<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coders@Work</title>
  
  
  <link href="https://davyjones2010.github.io/atom.xml" rel="self"/>
  
  <link href="https://davyjones2010.github.io/"/>
  <updated>2022-08-07T10:51:31.345Z</updated>
  <id>https://davyjones2010.github.io/</id>
  
  <author>
    <name>Davy Walker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从GitHub CLI禁止用户名密码登录引发的思考与总结</title>
    <link href="https://davyjones2010.github.io/2022-07-23-github-token-login/"/>
    <id>https://davyjones2010.github.io/2022-07-23-github-token-login/</id>
    <published>2022-07-23T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在本地CLI中push github代码时, 要求输入用户名密码, 但输入密码之后, 提示禁止使用密码登录.</p><ul><li>根据提示配置了半天SSH免登, 结果发现并不生效, push时仍然让输入账号名密码.</li><li>后续根据提示, 在<a href="https://github.com/settings/tokens">GitHub页面新申请了Token</a>, 然后使用 用户名+Token 登录就可以了.<br>从而引发了诸多疑问与思考.</li></ul><h1 id="GitHub访问几种方式"><a href="#GitHub访问几种方式" class="headerlink" title="GitHub访问几种方式"></a>GitHub访问几种方式</h1><h2 id="方案1-SSH方式"><a href="#方案1-SSH方式" class="headerlink" title="方案1: SSH方式"></a>方案1: SSH方式</h2><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207242155452.png"></p><p>这种方式, 可以通过配置SSH免登即可.</p><h3 id="如何支持不同Host采用不同SSHKey"><a href="#如何支持不同Host采用不同SSHKey" class="headerlink" title="如何支持不同Host采用不同SSHKey?"></a>如何支持不同Host采用不同SSHKey?</h3><p>如果在本地, 既需要配置gitee的SSH免登, 又需要配置github的SSH免登, 有需要配置其他Host的SSH免登, 怎么能让不同的Host使用不同的公私钥对?</p><ul><li>配置样例如下:</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.ssh/config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-- 为 git@gitee.com:/xxx ssh地址配置Host gitee.com  HostName gitee.com  AddKeysToAgent <span class="token function">yes</span>  UseKeychain <span class="token function">yes</span>  IdentityFile ~/.ssh/id_rsa-- 为 git@github.com:xxx/xxx ssh地址配置Host github.com  HostName github.com  AddKeysToAgent <span class="token function">yes</span>  UseKeychain <span class="token function">yes</span>  IdentityFile ~/.ssh/id_ed25519-- 其他地址默认ssh地址配置Host *  AddKeysToAgent <span class="token function">yes</span>  UseKeychain <span class="token function">yes</span>  IdentityFile ~/.ssh/id_ed25519<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>验证是否配置正确:</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>davywalker@davywalkers-MacBook-Pro ~<span class="token punctuation">]</span>$ <span class="token function">ssh</span> git@github.comPTY allocation request failed on channel <span class="token number">1</span>Hi DavyJones2010<span class="token operator">!</span> You've successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方案2-HTTPS方式"><a href="#方案2-HTTPS方式" class="headerlink" title="方案2: HTTPS方式"></a>方案2: HTTPS方式</h2><h3 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h3><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207242155904.png"></p><p>这种方式, 即背景中的案例, 必须通过 用户名+Token方式 登录, 即CLI中密码字段, 不要输入账号的密码, 而是输入Token</p><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207242158549.png"></p><p>搜索了下, <strong>从2021年8月13日开始, GitHub已经禁止了 用户名+密码方式 登录</strong></p><blockquote><p>From August 13, 2021, <br/><br>GitHub is no longer accepting account passwords when authenticating Git operations. <br/><br>You need to add a PAT (Personal Access Token) instead, <br/><br>and you can follow the below method to add a PAT on your system. <br/></p></blockquote><h3 id="GitHub密码存储位置"><a href="#GitHub密码存储位置" class="headerlink" title="GitHub密码存储位置"></a>GitHub密码存储位置</h3><p>在使用SourceTree的时候, 由于repo使用的也是HTTPS, 因此也提示输入 用户名+密码, 由于密码方式被禁用, 因此后续再push这个repo, 会一直报禁止密码登录错误.<br>但也<mark>找不到修改&#x2F;删除该密码的位置.</mark></p><p>查了下资料, 不同的操作系统, 甚至同样操作系统的不同的版本, 存储方式都不同. 这里以 <a href="https://stackoverflow.com/questions/42584934/where-is-my-remote-git-repository-password-stored-on-the-local-machine">MacOS Monterey 12.3.1版本</a> 为例:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalkerdeMacBook-Pro:~ davywalker$ <span class="token function">git</span> config credential.helperosxkeychain<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看出来是由keychain进行的管理, 在Mac的 <code>Applications -&gt; Utilties -&gt; Keychain Access</code> </p><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207252101640.png"></p><ul><li>可以看到SourceTree应用保存的GitHub Repo密码.</li><li>同时也可以看到IntelliJ IDEA保存的GitHub Repo密码, 通过显示repo密码发现, 这个密码字段其实就是签发给Intellij的 PAT(Personal Access Token)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于<font color='red'>本地配置的remote repo是HTTPS方式, 因此通过配置SSH免登方式必然是无效的.</font> </p><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207242202265.png"></p><h1 id="登录安全思考"><a href="#登录安全思考" class="headerlink" title="登录安全思考"></a>登录安全思考</h1><h2 id="为啥禁止CLI-HTTPS方式通过用户名密码登录"><a href="#为啥禁止CLI-HTTPS方式通过用户名密码登录" class="headerlink" title="为啥禁止CLI HTTPS方式通过用户名密码登录?"></a>为啥禁止CLI HTTPS方式通过用户名密码登录?</h2><p>应该是担心密码泄露.<br>但会在哪种情况下泄露密码?</p><ol><li>存储过程: 为了防止每次push都重复输入, git client应该把用户名密码存储到本机某个位置了. </li><li>传输过程: HTTPS中间人攻击, 发生概率就较小了<br>所以应该还是密码存储的风险.<br>通过页面登录, 有交互方式可以实现MFA, 但<mark>CLI方式无法进行交互从而实现MFA.</mark><br>这样从而减弱了安全性.</li></ol><h2 id="为啥通过用户名-Token方式登录-就支持呢"><a href="#为啥通过用户名-Token方式登录-就支持呢" class="headerlink" title="为啥通过用户名+Token方式登录, 就支持呢"></a>为啥通过用户名+Token方式登录, 就支持呢</h2><h3 id="几种类型的Token"><a href="#几种类型的Token" class="headerlink" title="几种类型的Token"></a>几种类型的Token</h3><ul><li>密码: 时间维度是永久有效, 不可召回. 权限范围是无限的(除非子账号). 可能是有规律的.</li><li>SecretKey: 时间维度通常是永久有效(但支持设定长期), 可以召回. 权限范围是有限的. 通常是UUID等无规律的.</li><li>RefreshToken: 时间维度是较长维度(例如可以60天), 可以召回. 权限范围是有限的. 通常是UUID等无规律的.</li><li>AccessToken: 时间维度是较短维度(例如4个小时), 可以召回(但一般不召回, 通过召回RefreshToken实现). 权限范围是优先的. 通常是UUID等无规律的.</li></ul><h3 id="几种登录方式"><a href="#几种登录方式" class="headerlink" title="几种登录方式"></a>几种登录方式</h3><ul><li>方式1: 在网页端, 通常选择密码方式登录, 但需要开启MFA以加固安全. 以该方式作为安全性最强, 权限最大的方式. </li><li>方式2: 在服务端SDK里, 通常选择SecretKey方式. SecretKey如果泄露, 可以通过方式1登录, 然后撤销SecretKey的有效性, 重新签发新的SecretKey. </li><li>方式3: 在移动端SDK里, 通常会签发一个RefreshToken+AccessToken. 每次AccessToken过期之后, 重新通过RefreshToken调用API申请新的AccessToken.</li></ul><p>因此在GitHub CLI方式登录, 其实就是从方式1(但不带MFA)降级到方案2, 一是限制权限范围, 二是可以随时撤销. </p><h2 id="其他解决方案"><a href="#其他解决方案" class="headerlink" title="其他解决方案"></a>其他解决方案</h2><ul><li>也可以将remote repo切换成<a href="https://docs.github.com/en/get-started/getting-started-with-git/managing-remote-repositories#switching-remote-urls-from-https-to-ssh">SSH方式</a>, 并配置SSH免登实现.</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在本地CLI中push github代码时, 要求输入用户名密码, 但输入密码之后, 提示禁止使用密码登录.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据提示配置了半天SSH免登, 结果发现并不生效, push时仍然让输入账号名密码.&lt;/li&gt;
&lt;li&gt;后续根据提示, 在&lt;a href=&quot;https://github.com/settings/tokens&quot;&gt;GitHub页面新申请了Token&lt;/a&gt;, 然后使用 用户名+Token 登录就可以了.&lt;br&gt;从而引发了诸多疑问与思考.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;GitHub访问几种方式&quot;&gt;&lt;a href=&quot;#GitHub访问几种方式&quot; class=&quot;headerlink&quot; title=&quot;GitHub访问几种方式&quot;&gt;&lt;/a&gt;GitHub访问几种方式&lt;/h1&gt;&lt;h2 id=&quot;方案1-SSH方式&quot;&gt;&lt;a href=&quot;#方案1-SSH方式&quot; class=&quot;headerlink&quot; title=&quot;方案1: SSH方式&quot;&gt;&lt;/a&gt;方案1: SSH方式&lt;/h2&gt;&lt;h3 id=&quot;配置方式&quot;&gt;&lt;a href=&quot;#配置方式&quot; class=&quot;headerlink&quot; title=&quot;配置方式&quot;&gt;&lt;/a&gt;配置方式&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207242155452.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种方式, 可以通过配置SSH免登即可.&lt;/p&gt;
&lt;h3 id=&quot;如何支持不同Host采用不同SSHKey&quot;&gt;&lt;a href=&quot;#如何支持不同Host采用不同SSHKey&quot; class=&quot;headerlink&quot; title=&quot;如何支持不同Host采用不同SSHKey?&quot;&gt;&lt;/a&gt;如何支持不同Host采用不同SSHKey?&lt;/h3&gt;&lt;p&gt;如果在本地, 既需要配置gitee的SSH免登, 又需要配置github的SSH免登, 有需要配置其他Host的SSH免登, 怎么能让不同的Host使用不同的公私钥对?&lt;/p&gt;</summary>
    
    
    
    
    <category term="distributed-system" scheme="https://davyjones2010.github.io/tags/distributed-system/"/>
    
    <category term="login" scheme="https://davyjones2010.github.io/tags/login/"/>
    
    <category term="token" scheme="https://davyjones2010.github.io/tags/token/"/>
    
  </entry>
  
  <entry>
    <title>由ZK的SID/ZXID与snowflake算法引发的ID生成算法探讨</title>
    <link href="https://davyjones2010.github.io/2022-07-11-zk-uuid-gen/"/>
    <id>https://davyjones2010.github.io/2022-07-11-zk-uuid-gen/</id>
    <published>2022-07-11T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几种生成算法"><a href="#几种生成算法" class="headerlink" title="几种生成算法"></a>几种生成算法</h1><h2 id="zk里的sid生成算法"><a href="#zk里的sid生成算法" class="headerlink" title="zk里的sid生成算法"></a>zk里的sid生成算法</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li>一个long类型, 占用64位</li><li>由ZK服务端生成的.</li><li>当客户端与ZK服务端建立好TCP连接(或者说应用层连接)之后, 生成.</li></ul><h3 id="生成规则"><a href="#生成规则" class="headerlink" title="生成规则"></a>生成规则</h3><ol><li>获取当前时间(2013-10-04 21:59:42)的毫秒表示：1380895182327 用二进制表示为：</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122157745.png"></p><ol start="2"><li>将步骤1中的数值左移24位，得到：</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122157302.png"></p><ol start="3"><li>右移8位：</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122158285.png"></p><ol start="4"><li>添加机器标识: SID. id 表示配置在myid文件中的值，通常是整数1、2、3等,假设id为2：</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122158613.png"></p><ol start="5"><li>将步骤3和步骤4得到的两个64位表示的数值进行<code>或</code>操作：</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122158687.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">initializeNextSessionId</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> nextSid<span class="token punctuation">;</span>    nextSid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Time</span><span class="token punctuation">.</span><span class="token function">currentElapsedTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>    nextSid <span class="token operator">=</span> nextSid <span class="token operator">|</span> <span class="token punctuation">(</span>id <span class="token operator">&lt;&lt;</span> <span class="token number">56</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextSid <span class="token operator">==</span> <span class="token class-name">EphemeralType</span><span class="token punctuation">.</span>CONTAINER_EPHEMERAL_OWNER<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">++</span>nextSid<span class="token punctuation">;</span>  <span class="token comment">// this is an unlikely edge case, but check it just in case</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> nextSid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>{8位, 当前主机的myid} {40位, 毫秒时间戳} {16位, 单host递增序列号}<br>ZK主机启动时, 会把前 48位初始化好, 接下来每次有client链接到该host, 则后16位进行递增.</p><h3 id="线上样例"><a href="#线上样例" class="headerlink" title="线上样例"></a>线上样例</h3><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122158988.png"></p><p>例如, sid &#x3D; 0x3 518ae13bc4 16e8 本质上能拆分成:</p><ul><li>前8位: 0x3, 代表当前myid&#x3D;3, 是整个ZK集群的第3台服务器.</li><li>中间40位: 518ae13bc4, 代表初始化时时间戳. 由于移位时截断了最高位1, 因此实际的时间戳是 1518ae13bc4, 转成10进制1449733995460, 按照毫秒数转成时间戳2015-12-10 15:53:15, 可以知道该host启动是在这个时间点.</li><li>后16位: 16e8, 转成10进制, 5864, 代表是第5864个连接</li></ul><h3 id="碰撞分析"><a href="#碰撞分析" class="headerlink" title="碰撞分析"></a>碰撞分析</h3><p>思考SID产生规则, 是否有碰撞风险?</p><ol><li>前8位代表主机位, 最大支持256个主机, 如果集群有上千台服务器, 这样必然会重复, 但这样会导致碰撞么? –&gt; 不太会<ol><li>只要能保证前48位不重复, 即可以保证sid不碰撞. 因为后16位是单host粒度递增.</li></ol></li><li>前48位如何碰撞?<ol><li>即前8位相同的主机 myid&#x3D;1 (二进制 00000001) 与 myid&#x3D;257 (100000001)</li><li>在同一毫秒同时启动, 从而中间40位相同</li><li>而在实际小规模集群情况下, 基本很难产生.</li></ol></li><li>单机上, 后16位如果溢出怎么办?<ol><li>即单机上client反复创建session, 超过了2^16&#x3D;65535, 必然会重复!</li><li>经试验, 发现当后16位满了之后, 会向前边借位. 例如:<ol><li>单机上之前的sid: 0x3 764c3db1d3 768e</li><li>后续频繁创建session, 后16位满了, 变成 0x3 764c3db1d4 00e1</li></ol></li><li>看代码: 无脑地对sid做+1操作. 即使这样, 也不太会导致 中间40位碰撞. (有这个可能, 例如当前session频繁创建, 变成了 0x3 ffffffffff 768e, 接下来服务器在 ffffffffff 这个毫秒点启动, 但当前session未失效, 重新连接上去了.  从而sid从 0x3 ffffffffff 0000开始递增, 有可能重新生成了一个 0x3 ffffffffff 768e 的sid)</li></ol></li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122159565.png"></p><h2 id="zk里的zxid生成算法"><a href="#zk里的zxid生成算法" class="headerlink" title="zk里的zxid生成算法"></a>zk里的zxid生成算法</h2><h3 id="zxid组成"><a href="#zxid组成" class="headerlink" title="zxid组成"></a>zxid组成</h3><blockquote><p>The zxid has two parts: the epoch and a counter. <br/><br>In our implementation the zxid is a 64-bit number. <br/><br>We use the high order 32-bits for the epoch and the low order 32-bits for the counter.</p></blockquote><p>64位的long类型, 包含两部分: 前32位代表epoch(即选举次数); 后32位代表counter(即该zk集群中的update操作的次数, 基本是单调递增的).<br>但实际这样设计是有缺陷的:</p><ul><li>在实际场景中, quorum一般都是在较为稳定的内网环境下, 不太会因为网络问题导致发生failover选主切换; 因此epoch使用32位, 支持40亿次选举, 没啥必要.</li><li>而实际counter增长是比较迅猛的, 在支持1000qps的系统中, 50天左右counter就会溢出.</li><li>而counter溢出会导致发生一次强制选主, 从而把counter清零, 把epoch+1;</li><li>而在3.3.5版本之前, counter溢出不会选主, 存在bug, 导致zk集群整体不可用. <a href="https://issues.apache.org/jira/browse/ZOOKEEPER-1277">servers stop serving when lower 32bits of zxid roll over</a></li></ul><h3 id="zxid生成"><a href="#zxid生成" class="headerlink" title="zxid生成"></a>zxid生成</h3><ul><li>zxid必然是由leader生成, 保证单调递增, 不能由客户端生成.</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> epoch <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">long</span> counter <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">long</span> zxid <span class="token operator">=</span> epoch <span class="token operator">&lt;&lt;</span> <span class="token number">32</span> <span class="token operator">|</span> counter<span class="token punctuation">;</span><span class="token comment">// 新的update操作</span>zxid<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="zxid使用情况"><a href="#zxid使用情况" class="headerlink" title="zxid使用情况"></a>zxid使用情况</h3><p>可以使用如下脚本判断后32位使用量, 如果结果&gt;0.8, 代表使用量已经超过80%, 代表有风险.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> srvr <span class="token operator">|</span> <span class="token function">nc</span> <span class="token number">127.0</span>.0.1 <span class="token number">32188</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'/Zxid/&#123;printf "%f\n", and(strtonum($NF),0xffffffff)/2^32&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Snowflake-ID生成算法"><a href="#Snowflake-ID生成算法" class="headerlink" title="Snowflake ID生成算法"></a>Snowflake ID生成算法</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122159430.png"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>41位时间戳, 标识的时间范围是?</li></ul><p>1970-01-01 08:00:00 ~ 2039-09-07 23:47:35</p><blockquote><p>41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) 得到的值，这里的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年</p></blockquote><ul><li>10位机器id, 标识的机器数量范围是:</li></ul><p>1024 台, 5位datacenterId和 5位workerId</p><ul><li>12位序列号</li></ul><h3 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h3><p>RocketMQ, 消息ID是使用snowflake算法生成, 是由客户端产生.</p><ul><li>客户端如何知道自己的datacenterId?</li><li>可以通过配置, 也可以如下, 通过本机网卡的MAC生成, 参照：<a href="https://github.com/dromara/hutool/blob/a9310c2d305acac617ca656ea6ffc3be6cc48a4c/hutool-core/src/main/java/cn/hutool/core/util/IdUtil.java#L240">IdUtil.java</a></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 获取数据中心ID&lt;br> * 数据中心ID依赖于本地网卡MAC地址。 * &lt;p> * 此算法来自于mybatis-plus#Sequence * &lt;/p> * * @param maxDatacenterId 最大的中心ID * @return 数据中心ID * @since 5.7.3 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">getDataCenterId</span><span class="token punctuation">(</span><span class="token keyword">long</span> maxDatacenterId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span>maxDatacenterId <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"maxDatacenterId must be > 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>maxDatacenterId <span class="token operator">==</span> <span class="token class-name">Long</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        maxDatacenterId <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">long</span> id <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mac <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">&#123;</span>        mac <span class="token operator">=</span> <span class="token class-name">NetUtil</span><span class="token punctuation">.</span><span class="token function">getLocalHardwareAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UtilException</span> ignore<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// ignore</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> mac<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0x000000FF</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> mac<span class="token punctuation">[</span>mac<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0x0000FF00</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> mac<span class="token punctuation">[</span>mac<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">6</span><span class="token punctuation">;</span>        id <span class="token operator">=</span> id <span class="token operator">%</span> <span class="token punctuation">(</span>maxDatacenterId <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> id<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>客户端如何知道自己的工作机器ID? </li><li>根据进程PID与datacenterId生成, 参照：<a href="https://github.com/dromara/hutool/blob/a9310c2d305acac617ca656ea6ffc3be6cc48a4c/hutool-core/src/main/java/cn/hutool/core/util/IdUtil.java#L240">IdUtil.java</a></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 获取机器ID，使用进程ID配合数据中心ID生成&lt;br> * 机器依赖于本进程ID或进程名的Hash值。 * * &lt;p> * 此算法来自于mybatis-plus#Sequence * &lt;/p> * * @param datacenterId 数据中心ID * @param maxWorkerId  最大的机器节点ID * @return ID * @since 5.7.3 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">getWorkerId</span><span class="token punctuation">(</span><span class="token keyword">long</span> datacenterId<span class="token punctuation">,</span> <span class="token keyword">long</span> maxWorkerId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">StringBuilder</span> mpid <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mpid<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>datacenterId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        mpid<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">RuntimeUtil</span><span class="token punctuation">.</span><span class="token function">getPid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UtilException</span> igonre<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//ignore</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*     * MAC + PID 的 hashcode 获取16个低位     */</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>mpid<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>maxWorkerId <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="aws中资源ID生成算法"><a href="#aws中资源ID生成算法" class="headerlink" title="aws中资源ID生成算法"></a>aws中资源ID生成算法</h2><h3 id="方案1-Base36"><a href="#方案1-Base36" class="headerlink" title="方案1: Base36"></a>方案1: Base36</h3><p>代码如下, 优点是不需要占位符, 可以直接用<code>ALPHABET</code>甚至可以修改<code>ALPHABET</code>的顺序达到简单加密的效果.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Base36Test</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 26小写+26大写+10数字=62</span>    <span class="token comment">//public static String ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";</span>    <span class="token comment">// 26小写+10数字=36</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> ALPHABET <span class="token operator">=</span> <span class="token string">"0123456789abcdefghijklmnopqrstuvwxyz"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">encoding</span><span class="token punctuation">(</span><span class="token keyword">long</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"num must be greater than 0."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> num <span class="token operator">/=</span> <span class="token number">36</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>ALPHABET<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">decoding</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"str must not be empty."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            result <span class="token operator">+=</span> ALPHABET<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> dcId <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> izId <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> l <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> encoding <span class="token operator">=</span> <span class="token class-name">Base36Test</span><span class="token punctuation">.</span><span class="token function">encoding</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//int idx = (int)(Math.random() * 1024);</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        encoding <span class="token operator">=</span> <span class="token class-name">Base36Test</span><span class="token punctuation">.</span><span class="token function">encoding</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>        encoding <span class="token operator">=</span> <span class="token class-name">Base36Test</span><span class="token punctuation">.</span><span class="token function">encoding</span><span class="token punctuation">(</span><span class="token number">1023</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>        encoding <span class="token operator">=</span> <span class="token class-name">Base36Test</span><span class="token punctuation">.</span><span class="token function">encoding</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方案2-Base64"><a href="#方案2-Base64" class="headerlink" title="方案2: Base64"></a>方案2: Base64</h3><p>缺点是会有<code>=</code>占位符.</p><h1 id="时钟回拨问题"><a href="#时钟回拨问题" class="headerlink" title="时钟回拨问题"></a>时钟回拨问题</h1><ul><li>zk里的sid不太会有时钟回拨问题, 是因为时间戳是机器启动的时候生成的. 除非回拨时间特别长, 刚好回拨之后机器又重启了, 拿到了之前那个时间戳. 但考虑到实际场景, 实际不太会发生.<ul><li>机器重启不会那么频繁, 只会在启动时生成</li><li>时钟回拨, 一般都是亚秒级别的回拨</li></ul></li><li>rocketmq里snowflake, 由于是客户端每次生成时实时获取的时间戳, 因此即使回拨了几毫秒, 在生成ID速度非常快的情况下, 也有可能重复. 如何解决?<ul><li>比较挫的方案, 关闭ntp</li><li>比较好的方案: 当回拨时间小于15ms，就等时间追上来之后继续生成。</li></ul><ol><li>更好的方案, 当时间大于15ms时间我们通过<strong>更换workid</strong>来产生之前都没有产生过的来解决回拨问题。</li><li>最好的方案: 如下修改算法, 可以找2bit位作为时钟回拨位，发现有时钟回拨就将回拨位加1，达到最大位后再从0开始进行循环。</li></ol></li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122159865.png"></p><h1 id="方案比较"><a href="#方案比较" class="headerlink" title="方案比较"></a>方案比较</h1><ul><li><p>相同点: </p><ul><li>都使用long类型, 占用64位</li><li>都希望既能尽量减少碰撞, 又能反映递增趋势</li><li>组成结构都是: <code>主机编号+时间戳+递增编号</code></li></ul></li><li><p>差异点:</p><ul><li>时间戳: <ul><li>sid时间戳占用40位(完整的应该是41位, 但默认截断了最高位1); 而snowflake时间戳占用41位, 相对时间范围是79年, 绝对时间到2039年. </li><li>sid的时间戳, 是zk主机启动起来的时间戳, 之后在下次启动之前, 就不再变化了.</li><li>snowflake的时间戳, 是client相对于某个时间点的相对时间; 且是生成ID的当前时间, 下一个毫秒这个时间戳会变化.</li></ul></li></ul></li><li><p>其他</p><ul><li>zk的算法, 但单host增数量是65535(实际可以借40位, 即上千亿, 但有碰撞风险了), 适用于长连场景, 即session不会频繁创建, 从而导致后16位递增那么快.</li><li>snowflake算法, 支持单机每毫秒产生 2^12 &#x3D; 4096 个ID, 适用于创建ID非常频繁的场景.</li><li>假设, 用zk的算法来生成snowflake的id:<ul><li>如果还是机器启动时生成时间戳位, 那单机只能生成 2^16 &#x3D; 65535 个ID, 之后就只能借时间戳的位了, 可能会重复了!</li></ul></li><li>假设, 用snowflake来生成zk的sid: <ul><li>貌似没啥问题.</li></ul></li></ul></li></ul><h1 id="其他总结"><a href="#其他总结" class="headerlink" title="其他总结"></a>其他总结</h1><ol><li>sid, snowflakeID 本质上都是分布式ID生成, 需要保障几点:<ol><li>局部, 全局 唯一</li><li>趋势递增. (这点是UUID无法达到的效果, 因此不使用UUIDGen)</li></ol></li></ol><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul><li><a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></li><li><a href="https://www.cnblogs.com/jiangxinlingdu/p/8440413.html">https://www.cnblogs.com/jiangxinlingdu/p/8440413.html</a></li><li><a href="https://xie.infoq.cn/article/ed9b31c014342fd469627d42d">https://xie.infoq.cn/article/ed9b31c014342fd469627d42d</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;几种生成算法&quot;&gt;&lt;a href=&quot;#几种生成算法&quot; class=&quot;headerlink&quot; title=&quot;几种生成算法&quot;&gt;&lt;/a&gt;几种生成算法&lt;/h1&gt;&lt;h2 id=&quot;zk里的sid生成算法&quot;&gt;&lt;a href=&quot;#zk里的sid生成算法&quot; class=&quot;headerlink&quot; title=&quot;zk里的sid生成算法&quot;&gt;&lt;/a&gt;zk里的sid生成算法&lt;/h2&gt;&lt;h3 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个long类型, 占用64位&lt;/li&gt;
&lt;li&gt;由ZK服务端生成的.&lt;/li&gt;
&lt;li&gt;当客户端与ZK服务端建立好TCP连接(或者说应用层连接)之后, 生成.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;生成规则&quot;&gt;&lt;a href=&quot;#生成规则&quot; class=&quot;headerlink&quot; title=&quot;生成规则&quot;&gt;&lt;/a&gt;生成规则&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;获取当前时间(2013-10-04 21:59:42)的毫秒表示：1380895182327 用二进制表示为：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122157745.png&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;将步骤1中的数值左移24位，得到：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122157302.png&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;右移8位：&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="zookeeper" scheme="https://davyjones2010.github.io/tags/zookeeper/"/>
    
    <category term="distributed-system" scheme="https://davyjones2010.github.io/tags/distributed-system/"/>
    
    <category term="uuid" scheme="https://davyjones2010.github.io/tags/uuid/"/>
    
    <category term="snowflake" scheme="https://davyjones2010.github.io/tags/snowflake/"/>
    
    <category term="sid" scheme="https://davyjones2010.github.io/tags/sid/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络之HTTP Proxy原理与实现分析</title>
    <link href="https://davyjones2010.github.io/2022-07-10-linux-network-http-proxy/"/>
    <id>https://davyjones2010.github.io/2022-07-10-linux-network-http-proxy/</id>
    <published>2022-07-10T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在使用apache的HttpClient时(获取其他常用的httpclient), 经常会发现初始化时可以配置http proxy. 但有些疑问:</p><ol><li>在什么场景下需要使用http proxy?</li><li>具体http proxy怎么配置?</li><li>具体http proxy的实现原理是啥? 包括 httpClient 如何使用这个proxy? 具体的httpProxy怎么处理这种包?</li></ol><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>docker</li><li>ubuntu</li></ul><h2 id="http-proxy-服务端部署"><a href="#http-proxy-服务端部署" class="headerlink" title="http proxy 服务端部署"></a>http proxy 服务端部署</h2><p>Nginx通常是作为反向代理, 但其实也可以作为正向代理使用:  <a href="https://github.com/reiz/nginx_proxy">nginx_proxy</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d -p <span class="token number">9999</span>:8888 -v <span class="token variable">$&#123;<span class="token environment constant">PWD</span>&#125;</span>/nginx_allowlist.conf:/usr/local/nginx/conf/nginx.conf reiz/nginx_proxy:0.0.3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="http-proxy-客户端配置"><a href="#http-proxy-客户端配置" class="headerlink" title="http proxy 客户端配置"></a>http proxy 客户端配置</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span><span class="token class-name">HostConfiguration</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span><span class="token class-name">HttpClient</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span>methods<span class="token punctuation">.</span></span><span class="token class-name">GetMethod</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span>params<span class="token punctuation">.</span></span><span class="token class-name">HttpMethodParams</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpClientTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> ENCODING <span class="token operator">=</span> <span class="token string">"UTF-8"</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"https://www.google.com"</span><span class="token punctuation">;</span>                <span class="token class-name">HttpClient</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">HostConfiguration</span> hostConfiguration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HostConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hostConfiguration<span class="token punctuation">.</span><span class="token function">setProxy</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">9999</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">setHostConfiguration</span><span class="token punctuation">(</span>hostConfiguration<span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">getParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setParameter</span><span class="token punctuation">(</span>            <span class="token class-name">HttpMethodParams</span><span class="token punctuation">.</span>HTTP_CONTENT_CHARSET<span class="token punctuation">,</span> ENCODING<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">GetMethod</span> method <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetMethod</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">executeMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Code: "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">String</span> response <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getResponseBodyAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="客户端请求分析"><a href="#客户端请求分析" class="headerlink" title="客户端请求分析"></a>客户端请求分析</h2><p>不配置proxy:</p><ul><li>client —http get—&gt; <a href="http://www.google.com/">www.google.com</a></li></ul><p>配置了proxy:</p><ul><li>client — tcp —&gt; proxy — http get —&gt;  <a href="http://www.google.com/">www.google.com</a></li></ul><p>可以看到, client.executeMethod实质上是:</p><ol><li>client先与proxy建立了TCP连接.</li><li>然后将HTTP报文, 包括目标域名(即GET <a href="http://www.google.com/">http://www.google.com</a>), 作为TCP的output stream传给proxy</li><li>proxy解析tcp报文, 获取到真正的目标域名, 查找DNS获取到google.com的ip地址.</li><li>proxy与google.com建立TCP连接, 发送报文body等.</li></ol><p>这种也叫: relay, 即中继.</p><h2 id="实际连接分析"><a href="#实际连接分析" class="headerlink" title="实际连接分析"></a>实际连接分析</h2><h3 id="host上，-LISTEN了9999端口"><a href="#host上，-LISTEN了9999端口" class="headerlink" title="host上， LISTEN了9999端口"></a>host上， LISTEN了9999端口</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/PlayGround/docker/nginx-forward-proxy$ <span class="token function">netstat</span> -natp <span class="token operator">|</span> <span class="token function">fgrep</span> <span class="token number">9999</span><span class="token punctuation">(</span>Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.<span class="token punctuation">)</span>tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:9999            <span class="token number">0.0</span>.0.0:*               LISTEN      -                   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容器内部，-LISTEN了8888端口"><a href="#容器内部，-LISTEN了8888端口" class="headerlink" title="容器内部， LISTEN了8888端口"></a>容器内部， LISTEN了8888端口</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@84129a407795:/app<span class="token comment"># netstat -nat | fgrep 8888</span>tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:8888            <span class="token number">0.0</span>.0.0:*               LISTEN     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="在Host上某个java进程发起一个HTTP请求之后"><a href="#在Host上某个java进程发起一个HTTP请求之后" class="headerlink" title="在Host上某个java进程发起一个HTTP请求之后"></a>在Host上某个java进程发起一个HTTP请求之后</h3><ul><li><p>HOST上 Java 进程</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads/Clash-Linux$ <span class="token function">netstat</span> -natp <span class="token operator">|</span> <span class="token function">fgrep</span> <span class="token number">9999</span><span class="token punctuation">(</span>Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.<span class="token punctuation">)</span>tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:9999            <span class="token number">0.0</span>.0.0:*               LISTEN      -                   tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:9999          <span class="token number">127.0</span>.0.1:42261         TIME_WAIT   -                   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>容器内部</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@84129a407795:/app<span class="token comment"># netstat -nat | fgrep 8888</span>tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:8888            <span class="token number">0.0</span>.0.0:*               LISTEN     tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">172.17</span>.0.4:8888         <span class="token number">172.17</span>.0.1:51960        TIME_WAIT  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>TODO:</p><ul><li>在访问<code>http://www.google.com</code>时，Java测试代码正常返回结果。</li><li>在访问<code>http://www.baidu.com</code>时， Java会出现如下异常，理论上由于不在nginx的白名单里应该被block的，但为啥会抛出异常？<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>IOException</span><span class="token operator">:</span> <span class="token class-name">Stream</span> closedat <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>BufferedInputStream</span><span class="token punctuation">.</span><span class="token function">getBufIfOpen</span><span class="token punctuation">(</span><span class="token class-name">BufferedInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">170</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>BufferedInputStream</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">BufferedInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">336</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span>WireLogInputStream</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">WireLogInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">69</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span>ContentLengthInputStream</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">ContentLengthInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">170</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>FilterInputStream</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">FilterInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">133</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span>AutoCloseInputStream</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">AutoCloseInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">108</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>FilterInputStream</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">FilterInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">107</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span>AutoCloseInputStream</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">AutoCloseInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span>HttpMethodBase</span><span class="token punctuation">.</span><span class="token function">getResponseBody</span><span class="token punctuation">(</span><span class="token class-name">HttpMethodBase</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">690</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span>HttpMethodBase</span><span class="token punctuation">.</span><span class="token function">getResponseBodyAsString</span><span class="token punctuation">(</span><span class="token class-name">HttpMethodBase</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">803</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">edu<span class="token punctuation">.</span>xmu<span class="token punctuation">.</span>test<span class="token punctuation">.</span>javaweb<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span>HttpClientProxyTest</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token class-name">HttpClientProxyTest</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">31</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h1 id="再回到实践中"><a href="#再回到实践中" class="headerlink" title="再回到实践中"></a>再回到实践中</h1><h2 id="实践1：-DNS劫持-正向代理过滤域名"><a href="#实践1：-DNS劫持-正向代理过滤域名" class="headerlink" title="实践1： DNS劫持+正向代理过滤域名"></a>实践1： DNS劫持+正向代理过滤域名</h2><p>通过DNS劫持，将所有HTTP请求都定位到正向代理中，在正向代理里进行代理域名的黑白名单控制。</p><ul><li>缺点：<ul><li>DNS劫持可以被手动禁用，也可以手动指定<code>8.8.8.8</code>绕过DNS服务器（当然如果DNS请求直接都被劫持，）。</li><li>只针对HTTP请求有效，如果知道目标的IP, 可以通过IP直连上。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在使用apache的HttpClient时(获取其他常用的httpclient), 经常会发现初始化时可以配置http proxy. 但有些疑问:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在什么场景下需要使用http proxy?&lt;/li&gt;
&lt;li&gt;具体http proxy怎么配置?&lt;/li&gt;
&lt;li&gt;具体http proxy的实现原理是啥? 包括 httpClient 如何使用这个proxy? 具体的httpProxy怎么处理这种包?&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;实践&quot;&gt;&lt;a href=&quot;#实践&quot; class=&quot;headerlink&quot; title=&quot;实践&quot;&gt;&lt;/a&gt;实践&lt;/h1&gt;&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;docker&lt;/li&gt;
&lt;li&gt;ubuntu&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;http-proxy-服务端部署&quot;&gt;&lt;a href=&quot;#http-proxy-服务端部署&quot; class=&quot;headerlink&quot; title=&quot;http proxy 服务端部署&quot;&gt;&lt;/a&gt;http proxy 服务端部署&lt;/h2&gt;&lt;p&gt;Nginx通常是作为反向代理, 但其实也可以作为正向代理使用:  &lt;a href=&quot;https://github.com/reiz/nginx_proxy&quot;&gt;nginx_proxy&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;docker&lt;/span&gt; run -d -p &lt;span class=&quot;token number&quot;&gt;9999&lt;/span&gt;:8888 -v &lt;span class=&quot;token variable&quot;&gt;$&amp;#123;&lt;span class=&quot;token environment constant&quot;&gt;PWD&lt;/span&gt;&amp;#125;&lt;/span&gt;/nginx_allowlist.conf:/usr/local/nginx/conf/nginx.conf reiz/nginx_proxy:0.0.3&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;http-proxy-客户端配置&quot;&gt;&lt;a href=&quot;#http-proxy-客户端配置&quot; class=&quot;headerlink&quot; title=&quot;http proxy 客户端配置&quot;&gt;&lt;/a&gt;http proxy 客户端配置&lt;/h2&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://davyjones2010.github.io/tags/linux/"/>
    
    <category term="iaas" scheme="https://davyjones2010.github.io/tags/iaas/"/>
    
    <category term="network" scheme="https://davyjones2010.github.io/tags/network/"/>
    
    <category term="cloud-computing" scheme="https://davyjones2010.github.io/tags/cloud-computing/"/>
    
    <category term="http-proxy" scheme="https://davyjones2010.github.io/tags/http-proxy/"/>
    
    <category term="proxy" scheme="https://davyjones2010.github.io/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>记一次分布式场景下状态机设计缺陷导致的问题</title>
    <link href="https://davyjones2010.github.io/2022-07-06-state-machine-in-distributed-system/"/>
    <id>https://davyjones2010.github.io/2022-07-06-state-machine-in-distributed-system/</id>
    <published>2022-07-06T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li><p>为某个对象item建模, 有如下几种状态变迁, 在数据库中state字段记录:<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207072308671.png"></p></li><li><p>其中processing过程可能会持续时间较久, 10min左右</p></li><li><p>在服务端某个线程响应请求, 该对象处于processing过程中时, 服务器发布重启, 导致item状态一直卡在processing </p></li><li><p>而processing状态, <strong>本身是中间状态, 无法进行任何人肉干预&#x2F;操作</strong>, 从而导致只能临时提交数据订正, 将状态字段修改回”init”, 然后再执行一次process.</p></li></ul><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>仔细思考了下, 发现设计的时候, 根本原因是对于中间状态没有做好处理, 如背景中介绍的服务重启的处理.<br>而<mark>在分布式场景下, 服务重启是by design需要被接受的.</mark><br>这里思考了下可能的几种处理方式:</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul><li>如何区分状态机的中间状态与终态? </li><li>一条原则: <mark>终态-&gt;终态之间, 必须是可以人肉有入口触发的(而不是系统自动触发的); 必须是可重入的.</mark></li></ul><h2 id="方案1-状态机设计修改-把processing作为纯粹的中间状态"><a href="#方案1-状态机设计修改-把processing作为纯粹的中间状态" class="headerlink" title="方案1: 状态机设计修改: 把processing作为纯粹的中间状态"></a>方案1: 状态机设计修改: 把processing作为纯粹的中间状态</h2><ol><li><p>将processing从状态机中删除掉, 如下: <br/><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207072351350.png"></p></li><li><p>使用 分布式锁&#x2F;db字段锁 来实现排他功能(即item同时只能被一个线程处理, 防止多个线程同时处理一个item导致死锁&#x2F;重复计算等问题).</p><ol><li>在item执行前, 加上锁+锁超时时间(如例子中的10min); 其他线程要执行时, 无法抢到该item的锁. </li><li>item执行完成之后, 状态修改为finished之后, 再释放掉item锁.</li><li>item执行异常中断(例如服务器重启, 线程crash等): 等待锁超时. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.</li><li>item执行失败: 线程里catch住异常, 主动释放掉该item锁. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.</li></ol></li><li><p>或者使用事务:(不过本例子中不适合, 因为10min太久了, 其他执行耗时较短30s以内的可以使用该方案)  </p><ol><li>item执行前开启事务;</li><li>执行后修改状态为finished, commit事务.</li><li>item执行异常中断(例如服务器重启, 线程crash等): 事务自动回滚. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.</li><li>item执行失败: 主动回滚事务. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.</li></ol></li></ol><h2 id="方案2-状态机设计修改-把processing作为纯粹的终态"><a href="#方案2-状态机设计修改-把processing作为纯粹的终态" class="headerlink" title="方案2: 状态机设计修改: 把processing作为纯粹的终态"></a>方案2: 状态机设计修改: 把processing作为纯粹的终态</h2><ol><li><p>需要设计从processing-&gt;finished&#x2F;init的人肉触发入口.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207072354738.png"></p></li><li><p>如何防止多个线程同时触发该item从processing-&gt;finished&#x2F;init的变迁? 参见方案1中锁&#x2F;事务的方式</p></li></ol><h2 id="方案3-优雅停机"><a href="#方案3-优雅停机" class="headerlink" title="方案3: 优雅停机"></a>方案3: 优雅停机</h2><ol><li>在shutdown-hook里注册事件:<ol><li>将状态改回init. –&gt; required.</li><li>将worker线程interrupt掉. –&gt; optional, 因为即使不interrupt, 进程停止线程也会被回收.</li></ol></li><li>但该方案有很大的缺陷, 如果直接<code>kill -9</code>, 则shutdown-hook根本不会执行.</li></ol><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>最终采用了方案2, 因为从状态机中删除掉一个终态, 对现有代码改造量太大了.</p><h1 id="其他思考"><a href="#其他思考" class="headerlink" title="其他思考"></a>其他思考</h1><ol><li>状态机设计的时候, 一定要慎重考虑哪些是终态, 哪些是中间状态. 不是说因为在某个状态持续时间较长(如例子中的processing), 就要作为终态. </li><li>状态机中每个终态之间, 必须考虑可重入性; 必须要保证能人肉触发终态之间的转化. 本文的例子就是反面教材, item卡在processing这个终态, 无法进行程序上的任何操作.</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为某个对象item建模, 有如下几种状态变迁, 在数据库中state字段记录:&lt;br&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207072308671.png&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其中processing过程可能会持续时间较久, 10min左右&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在服务端某个线程响应请求, 该对象处于processing过程中时, 服务器发布重启, 导致item状态一直卡在processing &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;而processing状态, &lt;strong&gt;本身是中间状态, 无法进行任何人肉干预&amp;#x2F;操作&lt;/strong&gt;, 从而导致只能临时提交数据订正, 将状态字段修改回”init”, 然后再执行一次process.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;方案&quot;&gt;&lt;a href=&quot;#方案&quot; class=&quot;headerlink&quot; title=&quot;方案&quot;&gt;&lt;/a&gt;方案&lt;/h1&gt;&lt;p&gt;仔细思考了下, 发现设计的时候, 根本原因是对于中间状态没有做好处理, 如背景中介绍的服务重启的处理.&lt;br&gt;而&lt;mark&gt;在分布式场景下, 服务重启是by design需要被接受的.&lt;/mark&gt;&lt;br&gt;这里思考了下可能的几种处理方式:&lt;/p&gt;
&lt;h2 id=&quot;原则&quot;&gt;&lt;a href=&quot;#原则&quot; class=&quot;headerlink&quot; title=&quot;原则&quot;&gt;&lt;/a&gt;原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如何区分状态机的中间状态与终态? &lt;/li&gt;
&lt;li&gt;一条原则: &lt;mark&gt;终态-&amp;gt;终态之间, 必须是可以人肉有入口触发的(而不是系统自动触发的); 必须是可重入的.&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;方案1-状态机设计修改-把processing作为纯粹的中间状态&quot;&gt;&lt;a href=&quot;#方案1-状态机设计修改-把processing作为纯粹的中间状态&quot; class=&quot;headerlink&quot; title=&quot;方案1: 状态机设计修改: 把processing作为纯粹的中间状态&quot;&gt;&lt;/a&gt;方案1: 状态机设计修改: 把processing作为纯粹的中间状态&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将processing从状态机中删除掉, 如下: &lt;br&gt;&lt;br&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207072351350.png&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 分布式锁&amp;#x2F;db字段锁 来实现排他功能(即item同时只能被一个线程处理, 防止多个线程同时处理一个item导致死锁&amp;#x2F;重复计算等问题).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在item执行前, 加上锁+锁超时时间(如例子中的10min); 其他线程要执行时, 无法抢到该item的锁. &lt;/li&gt;
&lt;li&gt;item执行完成之后, 状态修改为finished之后, 再释放掉item锁.&lt;/li&gt;
&lt;li&gt;item执行异常中断(例如服务器重启, 线程crash等): 等待锁超时. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.&lt;/li&gt;
&lt;li&gt;item执行失败: 线程里catch住异常, 主动释放掉该item锁. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;或者使用事务:(不过本例子中不适合, 因为10min太久了, 其他执行耗时较短30s以内的可以使用该方案)  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;item执行前开启事务;&lt;/li&gt;
&lt;li&gt;执行后修改状态为finished, commit事务.&lt;/li&gt;
&lt;li&gt;item执行异常中断(例如服务器重启, 线程crash等): 事务自动回滚. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.&lt;/li&gt;
&lt;li&gt;item执行失败: 主动回滚事务. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;方案2-状态机设计修改-把processing作为纯粹的终态&quot;&gt;&lt;a href=&quot;#方案2-状态机设计修改-把processing作为纯粹的终态&quot; class=&quot;headerlink&quot; title=&quot;方案2: 状态机设计修改: 把processing作为纯粹的终态&quot;&gt;&lt;/a&gt;方案2: 状态机设计修改: 把processing作为纯粹的终态&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;需要设计从processing-&amp;gt;finished&amp;#x2F;init的人肉触发入口.&lt;br&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207072354738.png&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何防止多个线程同时触发该item从processing-&amp;gt;finished&amp;#x2F;init的变迁? 参见方案1中锁&amp;#x2F;事务的方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="learn-from-failure" scheme="https://davyjones2010.github.io/tags/learn-from-failure/"/>
    
    <category term="java" scheme="https://davyjones2010.github.io/tags/java/"/>
    
    <category term="good-design" scheme="https://davyjones2010.github.io/tags/good-design/"/>
    
    <category term="bad-design" scheme="https://davyjones2010.github.io/tags/bad-design/"/>
    
    <category term="state-machine" scheme="https://davyjones2010.github.io/tags/state-machine/"/>
    
    <category term="lock" scheme="https://davyjones2010.github.io/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>一些有意思的记录-4</title>
    <link href="https://davyjones2010.github.io/2022-07-03-random-snippets/"/>
    <id>https://davyjones2010.github.io/2022-07-03-random-snippets/</id>
    <published>2022-07-03T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.345Z</updated>
    
    <content type="html"><![CDATA[<p>五看: 看趋势, 看市场, 看客户, 看竞争, 看自己.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;五看: 看趋势, 看市场, 看客户, 看竞争, 看自己.&lt;/p&gt;
</summary>
    
    
    
    
    <category term="soft-skills" scheme="https://davyjones2010.github.io/tags/soft-skills/"/>
    
  </entry>
  
  <entry>
    <title>记一次Dubbo应用性能优化</title>
    <link href="https://davyjones2010.github.io/2022-07-02-dubbo-app-perf-tunning/"/>
    <id>https://davyjones2010.github.io/2022-07-02-dubbo-app-perf-tunning/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>新的应用以dubbo接口对外暴露调度能力。<br>在上线前需要整体压测，确认下系统能力与瓶颈。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>目标QPS: 500+<br>目标RT: 100ms-</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042216549.png"></p><h2 id="应用框架"><a href="#应用框架" class="headerlink" title="应用框架"></a>应用框架</h2><ul><li>SpringBoot 2.5.6</li><li>Druid 1.1.22</li></ul><h2 id="机器配置清单"><a href="#机器配置清单" class="headerlink" title="机器配置清单"></a>机器配置清单</h2><ul><li>ECS规格： ecs.n4.2xlarge</li><li>2台8C16G 独享型</li><li>CPU: 2.5 GHz主频的Intel ® Xeon ®处理器</li><li>JDK 1.8</li><li>网络： 1.2Gbps，即至少支持100MB&#x2F;s的内网带宽</li></ul><h2 id="中间件配置清单"><a href="#中间件配置清单" class="headerlink" title="中间件配置清单"></a>中间件配置清单</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>规格：8C32GB</li><li>支持的最大连接数量：30000</li><li>Host到Redis的Ping延时在1ms以内</li></ul><h3 id="DB-x2F-RDS"><a href="#DB-x2F-RDS" class="headerlink" title="DB&#x2F;RDS"></a>DB&#x2F;RDS</h3><ul><li>规格：mysql.x4.4xlarge.2 32C128GB</li><li>MySQL 5.7</li><li>支持的最大连接数量：20000</li><li>Host到DB的Ping延时在1ms以内</li></ul><h1 id="压测记录"><a href="#压测记录" class="headerlink" title="压测记录"></a>压测记录</h1><h2 id="第一轮压测"><a href="#第一轮压测" class="headerlink" title="第一轮压测"></a>第一轮压测</h2><h3 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h3><ul><li>压到140QPS时， RT已经飙升到8s+；</li></ul><h3 id="其他指标"><a href="#其他指标" class="headerlink" title="其他指标"></a>其他指标</h3><ul><li>cpu: 已经基本跑满了，利用率780+%；</li><li>mem: 内存占用量很低，总体稳定在34%左右。</li><li>网络： 总体入流量在10Mbps以下，出流量1Mbps以下，远远没有打到带宽上限。</li><li>磁盘： 没有频繁的磁盘IO</li><li>Java: 没有发生频繁的GC。</li></ul><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>根据应用日志，发现有如下几个问题：</p><ul><li>Redis访问<ul><li>单次schedule()请求，会连续串行调用40+次的redis get接口。</li><li>这些串行的get调用，加起来平均耗时在6s+</li></ul></li><li>其他问题：<ul><li>apache.util中Pair类型序列化问题</li></ul></li></ul><h3 id="Redis访问速度慢问题分析"><a href="#Redis访问速度慢问题分析" class="headerlink" title="Redis访问速度慢问题分析"></a>Redis访问速度慢问题分析</h3><h4 id="是否是服务端问题？"><a href="#是否是服务端问题？" class="headerlink" title="是否是服务端问题？"></a>是否是服务端问题？</h4><p>查看了Redis服务端整体性能情况：</p><ul><li>出口帶寬爲100MB，當時只利用了10%左右</li><li>CPU Usage 14% 左右</li><li>連接數：最大支持30000，當時只有3個穩定的連接</li><li>QPS: 高峯期QPS爲6000，而實例的max爲24w，使用率僅爲2.5%，遠遠沒有達到限流閾值</li></ul><h4 id="是否是客户端问题？"><a href="#是否是客户端问题？" class="headerlink" title="是否是客户端问题？"></a>是否是客户端问题？</h4><ul><li>網絡流量：10MB左右，遠遠沒有打滿。</li><li>Load: 很低，0.2以下</li></ul><h4 id="問題定位"><a href="#問題定位" class="headerlink" title="問題定位"></a>問題定位</h4><p>在這種情況下，一般就只能懷疑是client連接問題。類似HttpClient，客戶端請求都在排隊等着獲取connection。</p><ul><li>方案1： 增大連接池配置，增大最大連接數量。</li><li>方案2： 減少請求次數</li></ul><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>Redis优化：<ul><li>采用了方案2： 使用Redis的mget，而不是单个get。以减少网络交互</li><li>为啥没采用方案1？ <blockquote><p>因为 SpringBoot 1.5.x 版本默认使用Jedis作为redis client，比较好调整connection数量等。<br/><br>但 SpringBoot 2.x 版本默认使用了Lettuce作为redis client，本身基于Netty的异步IO方式实现，与Jedis不同，本身就支持单个连接被多个线程同时访问。<br>所以官方不建议配置连接池。</p></blockquote></li></ul></li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042214249.png"></p><ul><li>其他问题优化<ul><li>自己重新实现了一版Pair类型的序列化、反序列化方式</li></ul></li></ul><h2 id="第二轮压测"><a href="#第二轮压测" class="headerlink" title="第二轮压测"></a>第二轮压测</h2><h3 id="压测结果-1"><a href="#压测结果-1" class="headerlink" title="压测结果"></a>压测结果</h3><ul><li>在250QPS时，RT基本稳定在100ms以下</li><li>压到300QPS时，RT突然飙升到3s+</li><li>cpu利用率较低</li><li>内存占用量很低，总体稳定在34%左右</li><li>没有发生GC</li></ul><h3 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h3><p>根据日志打点，很容易找到当时的瓶颈就在ram-client调用鉴权服务鉴权上。</p><ul><li>RAM接口问题：</li></ul><h3 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>RAM Client优化：<ul><li>增大client的max-connections数量，增大到300。</li></ul></li></ul><blockquote><p>这里有个插曲，当增大client的max-connections数量到300之后，重新进行了一次压测，发现QPS并没有提升，RT的瓶颈仍然在访问RAM上！ <br/><br>后续看了ram-client的发布记录，发现属于ram-client的一个bug。<br/><br>ram-client使用了http-client作为内部实现。<br/><br>当前版本中，增大max-connections数量，只是增大了httpclient全局支持的connection数量，而单个host支持的connection数量仍然是默认值，即8. <br/><br>由于访问ram的endpoint就是单个host，因此相当于该配置没有生效！ <br/><br>后续升级了ram-client版本，新版本实现里，将max-connections值同时赋给了max-connections-per-host，因此相当于max-connections-per-host也被调大为300了<br/><br>关于max-connections与max-connections-per-host参数的详细解释，参见： <a href="https://davyjones2010.github.io/2022-03-15-http-client-netty/">异步HttpClient使用Netty作为SocketChannel的Provider</a></p></blockquote><h2 id="第三轮压测"><a href="#第三轮压测" class="headerlink" title="第三轮压测"></a>第三轮压测</h2><h3 id="压测结果-2"><a href="#压测结果-2" class="headerlink" title="压测结果"></a>压测结果</h3><ul><li><p>200QPS, 80ms RT</p></li><li><p>300QPS，2000ms RT</p></li><li><p>结果与上轮相比，并没有显著提升。</p></li><li><p>根据日志分析，ramclient耗时已经趋于平稳，平均10ms以下，调度耗时又上来了。</p></li></ul><h3 id="其他指标-1"><a href="#其他指标-1" class="headerlink" title="其他指标"></a>其他指标</h3><ul><li>cpu: 利用率较高，780%+</li><li>mem: 内存占用量很低，总体稳定在34%左右。</li><li>网络： 总体流量在10Mbps，远远没有打到带宽上限。</li><li>磁盘： 没有频繁的磁盘IO</li><li>Java: 没有发生频繁的GC。</li></ul><h3 id="原因分析-2"><a href="#原因分析-2" class="headerlink" title="原因分析"></a>原因分析</h3><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042215103.png"><br>根据当时的线程堆栈分析，占用CPU量最大的就是8个lettuce线程，几乎把CPU时间片占满了。<br>同时搜索了相关问题 ，发现<a href="https://gitter.im/lettuce-io/Lobby?at=5de8f93446397c721c8ed8ed">不是个例</a>。<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042215636.png"></p><h3 id="优化方案-2"><a href="#优化方案-2" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>Redis:<ul><li>使用Jedis作为Client，并且调大Jedis对应的连接池数量</li></ul></li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">spring.redis.client-type</span><span class="token punctuation">=</span><span class="token value attr-value">jedis</span><span class="token key attr-name">spring.redis.jedis.pool.max-active</span><span class="token punctuation">=</span><span class="token value attr-value">100</span><span class="token key attr-name">spring.redis.jedis.pool.max-idle</span><span class="token punctuation">=</span><span class="token value attr-value">16</span><span class="token key attr-name">spring.redis.jedis.pool.max-wait</span><span class="token punctuation">=</span><span class="token value attr-value">10000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第四轮压测"><a href="#第四轮压测" class="headerlink" title="第四轮压测"></a>第四轮压测</h2><h3 id="压测结果-3"><a href="#压测结果-3" class="headerlink" title="压测结果"></a>压测结果</h3><ul><li>300QPS，100ms RT</li><li>350QPS，200ms RT</li><li>400QPS，2000ms RT</li></ul><h3 id="其他指标-2"><a href="#其他指标-2" class="headerlink" title="其他指标"></a>其他指标</h3><ul><li>cpu: 利用率较高，780%+</li><li>mem: 内存占用量很低，总体稳定在34%左右。</li><li>网络： 总体流量在10Mbps，远远没有打到带宽上限。</li><li>磁盘： 没有频繁的磁盘IO</li><li>Java: 没有发生频繁的GC。</li></ul><h3 id="原因分析-3"><a href="#原因分析-3" class="headerlink" title="原因分析"></a>原因分析</h3><p>打印出了当时的线程栈信息，进行了详细的分析如下：</p><table><thead><tr><th>操作</th><th>线程数量</th></tr></thead><tbody><tr><td>獲取Druid連接</td><td>442</td></tr><tr><td>歸還Druid連接</td><td>164</td></tr><tr><td>業務線程中Bind操作</td><td>107</td></tr><tr><td>Log4j打印</td><td>77</td></tr><tr><td>Jedis執行</td><td>2</td></tr></tbody></table><ul><li>大部分线程卡在Druid数据库连接池归还连接、获取连接的搶鎖阶段（lock()）</li><li>小部分线程由于bind()异步线程池队列满，导致占用了业务线程</li><li>最后一部分线程卡（blocked）在log4j打印日志</li></ul><h4 id="Druid连接池问题"><a href="#Druid连接池问题" class="headerlink" title="Druid连接池问题"></a>Druid连接池问题</h4><p>與 <a href="https://blog.csdn.net/beFocused/article/details/108533137">记一次Dubbo线程耗尽的问题-druid数据库连接池突发性能</a> 文中的問題一模一樣。</p><h4 id="异步线程队列满问题"><a href="#异步线程队列满问题" class="headerlink" title="异步线程队列满问题"></a>异步线程队列满问题</h4><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042216269.png"></p><p>隊列默認長度爲200，在200的長度滿了之後，使用的是<code>ThreadPoolExecutor.CallerRunsPolicy</code>, 即不再在異步線程裏執行，而是在caller線程中執行。<br>從而導致業務線程壓力進一步增大。</p><h4 id="Log4j日志问题"><a href="#Log4j日志问题" class="headerlink" title="Log4j日志问题"></a>Log4j日志问题</h4><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042216085.png"><br>也是比較經典的問題，使用Log2j的異步logger即可解決。</p><h3 id="优化方案-3"><a href="#优化方案-3" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li><p>Druid优化： </p><ul><li>增大连接池中initial与max的连接数量</li><li>使用非公平锁，而不是默认的公平锁。具体参见<a href="https://mp.weixin.qq.com/s/RaiU9_ioWHvomZLLKuSuGw">有赞的压测记录</a>。<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">spring.datasource.druid.maxActive</span><span class="token punctuation">=</span><span class="token value attr-value">600</span><span class="token key attr-name">spring.datasource.druid.initialSize</span><span class="token punctuation">=</span><span class="token value attr-value">300</span><span class="token key attr-name">spring.datasource.druid.maxWait</span><span class="token punctuation">=</span><span class="token value attr-value">6000</span><span class="token key attr-name">spring.datasource.druid.minIdle</span><span class="token punctuation">=</span><span class="token value attr-value">300</span><span class="token key attr-name">spring.datasource.druid.poolPreparedStatements</span><span class="token punctuation">=</span><span class="token value attr-value">true</span><span class="token key attr-name">spring.datasource.druid.maxOpenPreparedStatements</span><span class="token punctuation">=</span><span class="token value attr-value">20</span><span class="token key attr-name">spring.datasource.druid.useUnfairLock</span><span class="token punctuation">=</span><span class="token value attr-value">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>bind线程池优化：</p><ul><li>增大队列大小，从200增大到20000</li></ul></li><li><p>log4j优化：</p><ul><li>使用log4j2的asyncLogger。</li></ul></li></ul><h2 id="第五轮压测"><a href="#第五轮压测" class="headerlink" title="第五轮压测"></a>第五轮压测</h2><h3 id="压测结果-4"><a href="#压测结果-4" class="headerlink" title="压测结果"></a>压测结果</h3><ul><li>在600QPS时，RT基本稳定在40ms以下。</li><li>由于每次调用接口，都会调用一次ram鉴权接口，ram整体限制单个租户需要小于600qps；也担心把ram接口打挂或者被ram限流，因此不再继续压测。</li><li>按照其他指标推测，<mark> 理论上可以打到1000QPS+，即单机500QPS+ </mark></li><li>终于达标了！~ 撒花庆祝~~~</li></ul><h3 id="其他指标-3"><a href="#其他指标-3" class="headerlink" title="其他指标"></a>其他指标</h3><ul><li>cpu: 利用率较低，400%左右</li><li>mem: 内存占用量很低，总体稳定在34%左右。</li><li>网络： 总体流量在10Mbps，远远没有打到带宽上限。</li><li>磁盘： 没有频繁的磁盘IO</li><li>Java: 没有发生频繁的GC。</li></ul><h1 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;新的应用以dubbo接口对外暴露调度能力。&lt;br&gt;在上线前需要整体压测，确认下系统能力与瓶颈。&lt;/p&gt;
&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;p&gt;目标QPS: 500+&lt;br&gt;目标RT: 100ms-&lt;/p&gt;
&lt;h2 id=&quot;整体架构&quot;&gt;&lt;a href=&quot;#整体架构&quot; class=&quot;headerlink&quot; title=&quot;整体架构&quot;&gt;&lt;/a&gt;整体架构&lt;/h2&gt;&lt;p&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042216549.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;应用框架&quot;&gt;&lt;a href=&quot;#应用框架&quot; class=&quot;headerlink&quot; title=&quot;应用框架&quot;&gt;&lt;/a&gt;应用框架&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SpringBoot 2.5.6&lt;/li&gt;
&lt;li&gt;Druid 1.1.22&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;机器配置清单&quot;&gt;&lt;a href=&quot;#机器配置清单&quot; class=&quot;headerlink&quot; title=&quot;机器配置清单&quot;&gt;&lt;/a&gt;机器配置清单&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ECS规格： ecs.n4.2xlarge&lt;/li&gt;
&lt;li&gt;2台8C16G 独享型&lt;/li&gt;
&lt;li&gt;CPU: 2.5 GHz主频的Intel ® Xeon ®处理器&lt;/li&gt;
&lt;li&gt;JDK 1.8&lt;/li&gt;
&lt;li&gt;网络： 1.2Gbps，即至少支持100MB&amp;#x2F;s的内网带宽&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://davyjones2010.github.io/tags/java/"/>
    
    <category term="dubbo" scheme="https://davyjones2010.github.io/tags/dubbo/"/>
    
    <category term="perf-tunning" scheme="https://davyjones2010.github.io/tags/perf-tunning/"/>
    
    <category term="redis" scheme="https://davyjones2010.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java&amp;JVM&amp;OQL 常用命令与脚本总结</title>
    <link href="https://davyjones2010.github.io/2022-07-01-java-jvm/"/>
    <id>https://davyjones2010.github.io/2022-07-01-java-jvm/</id>
    <published>2022-07-01T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-amp-JVM"><a href="#Java-amp-JVM" class="headerlink" title="Java&amp;JVM"></a>Java&amp;JVM</h1><h2 id="打-HeapDump"><a href="#打-HeapDump" class="headerlink" title="打 HeapDump"></a>打 HeapDump</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jmap -dump:live,file<span class="token operator">=</span>heapdump.phrof <span class="token variable">$pid</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jmap -dump:live,file<span class="token operator">=</span>heapdump.phrof -F <span class="token variable">$pid</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>一般情况下，<mark>尽量不要使用-F参数。</mark> 因为-F使用的是Linux操作系统层面的实现，而不是JVM层面的实现，会导致 打印堆信息很慢。<br/><br>如果提示第一种方式打印不出来堆的信息，需要增加-F，那么可以先检查下：</p><ol><li>Java应用进程的user_name是否与当前的user_name相同？ 如果不同，需要切换为同一个账号。</li><li>Java应用进程的Java路径是否与当前jmap命令的路径相同？ 如果不同，需要切换为同一个路径。</li></ol></blockquote><h2 id="打-ThreadDump"><a href="#打-ThreadDump" class="headerlink" title="打 ThreadDump"></a>打 ThreadDump</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jstack <span class="token variable">$pid</span> <span class="token operator">></span> tmp.jstack<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意: 当CPU利用率高或者想看下线程卡在哪里时，<mark>最好隔几秒就打一个线程栈，每个线程栈都保留下来</mark> <br/><br>多个线程栈对比起来看，会更能更好地发现问题。</p></blockquote><h2 id="查看消耗CPU时间片最多的线程信息"><a href="#查看消耗CPU时间片最多的线程信息" class="headerlink" title="查看消耗CPU时间片最多的线程信息"></a>查看消耗CPU时间片最多的线程信息</h2><p>需要与ThreadDump一起使用，才能定位到具体是Java中哪个线程。</p><ol><li>查看消耗cpu时间片最多的进程号<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 查看瞬时消耗CPU，倒序排列<span class="token function">top</span> -o %CPU// 查看累计消耗CPU时间片，倒序排列<span class="token function">top</span> -o TIME+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ <span class="token function">top</span> -o %CPU<span class="token function">top</span> - <span class="token number">21</span>:39:35 up <span class="token number">10</span>:52,  <span class="token number">1</span> user,  load average: <span class="token number">1.47</span>, <span class="token number">1.36</span>, <span class="token number">1.14</span>Tasks: <span class="token number">325</span> total,   <span class="token number">4</span> running, <span class="token number">320</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">1</span> zombie%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">8.2</span> us,  <span class="token number">4.1</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">87.4</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.3</span> si,  <span class="token number">0.0</span> st%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">7.5</span> us,  <span class="token number">3.8</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">88.7</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st%Cpu2  <span class="token builtin class-name">:</span> <span class="token number">11.6</span> us,  <span class="token number">2.7</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">85.4</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.3</span> si,  <span class="token number">0.0</span> st%Cpu3  <span class="token builtin class-name">:</span>  <span class="token number">8.4</span> us,  <span class="token number">3.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">88.6</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> stMiB Mem <span class="token builtin class-name">:</span>   <span class="token number">7823.4</span> total,    <span class="token number">172.0</span> free,   <span class="token number">5254.4</span> used,   <span class="token number">2397.0</span> buff/cacheMiB Swap:   <span class="token number">2048.0</span> total,    <span class="token number">252.2</span> free,   <span class="token number">1795.7</span> used.   <span class="token number">1107.3</span> avail Mem     PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                         <span class="token number">2318</span> davywal+  <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">5178536</span> <span class="token number">247920</span>  <span class="token number">52372</span> R  <span class="token number">12.5</span>   <span class="token number">3.1</span>  <span class="token number">24</span>:33.00 gnome-shell                                     <span class="token number">2099</span> davywal+  <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">1008428</span> <span class="token number">112204</span>  <span class="token number">78172</span> R  <span class="token number">11.2</span>   <span class="token number">1.4</span>  <span class="token number">23</span>:31.71 Xorg                                            <span class="token number">6521</span> davywal+  <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">868244</span>  <span class="token number">35580</span>  <span class="token number">23924</span> R   <span class="token number">5.9</span>   <span class="token number">0.4</span>   <span class="token number">0</span>:38.61 gnome-terminal-                                 <span class="token number">5308</span> davywal+  <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">6370752</span> <span class="token number">517952</span> <span class="token number">219108</span> S   <span class="token number">2.6</span>   <span class="token number">6.5</span>  <span class="token number">39</span>:38.79 firefox                                      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>查看进程下消耗时间片最多的线程号</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span> -Hp <span class="token variable">$pid</span> -o %CPU<span class="token function">top</span> -Hp <span class="token variable">$pid</span> -o TIME+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ <span class="token function">top</span> -Hp <span class="token number">2318</span><span class="token function">top</span> - <span class="token number">21</span>:42:00 up <span class="token number">10</span>:55,  <span class="token number">1</span> user,  load average: <span class="token number">1.08</span>, <span class="token number">1.38</span>, <span class="token number">1.19</span>Threads:  <span class="token number">15</span> total,   <span class="token number">0</span> running,  <span class="token number">15</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:  <span class="token number">5.7</span> us,  <span class="token number">1.9</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">92.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.1</span> si,  <span class="token number">0.0</span> stMiB Mem <span class="token builtin class-name">:</span>   <span class="token number">7823.4</span> total,    <span class="token number">158.1</span> free,   <span class="token number">5264.5</span> used,   <span class="token number">2400.9</span> buff/cacheMiB Swap:   <span class="token number">2048.0</span> total,    <span class="token number">250.8</span> free,   <span class="token number">1797.2</span> used.   <span class="token number">1092.3</span> avail Mem     PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                         <span class="token number">2318</span> davywal+  <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">5178588</span> <span class="token number">247724</span>  <span class="token number">52288</span> S   <span class="token number">5.7</span>   <span class="token number">3.1</span>  <span class="token number">24</span>:28.42 gnome-shell                                     <span class="token number">2331</span> davywal+  <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">5178588</span> <span class="token number">247724</span>  <span class="token number">52288</span> S   <span class="token number">0.0</span>   <span class="token number">3.1</span>   <span class="token number">0</span>:00.34 gmain                                           <span class="token number">2335</span> davywal+  <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">5178588</span> <span class="token number">247724</span>  <span class="token number">52288</span> S   <span class="token number">0.0</span>   <span class="token number">3.1</span>   <span class="token number">0</span>:11.10 gdbus                                        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>将10进制转成16进制<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">printf</span> <span class="token string">'%x\n'</span> <span class="token environment constant">$PPID</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// <span class="token number">10</span>进制转成16进制davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ <span class="token builtin class-name">printf</span> <span class="token string">'%x\n'</span> <span class="token number">2318</span>90e// <span class="token number">16</span>进制转成10进制davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ <span class="token builtin class-name">printf</span> <span class="token string">'%d\n'</span> 0x90e<span class="token number">2318</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>查看jstack中对应的线程信息</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">fgrep</span> <span class="token string">"0x90e"</span> tmp.jstack -C <span class="token number">50</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查看JVM默认HeapSize"><a href="#查看JVM默认HeapSize" class="headerlink" title="查看JVM默认HeapSize"></a>查看JVM默认HeapSize</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">java -XX:+PrintFlagsFinal -version <span class="token operator">|</span> <span class="token function">fgrep</span> HeapSize// 查看java_home, class_path等默认配置与系统环境变量java -XshowSettings:all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>如下，默认HeapSize为130023424&#x2F;1024&#x2F;1024&#x3D;124MB<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ java -XX:+PrintFlagsFinal -version <span class="token operator">|</span> <span class="token function">fgrep</span> HeapSize    uintx ErgoHeapSizeLimit                         <span class="token operator">=</span> <span class="token number">0</span>                                   <span class="token punctuation">&#123;</span>product<span class="token punctuation">&#125;</span>    uintx HeapSizePerGCThread                       <span class="token operator">=</span> <span class="token number">87241520</span>                            <span class="token punctuation">&#123;</span>product<span class="token punctuation">&#125;</span>    uintx InitialHeapSize                          :<span class="token operator">=</span> <span class="token number">130023424</span>                           <span class="token punctuation">&#123;</span>product<span class="token punctuation">&#125;</span>    uintx LargePageHeapSizeThreshold                <span class="token operator">=</span> <span class="token number">134217728</span>                           <span class="token punctuation">&#123;</span>product<span class="token punctuation">&#125;</span>    uintx MaxHeapSize                              :<span class="token operator">=</span> <span class="token number">2051014656</span>                          <span class="token punctuation">&#123;</span>product<span class="token punctuation">&#125;</span>openjdk version <span class="token string">"1.8.0_312"</span>OpenJDK Runtime Environment <span class="token punctuation">(</span>build <span class="token number">1.8</span>.0_312-8u312-b07-0ubuntu1~20.04-b07<span class="token punctuation">)</span>OpenJDK <span class="token number">64</span>-Bit Server VM <span class="token punctuation">(</span>build <span class="token number">25.312</span>-b07, mixed mode<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ java -XshowSettings:allVM settings:    Max. Heap Size <span class="token punctuation">(</span>Estimated<span class="token punctuation">)</span>: <span class="token number">1</span>.70G    Ergonomics Machine Class: server    Using VM: OpenJDK <span class="token number">64</span>-Bit Server VMProperty settings:    awt.toolkit <span class="token operator">=</span> sun.awt.X11.XToolkit    file.encoding <span class="token operator">=</span> UTF-8    file.encoding.pkg <span class="token operator">=</span> sun.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="OQL"><a href="#OQL" class="headerlink" title="OQL"></a>OQL</h1><ul><li><p><a href="https://wiki.eclipse.org/MemoryAnalyzer/OQL">如何使用OQL</a></p></li><li><p>查询某规格类的对象</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> edu<span class="token punctuation">.</span>xmu<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>UserServiceImpl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询对象某个属性(这里只能根据类, 查到该类下所有对象的属性)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> t<span class="token punctuation">.</span>initd<span class="token punctuation">,</span> t<span class="token punctuation">.</span>initAsyn<span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>publicCloud<span class="token punctuation">)</span><span class="token punctuation">,</span> namespace<span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>regionId<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>useNuwa<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>nuwaConfigDns<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>nuwaCluster<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>rootPath<span class="token punctuation">)</span> <span class="token keyword">FROM</span> edu<span class="token punctuation">.</span>xmu<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>UserServiceImpl t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询对象某个属性(如何根据对象ID, 精确查询到该对象的某些属性?)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> t<span class="token punctuation">.</span>initd<span class="token punctuation">,</span> t<span class="token punctuation">.</span>initAsyn<span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>publicCloud<span class="token punctuation">)</span><span class="token punctuation">,</span> namespace<span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>regionId<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>useNuwa<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>nuwaConfigDns<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>nuwaCluster<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>rootPath<span class="token punctuation">)</span> <span class="token keyword">FROM</span> OBJECTS <span class="token number">0x7480633e0</span> t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>根据类的hash地址, 获取对应实例</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> instanceof <span class="token number">0x733ccc9f0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>根据对象hash值获取对象信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span>  OBJECTS <span class="token number">0xdc2819e0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>根据条件筛选出对象信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> edu<span class="token punctuation">.</span>xmu<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>UserServiceImpl t <span class="token keyword">where</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>hostType<span class="token punctuation">)</span><span class="token operator">=</span><span class="token string">"ddh.ebmec3metest"</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> edu<span class="token punctuation">.</span>xmu<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>UserServiceImpl t <span class="token keyword">where</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token operator">=</span><span class="token string">"28745-27"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java-amp-JVM&quot;&gt;&lt;a href=&quot;#Java-amp-JVM&quot; class=&quot;headerlink&quot; title=&quot;Java&amp;amp;JVM&quot;&gt;&lt;/a&gt;Java&amp;amp;JVM&lt;/h1&gt;&lt;h2 id=&quot;打-HeapDump&quot;&gt;&lt;a href=&quot;#打-HeapDump&quot; class=&quot;headerlink&quot; title=&quot;打 HeapDump&quot;&gt;&lt;/a&gt;打 HeapDump&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;jmap -dump:live,file&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;heapdump.phrof &lt;span class=&quot;token variable&quot;&gt;$pid&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;jmap -dump:live,file&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;heapdump.phrof -F &lt;span class=&quot;token variable&quot;&gt;$pid&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;一般情况下，&lt;mark&gt;尽量不要使用-F参数。&lt;/mark&gt; 因为-F使用的是Linux操作系统层面的实现，而不是JVM层面的实现，会导致 打印堆信息很慢。&lt;br&gt;&lt;br&gt;如果提示第一种方式打印不出来堆的信息，需要增加-F，那么可以先检查下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java应用进程的user_name是否与当前的user_name相同？ 如果不同，需要切换为同一个账号。&lt;/li&gt;
&lt;li&gt;Java应用进程的Java路径是否与当前jmap命令的路径相同？ 如果不同，需要切换为同一个路径。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;打-ThreadDump&quot;&gt;&lt;a href=&quot;#打-ThreadDump&quot; class=&quot;headerlink&quot; title=&quot;打 ThreadDump&quot;&gt;&lt;/a&gt;打 ThreadDump&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;jstack &lt;span class=&quot;token variable&quot;&gt;$pid&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; tmp.jstack&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意: 当CPU利用率高或者想看下线程卡在哪里时，&lt;mark&gt;最好隔几秒就打一个线程栈，每个线程栈都保留下来&lt;/mark&gt; &lt;br&gt;&lt;br&gt;多个线程栈对比起来看，会更能更好地发现问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;查看消耗CPU时间片最多的线程信息&quot;&gt;&lt;a href=&quot;#查看消耗CPU时间片最多的线程信息&quot; class=&quot;headerlink&quot; title=&quot;查看消耗CPU时间片最多的线程信息&quot;&gt;&lt;/a&gt;查看消耗CPU时间片最多的线程信息&lt;/h2&gt;</summary>
    
    
    
    
    <category term="code-snippets" scheme="https://davyjones2010.github.io/tags/code-snippets/"/>
    
    <category term="java" scheme="https://davyjones2010.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://davyjones2010.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络之原理探讨与疑问总结</title>
    <link href="https://davyjones2010.github.io/2022-06-29-linux-network-faq/"/>
    <id>https://davyjones2010.github.io/2022-06-29-linux-network-faq/</id>
    <published>2022-06-29T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="网卡混杂模式"><a href="#网卡混杂模式" class="headerlink" title="网卡混杂模式"></a>网卡混杂模式</h2><ul><li><p>啥是网卡混杂模式？</p></li><li><p>正常情况下，在网卡收到二层帧之后，会查看TargetMac是否与自身的Mac地址相同，如果不同，则丢弃该帧。</p></li><li><p>开启了混杂模式之后，即使MAC地址不匹配，也不会丢弃。还是会进入TCP&#x2F;IP协议栈处理。</p></li><li><p>啥时候需要开启？</p></li><li><p>&#x2F;&#x2F; TODO:</p></li><li><p>如何开启？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 开启混杂模式<span class="token function">ifconfig</span> eth0 promisc// 取消混杂模式<span class="token function">ifconfig</span> eth0 -promisc// 内核判断网卡是否处于混杂模式是看如下标识，如果置位了0x100，则处于混杂模式<span class="token function">cat</span> /sys/class/net/eth0/flags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>是否开启了混杂模式，就能嗅探局域网（二层网）内的所有数据包了？</p></li><li><p>不一定。</p></li><li><p>针对二层如果是集线器模式，可以嗅探到。</p></li><li><p>但现在大部分二层都是交换机模式。即交换机会根据CAM表，往对应的端口转发，不会无脑地全部端口都转发，因此嗅探不到。</p></li><li><p>开启混杂模式的例子</p></li><li><p>如下，docker0网桥就开启了混杂模式。</p></li><li><p>&#x2F;&#x2F; TODO: 为啥docker0网桥开启混杂模式？具体怎么用的？</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ <span class="token function">cat</span> /sys/class/net/docker0/flags 0x1003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="路由器与NAT设备的关联与区别"><a href="#路由器与NAT设备的关联与区别" class="headerlink" title="路由器与NAT设备的关联与区别"></a>路由器与NAT设备的关联与区别</h2><h3 id="路由器工作原理："><a href="#路由器工作原理：" class="headerlink" title="路由器工作原理："></a>路由器工作原理：</h3><p>主要用来联通连个不同的网段，<mark>只修改sourceMac与targetMac，不修改sourceIp与targetIp</mark></p><ol><li>根据传入包指定的targetIp（传入包的MAC地址是路由器当前网卡的MAC地址，IP地址是真正的IP地址）</li><li>查询自身路由表，查找到最近的下一跳的IP地址。<code>route -n</code></li><li>再根据下一跳的IP地址，查找到对应的MAC地址。arp缓存表</li><li>修改数据包的targetMAC地址为下一跳的MAC地址，sourceMAC为当前网卡出口的mac地址</li><li>将数据包从对应网卡送出去。</li></ol><blockquote><p>路由器的核心是路由表的维护，能生成最短最优路径。<br/><br>从sourceIp到targetIp的路由路径，很可能与回包，即从targetIp返回到sourceIp的路由路径不一样。<br>取决于当时的路径中路由器的路由表情况。</p></blockquote><h3 id="NAT工作原理："><a href="#NAT工作原理：" class="headerlink" title="NAT工作原理："></a>NAT工作原理：</h3><ul><li><p>原理<br>需要修改sourceMac与targetMac。<br>同时如果是SNAT，则还要修改sourceIp。<br>如果是DNAT，则还要修改targetIp。</p></li><li><p>实现方式:<br>通过iptables可以设置nat表。<br>snat作用在postrouting阶段，dnat作用在prerouting阶段。<br>回包由内核的conntrack模块负责，不再由iptables负责。<br>详细参见 <a href="https://davyjones2010.github.io/2022-06-23-linux-network-nat">NAT之端口映射(PAT)原理总结&amp;实践</a></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由此可知，家用的路由器，是附带了SNAT（也可以配置DNAT）功能的路由器。</p><h2 id="ip-forwarding"><a href="#ip-forwarding" class="headerlink" title="ip_forwarding"></a>ip_forwarding</h2><h3 id="MAC地址匹配-但IP地址不匹配"><a href="#MAC地址匹配-但IP地址不匹配" class="headerlink" title="MAC地址匹配, 但IP地址不匹配"></a>MAC地址匹配, 但IP地址不匹配</h3><p>网卡会不会收到MAC地址与当前网卡MAC地址匹配, 但IP地址与当前网卡的IP不匹配的IP包?<br>具体咋处理? 直接丢弃? 还是可以使用?</p><ul><li>会收到。</li><li>如果开启了ip_forwarding，则会进入FORWARD&#x2F;ROUTE阶段，查看本地 route 表，进入路由与postrouting阶段，找到对应的出口网卡，将包转发出去。与路由器的功能完全一致了。</li><li>如果未开启ip_forwarding，则直接丢弃该包。</li><li>所以，NAT模式下，必须要开启ip_forwarding。</li></ul><h3 id="iptables工作原理图"><a href="#iptables工作原理图" class="headerlink" title="iptables工作原理图"></a>iptables工作原理图</h3><p>此图摘自 <a href="https://wiki.archlinux.org/title/Iptables">Archlinux 文档</a></p><pre class="line-numbers language-none"><code class="language-none">                               XXXXXXXXXXXXXXXXXX                             XXX     Network    XXX                               XXXXXXXXXXXXXXXXXX                                       +                                       |                                       v +-------------+              +------------------+ |table: filter| &lt;---+        | table: nat&#x2F;dnat  | |chain: INPUT |     |        | chain: PREROUTING| +-----+-------+     |        +--------+---------+       |             |                 |       v             |                 v [local process]     |           ****************          +--------------+       |             +---------+ Routing decision +------&gt; |table: filter |       v                         ****************          |chain: FORWARD|****************                                           +------+-------+Routing decision                                                  |****************                                                  |       |                                                          |       v                        ****************                  |+-------------+       +------&gt;  Routing decision  &lt;---------------+|table: nat   |       |         ****************|chain: OUTPUT|       |               ++-----+-------+       |               |      |               |               v      v               |      +-------------------++--------------+      |      | table: nat&#x2F;snat   ||table: filter | +----+      | chain: POSTROUTING||chain: OUTPUT |             +--------+----------++--------------+                      |                                      v                               XXXXXXXXXXXXXXXXXX                             XXX    Network     XXX                               XXXXXXXXXXXXXXXXXX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="为啥Linux默认不开启ip-forwarding"><a href="#为啥Linux默认不开启ip-forwarding" class="headerlink" title="为啥Linux默认不开启ip_forwarding?"></a>为啥Linux默认不开启ip_forwarding?</h3><p>因为在默认情况下，host只是扮演在网络中的一台主机的角色，根本不需要ip_forwarding的功能。</p><blockquote><p>A Linux machine acting as an ordinary host would not need to have IP forwarding enabled,<br>because it just generates and receives IP traffic for its own purposes</p></blockquote><h3 id="如何开启ip-forwarding"><a href="#如何开启ip-forwarding" class="headerlink" title="如何开启ip_forwarding?"></a>如何开启ip_forwarding?</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token number">1</span> <span class="token operator">></span> /proc/sys/net/ipv4/ip_forward<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>所以开启了ip_forwarding，相当于本机就具备一台路由器的能力了。<br/><br>如果再通过iptables配置了相应的nat规则，就相当于一台家用的路由器了。</p><h2 id="本地多网卡curl公网地址问题"><a href="#本地多网卡curl公网地址问题" class="headerlink" title="本地多网卡curl公网地址问题"></a>本地多网卡curl公网地址问题</h2><ul><li>如果本机有私网网卡virbr0, 公网网卡en0, 且开启了virbr0网段的SNAT规则. 则在本地curl公网地址, 则curl的出口网卡是啥? </li><li>是通过virbr0, 然后走SNAT到en0出去么?</li><li>还是直接通过en0出去?</li></ul><ol><li><p>curl 支持指定出口网卡如下(实际只是使用了对应网卡的ip地址作为SIP): 如果不指定, 则使用默认网卡. </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// curl指定网卡出口<span class="token function">curl</span> --interface virbr0 http://www.baidu.com// mac上查看默认网卡: route -n get <span class="token number">0.0</span>.0.0 <span class="token operator">|</span> <span class="token function">grep</span> interface<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>The –interface options is used to figure determine what address on the system will be used as the source IP. <br/><br>It doesn’t magically change anything about routing.</p></blockquote></li><li><p>参见<a href="#iptables%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE">iptables工作原理图</a>, 可知从curl公网地址, 就是从local process出去, 接下来会走route, 即查看Host的路由表, 确定出口网卡与网关信息.</p></li><li><p>接下来进入postrouting(SNAT)阶段, 如果配置有SNAT规则, 且刚好命中, 则执行SNAT.</p></li><li><p>所以结论是出口网卡是en0, 而不会经过virbr0(即使指定了<code>--interface virbr0</code>).</p></li><li><p>是否会SNAT, 取决于是否指定了<code>--interface virbr0</code>, 指定了, 则会走SNAT; 未指定, 则不需要走SNAT.</p></li></ol><h2 id="本地多网卡Java应用获取HostIp问题"><a href="#本地多网卡Java应用获取HostIp问题" class="headerlink" title="本地多网卡Java应用获取HostIp问题"></a>本地多网卡Java应用获取HostIp问题</h2><ul><li>如果本机有多块网卡, 在Java中如何获取到这些IP地址? </li><li>我们通常使用获取本机IP的方式如下: <mark>当Host多块网卡时, 不好兼容, 存在严重缺陷, 尤其是在线上服务器网卡堆叠场景下!</mark></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">InetAddress</span> ip <span class="token operator">=</span> <span class="token class-name">InetAddress</span><span class="token punctuation">.</span><span class="token function">getLocalHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> hostname <span class="token operator">=</span> ip<span class="token punctuation">.</span><span class="token function">getHostName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>解决方案: </li><li>方案1: 使用 <code>NetworkInterface.getNetworkInterfaces()</code> 接口, 获取所有网卡, 然后逐个获取IP信息.</li><li>方案2: 获取本机的FQDN, 然后使用<code>InetAddress.getByName(FQDN)</code>来获取主网卡的IP信息.<ul><li>本机的FQDN可以写在配置文件里.</li></ul></li><li>Ref: <a href="https://crunchify.com/how-to-get-server-ip-address-and-hostname-in-java/">How to get Server IP Address and Hostname in Java</a></li></ul><h2 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h2><h2 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h2><h3 id="LVS-v-s-iptables-x2F-netfilters"><a href="#LVS-v-s-iptables-x2F-netfilters" class="headerlink" title="LVS v.s. iptables&#x2F;netfilters"></a>LVS v.s. iptables&#x2F;netfilters</h3><p>本质上, 两个都可以做四层的DNAT, 都是工作在内核空间. </p><ul><li>LVS: 更侧重于LoadBalancing, 实现上使用hash查表, 而不是iptables的顺序查询. 效率更高. </li><li>iptables:</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042336674.png"></p><ul><li>可以看到, LVS本质上是与iptables配合使用</li><li>客户访问虚拟 IP（VIP）时，数据包先在主机内核空间被 PREROUTING 链检测，根据数据包的目标地址进行路由判断，若目标地址是本地，则交由 INPUT 链进行处理。</li><li>IPVS 工作于 INPUT 链，当数据包到达 INPUT 链时，会先由 IPVS 进行检查，并根据负载均衡算法选出真实服务器 IP。</li><li>IPVS 转发模式为 NAT 模式时，将数据包由 FORWARD 链进行处理后由 POST-ROUTING 链发送给真实服务器。</li><li>IPVS 转发模式为非 NAT 模式时，则将数据包由 POST-ROUTING 链发送给真实服务器。</li></ul><h3 id="LVS的几种模式分析"><a href="#LVS的几种模式分析" class="headerlink" title="LVS的几种模式分析"></a>LVS的几种模式分析</h3><p><a href="https://blog.csdn.net/Splend520/article/details/104587149">linux LVS负载均衡原理 NAT DR TUN FULLNAT 模式</a></p><h4 id="LVS-NAT-–-gt-NAT-x2F-DNAT"><a href="#LVS-NAT-–-gt-NAT-x2F-DNAT" class="headerlink" title="LVS-NAT –&gt; NAT&#x2F;DNAT"></a>LVS-NAT –&gt; NAT&#x2F;DNAT</h4><p>本质是类似iptables的端口映射(PAT)–&gt; 注意这里全程没有DIP的参与.</p><ul><li>LVS本身有两个IP, 对外是VIP, 对内是DIP(Director IP)</li><li>Client请求: {CIP, VIP}</li><li>LVS映射: 修改目标IP, VIP-&gt;RIP, 构建新的请求: {CIP, RIP}</li><li>Server处理: 完成后发送回包, {RIP, CIP}; 由于CIP与RIP不在同一个网段, 因此发送到网关(即LVS)</li><li>LVS映射: 修改源IP, RIP-&gt;VIP, 构建新的响应: {VIP, CIP}</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207052223099.png"></p><ul><li>缺点: <ul><li>需要RS与DS在同一个二层网络里, 且需要把DS&#x2F;DIP配置为RS的网关.</li></ul></li><li>优点: <ul><li>&#x2F;&#x2F; TODO:</li></ul></li></ul><h4 id="LVS-NAT-–-gt-FullNAT"><a href="#LVS-NAT-–-gt-FullNAT" class="headerlink" title="LVS-NAT –&gt; FullNAT"></a>LVS-NAT –&gt; FullNAT</h4><ul><li>LVS本身有两个IP, 对外是VIP, 对内是DIP(Director IP)</li><li>Client请求: {CIP, VIP}</li><li>LVS映射: 修改目标IP, VIP-&gt;RIP(RealServerIP); 修改源IP, CIP-&gt;DIP; 构建新的请求: {DIP, RIP}</li><li>RealServer处理: 完成后发送回包, {RIP, DIP} (FullNAT模式, 不需要LVS必须是网关, 只要三层IP可达即可)</li><li>LVS映射: 修改源IP, RIP-&gt;VIP; 通过conntrack查表, 修改目标IP, DIP-&gt;CIP; 构建新的响应: {VIP, CIP}</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207052218872.png"></p><ul><li><p>注意: LVS 本身不支持 FULLNAT 模式，需要额外对内核打补丁后才能使用。</p></li><li><p>缺点: </p><ul><li>不管是请求数据包还是响应数据包，都要经过负载均衡器。但是响应数据包一般要比请求数据包大很多，这可能会成为系统的瓶颈。</li></ul></li><li><p>优点:</p><ul><li>如上图, RealServer(DIP)不需要跟LVS在同一个网段, 只要IP包(三层路由)可达, 就能完成FullNAT</li></ul></li></ul><h4 id="LVS-DR"><a href="#LVS-DR" class="headerlink" title="LVS-DR"></a>LVS-DR</h4><h4 id="LVS-TUN"><a href="#LVS-TUN" class="headerlink" title="LVS-TUN"></a>LVS-TUN</h4><h4 id="实际"><a href="#实际" class="headerlink" title="实际"></a>实际</h4><ul><li><a href="https://help.aliyun.com/document_detail/27544.html">阿里云CLB</a>使用的是哪种模式? NAT?<ul><li>四层采用开源软件LVS（Linux Virtual Server）+ keepalived的方式实现负载均衡</li><li>LVS应该使用的是NAT模式. 但如果是NAT模式, 则必须把LVS作为ECS的网关. &#x2F;&#x2F;TODO: 待验证</li></ul></li></ul><h1 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h1><h1 id="什么是”冷土豆路由”与”热土豆路由”"><a href="#什么是”冷土豆路由”与”热土豆路由”" class="headerlink" title="什么是”冷土豆路由”与”热土豆路由”?"></a>什么是”冷土豆路由”与”热土豆路由”?</h1><ul><li>参见: <a href="https://docs.microsoft.com/zh-cn/azure/virtual-network/ip-services/routing-preference-overview">冷土豆路由&amp;热土豆路由</a></li><li>热土豆:<ul><li>入口流量: 如果来自新加坡的用户访问托管在芝加哥的 Azure 资源，则流量将通过公共 Internet 传输，并进入芝加哥的 Microsoft 全球网络。</li><li>出口流量: 出口流量遵循相同的原则。 流量会在托管服务的同一区域退出 Microsoft 网络。 例如，如果来自 Azure 芝加哥服务的流量最终传输给来自新加坡的用户，流量将离开芝加哥的 Microsoft 网络，并通过公共 Internet 传输给新加坡的用户。</li></ul></li><li>冷土豆:<ul><li>入口流量: 如果来自新加坡的用户访问托管在美国芝加哥的 Azure 资源，则流量将进入位于新加坡 Edge POP 的 Microsoft 全球网络，并通过 Microsoft 网络传输到托管在芝加哥的服务。</li><li>出口流量: 如果来自 Azure 芝加哥的流量最终传输给来自新加坡的用户，那么流量就会通过 Microsoft 网络从芝加哥传输到新加坡，并退出位于新加坡 Edge POP 的 Microsoft 网络。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;h1 id=&quot;FAQ&quot;&gt;&lt;a href=&quot;#FAQ&quot; class=&quot;headerlink&quot; title=&quot;FAQ&quot;&gt;&lt;/a&gt;FAQ&lt;/h1&gt;&lt;h2 id=&quot;网卡混杂模式&quot;&gt;&lt;a href=&quot;#网卡混杂模式&quot; class=&quot;headerlink&quot; title=&quot;网卡混杂模式&quot;&gt;&lt;/a&gt;网卡混杂模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;啥是网卡混杂模式？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正常情况下，在网卡收到二层帧之后，会查看TargetMac是否与自身的Mac地址相同，如果不同，则丢弃该帧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开启了混杂模式之后，即使MAC地址不匹配，也不会丢弃。还是会进入TCP&amp;#x2F;IP协议栈处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;啥时候需要开启？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;#x2F;&amp;#x2F; TODO:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何开启？&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;// 开启混杂模式
&lt;span class=&quot;token function&quot;&gt;ifconfig&lt;/span&gt; eth0 promisc
// 取消混杂模式
&lt;span class=&quot;token function&quot;&gt;ifconfig&lt;/span&gt; eth0 -promisc
// 内核判断网卡是否处于混杂模式是看如下标识，如果置位了0x100，则处于混杂模式
&lt;span class=&quot;token function&quot;&gt;cat&lt;/span&gt; /sys/class/net/eth0/flags&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;是否开启了混杂模式，就能嗅探局域网（二层网）内的所有数据包了？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不一定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;针对二层如果是集线器模式，可以嗅探到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但现在大部分二层都是交换机模式。即交换机会根据CAM表，往对应的端口转发，不会无脑地全部端口都转发，因此嗅探不到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开启混杂模式的例子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如下，docker0网桥就开启了混杂模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;#x2F;&amp;#x2F; TODO: 为啥docker0网桥开启混杂模式？具体怎么用的？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ &lt;span class=&quot;token function&quot;&gt;cat&lt;/span&gt; /sys/class/net/docker0/flags 
0x1003&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;路由器与NAT设备的关联与区别&quot;&gt;&lt;a href=&quot;#路由器与NAT设备的关联与区别&quot; class=&quot;headerlink&quot; title=&quot;路由器与NAT设备的关联与区别&quot;&gt;&lt;/a&gt;路由器与NAT设备的关联与区别&lt;/h2&gt;&lt;h3 id=&quot;路由器工作原理：&quot;&gt;&lt;a href=&quot;#路由器工作原理：&quot; class=&quot;headerlink&quot; title=&quot;路由器工作原理：&quot;&gt;&lt;/a&gt;路由器工作原理：&lt;/h3&gt;&lt;p&gt;主要用来联通连个不同的网段，&lt;mark&gt;只修改sourceMac与targetMac，不修改sourceIp与targetIp&lt;/mark&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据传入包指定的targetIp（传入包的MAC地址是路由器当前网卡的MAC地址，IP地址是真正的IP地址）&lt;/li&gt;
&lt;li&gt;查询自身路由表，查找到最近的下一跳的IP地址。&lt;code&gt;route -n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;再根据下一跳的IP地址，查找到对应的MAC地址。arp缓存表&lt;/li&gt;
&lt;li&gt;修改数据包的targetMAC地址为下一跳的MAC地址，sourceMAC为当前网卡出口的mac地址&lt;/li&gt;
&lt;li&gt;将数据包从对应网卡送出去。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;路由器的核心是路由表的维护，能生成最短最优路径。&lt;br&gt;&lt;br&gt;从sourceIp到targetIp的路由路径，很可能与回包，即从targetIp返回到sourceIp的路由路径不一样。&lt;br&gt;取决于当时的路径中路由器的路由表情况。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://davyjones2010.github.io/tags/linux/"/>
    
    <category term="iaas" scheme="https://davyjones2010.github.io/tags/iaas/"/>
    
    <category term="network" scheme="https://davyjones2010.github.io/tags/network/"/>
    
    <category term="cloud-computing" scheme="https://davyjones2010.github.io/tags/cloud-computing/"/>
    
    <category term="nat" scheme="https://davyjones2010.github.io/tags/nat/"/>
    
    <category term="pat" scheme="https://davyjones2010.github.io/tags/pat/"/>
    
  </entry>
  
  <entry>
    <title>常用的Linux命令之网络相关命令</title>
    <link href="https://davyjones2010.github.io/2022-06-25-linux-network-scripts/"/>
    <id>https://davyjones2010.github.io/2022-06-25-linux-network-scripts/</id>
    <published>2022-06-25T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><h2 id="查看ARP缓存表"><a href="#查看ARP缓存表" class="headerlink" title="查看ARP缓存表"></a>查看ARP缓存表</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/PlayGround/nat$ arp -vAddress                  HWtype  HWaddress           Flags Mask            Iface_gateway                 ether   c0:b4:7d:69:d6:c3   C                     wlp4s0<span class="token number">172.17</span>.0.3               ether   02:42:ac:11:00:03   C                     docker0<span class="token number">192.168</span>.3.2              ether   00:11:32:b2:b7:04   C                     wlp4s0<span class="token number">172.17</span>.0.2               ether   02:42:ac:11:00:02   C                     docker0Entries: <span class="token number">4</span>Skipped: <span class="token number">0</span>Found: <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查看某个网卡的arp缓存"><a href="#查看某个网卡的arp缓存" class="headerlink" title="查看某个网卡的arp缓存"></a>查看某个网卡的arp缓存</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/PlayGround/nat$ arp -i wlp4s0Address                  HWtype  HWaddress           Flags Mask            Iface_gateway                 ether   c0:b4:7d:69:d6:c3   C                     wlp4s0<span class="token number">192.168</span>.3.2              ether   00:11:32:b2:b7:04   C                     wlp4s0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><ul><li>flags:<ul><li>C: complete, each complete entry in the ARP cache will be marked with the C flag.</li><li>M: 手动增加的，Permanent entries are marked  with  M</li><li>P: TODO: 不太明白具体啥意思，published entries have the P flag.</li></ul></li></ul><h1 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h1><h2 id="查看网桥"><a href="#查看网桥" class="headerlink" title="查看网桥"></a>查看网桥</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ brctl showbridge namebridge <span class="token function">id</span>STP enabledinterfacesdocker0<span class="token number">8000</span>.0242cee53dddnoveth9aec769            vethe466b6bvirbr0<span class="token number">8000</span>.525400245c90<span class="token function">yes</span>virbr0-nic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查看veth-pair"><a href="#查看veth-pair" class="headerlink" title="查看veth pair"></a>查看veth pair</h2><p>如上，发现<code>veth9aec769</code>与<code>vethe466b6b</code>都挂在<code>docker0</code>网桥下。<br>这两个veth设备都是在host上的，那么两个veth设备对应的pair（分别在2个docker容器中）分别是啥？</p><ol><li>查看host上veth设备对应的docker容器内veth设备的编号（如下分别是if23,if24）</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ <span class="token function">ip</span> a <span class="token operator">|</span> <span class="token function">fgrep</span> veth9aec769<span class="token number">24</span>: veth9aec769@if23: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue master docker0 state UP group default davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ <span class="token function">ip</span> a <span class="token operator">|</span> <span class="token function">fgrep</span> vethe466b6b<span class="token number">22</span>: vethe466b6b@if21: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue master docker0 state UP group default <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>登录docker容器中查看veth设备编号</li></ol><p>如下可知：</p><ul><li>d3f6cb3a496e 容器的veth编号是21，与host上if22，即vethe466b6b绑定</li><li>333a28ae8ea1 容器的veth编号是23，与host上if24，即veth9aec769绑定</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/PlayGround/docker$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it d3f6cb3a496e /bin/sh -c <span class="token string">"ip a"</span><span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN qlen <span class="token number">1000</span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo       valid_lft forever preferred_lft forever<span class="token number">21</span>: eth0@if22: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state UP     link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff    inet <span class="token number">172.17</span>.0.3/16 brd <span class="token number">172.17</span>.255.255 scope global eth0       valid_lft forever preferred_lft forever       davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/PlayGround/docker$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it 333a28ae8ea1 /bin/sh -c <span class="token string">"ip a"</span><span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN qlen <span class="token number">1000</span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo       valid_lft forever preferred_lft forever<span class="token number">23</span>: eth0@if24: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state UP     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff    inet <span class="token number">172.17</span>.0.2/16 brd <span class="token number">172.17</span>.255.255 scope global eth0       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="CAM表（MAC-Learning-Table）"><a href="#CAM表（MAC-Learning-Table）" class="headerlink" title="CAM表（MAC Learning Table）"></a>CAM表（MAC Learning Table）</h1><p><a href="https://www.xmodulo.com/show-mac-learning-table-linux-bridge.html">How to show a MAC learning table of Linux bridge</a><br>如下，可以看到docker0网桥（虚拟交换机）的CAM表，即mac addr对应的port no</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ brctl showmacs docker0port nomac addris local?ageing timer  <span class="token number">1</span><span class="token number">22</span>:2f:64:b8:78:af<span class="token function">yes</span>   <span class="token number">0.00</span>  <span class="token number">1</span><span class="token number">22</span>:2f:64:b8:78:af<span class="token function">yes</span>   <span class="token number">0.00</span>  <span class="token number">2</span><span class="token number">46</span>:de:b9:ed:19:0f<span class="token function">yes</span>   <span class="token number">0.00</span>  <span class="token number">2</span><span class="token number">46</span>:de:b9:ed:19:0f<span class="token function">yes</span>   <span class="token number">0.00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/ $ routeKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Ifacedefault         <span class="token number">172.17</span>.0.1      <span class="token number">0.0</span>.0.0         UG    <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> eth0<span class="token number">172.17</span>.0.0      *               <span class="token number">255.255</span>.0.0     U     <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> eth0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这是docker容器内部的路由表：</li><li>第二条路由规则：从该主机，发往172.17.0.0&#x2F;16的IP包，都要通过eth0网卡发出（Iface&#x3D;eth0），不经过网关（Gateway&#x3D;*）,直接通过二层网络发送过去。</li><li>第一条路由规则：从该主机，发往其他地址的IP包，都要通过eth0网卡发出（Iface&#x3D;eth0），要先发给网关172.17.0.1（Gateway&#x3D;172.17.0.1）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface<span class="token number">0.0</span>.0.0         <span class="token number">192.168</span>.3.1     <span class="token number">0.0</span>.0.0         UG    <span class="token number">600</span>    <span class="token number">0</span>        <span class="token number">0</span> wlp4s0<span class="token number">172.17</span>.0.0      <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.0.0     U     <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> docker0<span class="token number">192.168</span>.3.0     <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.255.0   U     <span class="token number">600</span>    <span class="token number">0</span>        <span class="token number">0</span> wlp4s0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这是Host的路由表：</li><li>第二条路由规则：从该主机，发往172.17.0.0&#x2F;16的IP包，都要从docker0网卡发出（Iface&#x3D;docker0），不经过网关（Gateway&#x3D;0.0.0.0），直接通过二层网络发送过去</li><li>第三条路由规则：从该主机，发往192.168.3.0&#x2F;24的IP包，都要从wlp4s0网卡发出（Iface&#x3D;wlp4s0），不经过网关（Gateway&#x3D;0.0.0.0），直接通过二层网络发送过去</li></ul><p>因此：</p><ul><li>从主机 <code>ping 172.17.0.2</code> 容器，实际是进入了docker0网桥，因此能ping通容器</li><li>从主机 <code>ping 192.168.3.2</code> 即该主机局域网内其他主机，实际是从wlp4s0网卡（物理网卡）出去。</li></ul><h1 id="NAT-x2F-iptables"><a href="#NAT-x2F-iptables" class="headerlink" title="NAT&#x2F;iptables"></a>NAT&#x2F;iptables</h1><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><h3 id="Linux上查看DNS缓存"><a href="#Linux上查看DNS缓存" class="headerlink" title="Linux上查看DNS缓存"></a>Linux上查看DNS缓存</h3><h4 id="2016年前"><a href="#2016年前" class="headerlink" title="2016年前"></a>2016年前</h4><p><a href="https://unix.stackexchange.com/questions/28553/how-to-read-the-local-dns-cache-contents">By 2016, Prior to systemd, there was almost no OS-level DNS caching</a><br>unless nscd or dnsmasq was installed and running.<br>Even then, the DNS caching feature of nscd is disabled by default at least in Debian because it’s broken.<br><a href="https://stackoverflow.com/questions/11020027/dns-caching-in-linux">The practical upshot is that your linux system very very probably does not do any OS-level DNS caching.</a></p><blockquote><p>If an end user using your software needs to have DNS caching </br><br>because the DNS query load is large enough to be a problem or the RTT to the external DNS server is long enough to be a problem, </br><br>they can install a caching DNS server such as Unbound on the same machine as your application,<br>configured to cache responses and forward misses to the regular DNS resolvers.</p></blockquote><h4 id="2016年后"><a href="#2016年后" class="headerlink" title="2016年后"></a>2016年后</h4><p><a href="https://www.freedesktop.org/software/systemd/man/systemd-resolved.service.html">After 2016, nowadays on systemd there’s a service to cache DNS, it could be enabled with systemctl enable systemd-resolved</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ <span class="token function">service</span> systemd-resolved statussystemd-resolved.service - Network Name Resolution     Loaded: loaded <span class="token punctuation">(</span>/lib/systemd/system/systemd-resolved.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: enabled<span class="token punctuation">)</span>     Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since Sun <span class="token number">2022</span>-05-08 <span class="token number">16</span>:04:20 CST<span class="token punctuation">;</span> <span class="token number">1</span> months <span class="token number">18</span> days ago       Docs: man:systemd-resolved.service<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>             https://www.freedesktop.org/wiki/Software/systemd/resolved             https://www.freedesktop.org/wiki/Software/systemd/writing-network-configuration-managers             https://www.freedesktop.org/wiki/Software/systemd/writing-resolver-clients   Main PID: <span class="token number">603</span> <span class="token punctuation">(</span>systemd-resolve<span class="token punctuation">)</span>     Status: <span class="token string">"Processing requests..."</span>      Tasks: <span class="token number">1</span> <span class="token punctuation">(</span>limit: <span class="token number">9305</span><span class="token punctuation">)</span>     Memory: <span class="token number">2</span>.6M     CGroup: /system.slice/systemd-resolved.service             └─603 /lib/systemd/systemd-resolved<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ <span class="token function">cat</span> /etc/resolv.confnameserver <span class="token number">127.0</span>.0.53options edns0 trust-ad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ resolvectl statusLink <span class="token number">3</span> <span class="token punctuation">(</span>wlp4s0<span class="token punctuation">)</span>      Current Scopes: DNS        DefaultRoute setting: <span class="token function">yes</span>               LLMNR setting: <span class="token function">yes</span>        MulticastDNS setting: no           DNSOverTLS setting: no               DNSSEC setting: no             DNSSEC supported: no           Current DNS Server: <span class="token number">192.168</span>.3.1         DNS Servers: <span class="token number">192.168</span>.3.1          DNS Domain: ~.         Link <span class="token number">6</span> <span class="token punctuation">(</span>docker0<span class="token punctuation">)</span>      Current Scopes: noneDefaultRoute setting: no         LLMNR setting: <span class="token function">yes</span> MulticastDNS setting: no    DNSOverTLS setting: no        DNSSEC setting: no      DNSSEC supported: no  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Chrome上查看DNS缓存"><a href="#Chrome上查看DNS缓存" class="headerlink" title="Chrome上查看DNS缓存"></a>Chrome上查看DNS缓存</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chrome://net-internals/<span class="token comment">#dnschrome</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Firefox上查看DNS缓存"><a href="#Firefox上查看DNS缓存" class="headerlink" title="Firefox上查看DNS缓存"></a>Firefox上查看DNS缓存</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">about:networking<span class="token comment">#dns</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="DNS域名解析排查"><a href="#DNS域名解析排查" class="headerlink" title="DNS域名解析排查"></a>DNS域名解析排查</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:/etc/systemd$ <span class="token function">dig</span> baidu.comdavywalker@davywalker-ThinkPad-X1-Carbon-4th:/etc/systemd$ <span class="token function">dig</span> baidu.com +trace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="查看到某个IP的路由信息"><a href="#查看到某个IP的路由信息" class="headerlink" title="查看到某个IP的路由信息"></a>查看到某个IP的路由信息</h1><p>在Linux&amp;MacOS上，traceroute命令默认使用UDP，而Windows默认使用ICMP协议。但可以使用<code>traceroute -I</code>来强制使用ICMP协议。<br><a href="https://serverfault.com/questions/374620/does-traceroute-use-udp-or-icmp-or-both">By default Windows tracert uses ICMP and both Mac OS X and Linux traceroute use UDP.</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ <span class="token function">traceroute</span> <span class="token number">220.181</span>.38.148<span class="token function">traceroute</span> to <span class="token number">220.181</span>.38.148 <span class="token punctuation">(</span><span class="token number">220.181</span>.38.148<span class="token punctuation">)</span>, <span class="token number">30</span> hops max, <span class="token number">60</span> byte packets <span class="token number">1</span>  _gateway <span class="token punctuation">(</span><span class="token number">192.168</span>.3.1<span class="token punctuation">)</span>  <span class="token number">3.140</span> ms  <span class="token number">3.401</span> ms  <span class="token number">5.204</span> ms <span class="token number">2</span>  <span class="token number">122.233</span>.112.1 <span class="token punctuation">(</span><span class="token number">122.233</span>.112.1<span class="token punctuation">)</span>  <span class="token number">8.077</span> ms  <span class="token number">8.005</span> ms  <span class="token number">8.613</span> ms <span class="token number">3</span>  <span class="token number">61.164</span>.3.50 <span class="token punctuation">(</span><span class="token number">61.164</span>.3.50<span class="token punctuation">)</span>  <span class="token number">8.474</span> ms <span class="token number">61.164</span>.2.2 <span class="token punctuation">(</span><span class="token number">61.164</span>.2.2<span class="token punctuation">)</span>  <span class="token number">8.331</span> ms  <span class="token number">9.131</span> ms<span class="token number">30</span>  * * *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用ICMP协议进行traceroute</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ <span class="token function">traceroute</span> -I <span class="token number">220.181</span>.38.148<span class="token function">traceroute</span> to <span class="token number">220.181</span>.38.148 <span class="token punctuation">(</span><span class="token number">220.181</span>.38.148<span class="token punctuation">)</span>, <span class="token number">30</span> hops max, <span class="token number">60</span> byte packets <span class="token number">1</span>  _gateway <span class="token punctuation">(</span><span class="token number">192.168</span>.3.1<span class="token punctuation">)</span>  <span class="token number">3.348</span> ms  <span class="token number">3.300</span> ms  <span class="token number">3.604</span> ms <span class="token number">2</span>  <span class="token number">122.233</span>.112.1 <span class="token punctuation">(</span><span class="token number">122.233</span>.112.1<span class="token punctuation">)</span>  <span class="token number">46.031</span> ms  <span class="token number">46.236</span> ms  <span class="token number">46.274</span> ms <span class="token number">3</span>  <span class="token number">61.164</span>.3.50 <span class="token punctuation">(</span><span class="token number">61.164</span>.3.50<span class="token punctuation">)</span>  <span class="token number">8.196</span> ms  <span class="token number">9.610</span> ms  <span class="token number">9.522</span> ms <span class="token number">4</span>  * <span class="token number">115.233</span>.18.13 <span class="token punctuation">(</span><span class="token number">115.233</span>.18.13<span class="token punctuation">)</span>  <span class="token number">10.761</span> ms * <span class="token number">5</span>  <span class="token number">202.97</span>.102.201 <span class="token punctuation">(</span><span class="token number">202.97</span>.102.201<span class="token punctuation">)</span>  <span class="token number">40.430</span> ms  <span class="token number">40.413</span> ms  <span class="token number">40.431</span> ms <span class="token number">6</span>  <span class="token number">36.110</span>.245.66 <span class="token punctuation">(</span><span class="token number">36.110</span>.245.66<span class="token punctuation">)</span>  <span class="token number">35.611</span> ms *  <span class="token number">34.008</span> ms <span class="token number">7</span>  * * * <span class="token number">8</span>  <span class="token number">220.181</span>.182.30 <span class="token punctuation">(</span><span class="token number">220.181</span>.182.30<span class="token punctuation">)</span>  <span class="token number">41.642</span> ms  <span class="token number">41.785</span> ms  <span class="token number">37.416</span> ms <span class="token number">9</span>  * * *<span class="token number">10</span>  * * *<span class="token number">11</span>  * * *<span class="token number">12</span>  <span class="token number">220.181</span>.38.148 <span class="token punctuation">(</span><span class="token number">220.181</span>.38.148<span class="token punctuation">)</span>  <span class="token number">40.385</span> ms  <span class="token number">40.757</span> ms  <span class="token number">40.478</span> ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>路由器上，多个网卡，请求到某个网卡之后，是如何转发到其他网卡的？<br>例如：<br>docker容器内部 172.17.0.2，访问host的ip (192.168.3.80)</p><ol><li><p>docker容器内部有一条路由规则，非docker容器网段，都到docker0网桥上，docker0网桥IP 172.17.0.1</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Destination     Gateway         Genmask         Flags Metric Ref    Use Ifacedefault         <span class="token number">172.17</span>.0.1      <span class="token number">0.0</span>.0.0         UG    <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> eth0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>请求到docker0网桥 172.17.0.1 之后，（docker0网桥本身就在Host上），查看路由表，从 wlp4s0 网卡发出（这里具体怎么发出的？）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:/etc/systemd$ route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface<span class="token number">0.0</span>.0.0         <span class="token number">192.168</span>.3.1     <span class="token number">0.0</span>.0.0         UG    <span class="token number">600</span>    <span class="token number">0</span>        <span class="token number">0</span> wlp4s0<span class="token number">172.17</span>.0.0      <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.0.0     U     <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> docker0<span class="token number">192.168</span>.3.0     <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.255.0   U     <span class="token number">600</span>    <span class="token number">0</span>        <span class="token number">0</span> wlp4s0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ARP协议&quot;&gt;&lt;a href=&quot;#ARP协议&quot; class=&quot;headerlink&quot; title=&quot;ARP协议&quot;&gt;&lt;/a&gt;ARP协议&lt;/h1&gt;&lt;h2 id=&quot;查看ARP缓存表&quot;&gt;&lt;a href=&quot;#查看ARP缓存表&quot; class=&quot;headerlink&quot; title=&quot;查看ARP缓存表&quot;&gt;&lt;/a&gt;查看ARP缓存表&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/PlayGround/nat$ arp -v
Address                  HWtype  HWaddress           Flags Mask            Iface
_gateway                 ether   c0:b4:7d:69:d6:c3   C                     wlp4s0
&lt;span class=&quot;token number&quot;&gt;172.17&lt;/span&gt;.0.3               ether   02:42:ac:11:00:03   C                     docker0
&lt;span class=&quot;token number&quot;&gt;192.168&lt;/span&gt;.3.2              ether   00:11:32:b2:b7:04   C                     wlp4s0
&lt;span class=&quot;token number&quot;&gt;172.17&lt;/span&gt;.0.2               ether   02:42:ac:11:00:02   C                     docker0
Entries: &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;	Skipped: &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;	Found: &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;查看某个网卡的arp缓存&quot;&gt;&lt;a href=&quot;#查看某个网卡的arp缓存&quot; class=&quot;headerlink&quot; title=&quot;查看某个网卡的arp缓存&quot;&gt;&lt;/a&gt;查看某个网卡的arp缓存&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/PlayGround/nat$ arp -i wlp4s0
Address                  HWtype  HWaddress           Flags Mask            Iface
_gateway                 ether   c0:b4:7d:69:d6:c3   C                     wlp4s0
&lt;span class=&quot;token number&quot;&gt;192.168&lt;/span&gt;.3.2              ether   00:11:32:b2:b7:04   C                     wlp4s0&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;参数详解&quot;&gt;&lt;a href=&quot;#参数详解&quot; class=&quot;headerlink&quot; title=&quot;参数详解&quot;&gt;&lt;/a&gt;参数详解&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;flags:&lt;ul&gt;
&lt;li&gt;C: complete, each complete entry in the ARP cache will be marked with the C flag.&lt;/li&gt;
&lt;li&gt;M: 手动增加的，Permanent entries are marked  with  M&lt;/li&gt;
&lt;li&gt;P: TODO: 不太明白具体啥意思，published entries have the P flag.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;网桥&quot;&gt;&lt;a href=&quot;#网桥&quot; class=&quot;headerlink&quot; title=&quot;网桥&quot;&gt;&lt;/a&gt;网桥&lt;/h1&gt;&lt;h2 id=&quot;查看网桥&quot;&gt;&lt;a href=&quot;#查看网桥&quot; class=&quot;headerlink&quot; title=&quot;查看网桥&quot;&gt;&lt;/a&gt;查看网桥&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ brctl show
bridge name	bridge &lt;span class=&quot;token function&quot;&gt;id&lt;/span&gt;		STP enabled	interfaces
docker0		&lt;span class=&quot;token number&quot;&gt;8000&lt;/span&gt;.0242cee53ddd	no		veth9aec769
							            vethe466b6b
virbr0		&lt;span class=&quot;token number&quot;&gt;8000&lt;/span&gt;.525400245c90	&lt;span class=&quot;token function&quot;&gt;yes&lt;/span&gt;		virbr0-nic&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="code-snippets" scheme="https://davyjones2010.github.io/tags/code-snippets/"/>
    
    <category term="linux" scheme="https://davyjones2010.github.io/tags/linux/"/>
    
    <category term="network" scheme="https://davyjones2010.github.io/tags/network/"/>
    
    <category term="nat" scheme="https://davyjones2010.github.io/tags/nat/"/>
    
    <category term="arp" scheme="https://davyjones2010.github.io/tags/arp/"/>
    
  </entry>
  
  <entry>
    <title>记一次Dubbo服务调用异常排查</title>
    <link href="https://davyjones2010.github.io/2022-06-24-dubbo-invoke-error/"/>
    <id>https://davyjones2010.github.io/2022-06-24-dubbo-invoke-error/</id>
    <published>2022-06-24T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ul><li>应用拓扑: systemA —- dubbo 调用 —-&gt; systemB</li><li>systemB应用在已有的dubbo接口类里, 新增加了一个方法methodA.</li><li>systemA在调用该methodA时, 抛错. 错误信息如下:</li></ul><h1 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h1><h2 id="0x00-排查provider侧"><a href="#0x00-排查provider侧" class="headerlink" title="0x00 排查provider侧"></a>0x00 排查provider侧</h2><p>确认provider侧:</p><ol><li>服务是否正常可以执行? &gt; 通过telnet localhost, 手动invoke确定是OK的.</li><li>接口类&amp;接口方法是否正常注册在registry上? &gt; 通过查看dubbo registry, 发现接口类与接口方法是正常注册的.</li></ol><h2 id="0x01-排查consumer侧"><a href="#0x01-排查consumer侧" class="headerlink" title="0x01 排查consumer侧"></a>0x01 排查consumer侧</h2><p>确认consumer侧:</p><ol><li>是否正确依赖到了provider?<ol><li>通过查看 tcp ESTABLISHED 连接确定长连接已经建立.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122201347.png"></li><li>or 查看registry下发的 dubbo config 文件?  –&gt; TODO: 暂时没找到, 待分析.</li></ol></li><li>请求是否正确路由到了provider的host?  &#x2F;&#x2F; 由于systemB有多套环境, 怀疑是请求路由到了非目标环境.<ol><li>动态分析: 查看 dubbo 请求日志 –&gt; 没找到, 待进一步查看.</li><li>静态分析: 查看 diamond 配置 + 相关代码, 是不是路由代码有误?</li></ol></li></ol><h2 id="0x02-真实错误原因"><a href="#0x02-真实错误原因" class="headerlink" title="0x02 真实错误原因"></a>0x02 真实错误原因</h2><ul><li>provider侧与consumer侧都没有问题, 路由也没有问题, 但为啥会报错?</li><li>最终在某位同学的提醒下, 查看了consumer侧的error日志, 发现了详细的错误堆栈信息如下(原来是序列化失败):</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122201975.png"></p><h2 id="0x03-原因探讨"><a href="#0x03-原因探讨" class="headerlink" title="0x03 原因探讨"></a>0x03 原因探讨</h2><h3 id="为啥dubbo调用参数必须要是Serializable的"><a href="#为啥dubbo调用参数必须要是Serializable的" class="headerlink" title="为啥dubbo调用参数必须要是Serializable的?"></a>为啥dubbo调用参数必须要是Serializable的?</h3><p>因为dubbo rpc, 默认使用hessian2序列化方式.<br><a href="https://blog.csdn.net/liyong1028826685/article/details/117308356">而hessian2针对java Object类型参数, 使用的是默认的Java序列化方式</a>.<br>而Java序列化则要求Object必须<code>implements Serializable</code>接口.</p><h3 id="为啥在本地telnet-invoke的时候没有序列化失败错误"><a href="#为啥在本地telnet-invoke的时候没有序列化失败错误" class="headerlink" title="为啥在本地telnet invoke的时候没有序列化失败错误?"></a>为啥在本地telnet invoke的时候没有序列化失败错误?</h3><p>因为在本地telnet invoke的时候, 默认使用的是JSON序列化方式!</p><h3 id="如何查看当前接口使用的序列化方式"><a href="#如何查看当前接口使用的序列化方式" class="headerlink" title="如何查看当前接口使用的序列化方式?"></a>如何查看当前接口使用的序列化方式?</h3><ol><li>查看registry, 如果没有指定, 则是默认的hessian2:</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122202268.png"></p><h3 id="如何指定序列化方式"><a href="#如何指定序列化方式" class="headerlink" title="如何指定序列化方式?"></a>如何指定序列化方式?</h3><p><a href="https://dubbo.apache.org/zh/docs/references/xml/dubbo-protocol/">https://dubbo.apache.org/zh/docs/references/xml/dubbo-protocol/</a><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122202940.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&lt;</span>dubbo:protocol <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">"dubbo-m"</span> <span class="token assign-left variable">threadpool</span><span class="token operator">=</span><span class="token string">"dubboThreadPool"</span> <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">"dubbo"</span>  <span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$&#123;pbs.dubbo.protocol.default.port&#125;</span>"</span>  <span class="token assign-left variable">threads</span><span class="token operator">=</span><span class="token string">"150"</span> <span class="token assign-left variable">serialization</span><span class="token operator">=</span><span class="token string">"json"</span> /<span class="token operator">></span><span class="token operator">&lt;</span>dubbo:protocol <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">"dubbo-h"</span> <span class="token assign-left variable">threadpool</span><span class="token operator">=</span><span class="token string">"dubboThreadPool"</span> <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">"dubbo"</span>  <span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$&#123;pbs.dubbo.protocol.high.port&#125;</span>"</span>  <span class="token assign-left variable">threads</span><span class="token operator">=</span><span class="token string">"150"</span> <span class="token assign-left variable">serialization</span><span class="token operator">=</span><span class="token string">"fastjson"</span> /<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><h2 id="正确的问题排查步骤"><a href="#正确的问题排查步骤" class="headerlink" title="正确的问题排查步骤"></a>正确的问题排查步骤</h2><ol><li>排查问题时, 优先在报错的host(不用管是consumer&#x2F;provider)上, 查看error等更详细的堆栈日志.</li></ol><h2 id="走的一些弯路"><a href="#走的一些弯路" class="headerlink" title="走的一些弯路"></a>走的一些弯路</h2><ol><li>provider侧排查时, invoke 方法名称写错, 导致误以为是provider没有把新的接口方法暴露出去. 误导了排查方向. 如下:</li></ol><p>正确的: <code>invoke com.xxx.xxx.XXXQueryService.queryHistory(&quot;&quot;)</code><br>错误的: <code>invoke com.xxx.xxx.XXXQueryService.describeHistory(&quot;&quot;)</code><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122202508.png"><br><a href="#dubbo%E5%A6%82%E4%BD%95%E6%9F%A5%E5%88%B0%E6%9F%90%E5%8F%B0host%E4%B8%AD%E6%9F%90%E4%B8%AA%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BE%9B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95">如何快速查看某个host的某个interface有没有把某个method暴露出去</a></p><ol start="2"><li>consumer侧排查时, 由于systemA的dubbo console的端口与systemB的dubbo console 端口不一致, 也查了半天.<br><a href="#dubbo%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bconsole%E7%9A%84%E7%AB%AF%E5%8F%A3">如何快速查到dubbo console端口号?</a></li></ol><h2 id="Dubbo最佳实践"><a href="#Dubbo最佳实践" class="headerlink" title="Dubbo最佳实践"></a>Dubbo最佳实践</h2><h3 id="dubbo按照端口进行线程池隔离"><a href="#dubbo按照端口进行线程池隔离" class="headerlink" title="dubbo按照端口进行线程池隔离"></a>dubbo按照端口进行线程池隔离</h3><h4 id="隔离原理"><a href="#隔离原理" class="headerlink" title="隔离原理"></a>隔离原理</h4><p>单个host可以开启多个dubbo端口, 每个端口由独立的线程池处理, 把svc按照端口进行分组.<br>可以防止低优先级接口占用线程导致dubbo线程池满, 从而影响高优先级接口.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122202434.png"></p><h4 id="隔离配置样例"><a href="#隔离配置样例" class="headerlink" title="隔离配置样例"></a>隔离配置样例</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>registry</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>coreRegistry<span class="token punctuation">"</span></span> <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;pbs.dubbo.registry.address&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment">&lt;!-- 核心接口 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>protocol</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo-core<span class="token punctuation">"</span></span> <span class="token attr-name">threadpool</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubboThreadPool<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo<span class="token punctuation">"</span></span>  <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;pbs.dubbo.protocol.core.port&#125;<span class="token punctuation">"</span></span>  <span class="token attr-name">threads</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment">&lt;!-- 中优先级接口线程池(默认，为了最大保持兼容) --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>protocol</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo-m<span class="token punctuation">"</span></span> <span class="token attr-name">threadpool</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubboThreadPool<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo<span class="token punctuation">"</span></span>  <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;pbs.dubbo.protocol.default.port&#125;<span class="token punctuation">"</span></span>  <span class="token attr-name">threads</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>150<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment">&lt;!-- 默认provider使用dubbo-m,http-dubbo协议 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>provider</span> <span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo-m<span class="token punctuation">"</span></span> <span class="token attr-name">filter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>-sentinel.dubbo.provider.filter<span class="token punctuation">"</span></span> <span class="token attr-name">delay</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>-1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment">&lt;!-- 使用dubbo-core --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.TestService<span class="token punctuation">"</span></span><span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo-core<span class="token punctuation">"</span></span> <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;pbs.service.version&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>testService<span class="token punctuation">"</span></span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">timeout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>30000<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment">&lt;!-- 使用dubbo-core --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.SampleService<span class="token punctuation">"</span></span><span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo-core<span class="token punctuation">"</span></span> <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;pbs.service.version&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sampleService<span class="token punctuation">"</span></span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">timeout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>30000<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dubbo默认端口号配置原则"><a href="#dubbo默认端口号配置原则" class="headerlink" title="dubbo默认端口号配置原则"></a>dubbo默认端口号配置原则</h3><p>如上, <code>pbs.dubbo.protocol.default.port=-1</code>配置项, 按照dubbo文档说明, 应该是随机分配一个端口. 但发现systemB实际启动后, 却开启了 20880 端口. 这是为啥?</p><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p>根据 <a href="https://dubbo.apache.org/zh/docs/references/xml/dubbo-protocol/">https://dubbo.apache.org/zh/docs/references/xml/dubbo-protocol/</a>  文档说明,  <code>分配的端口在协议缺省端口的基础上增长</code><br>但实际语焉不详, dubbo协议默认端口是20880,  那么如果配置 <code>port=-1</code>, 则端口是 <code>20880</code> or <code>20881</code>??</p><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122203219.png"></p><h4 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h4><p>核心代码: <code>com.alibaba.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol</code>, 可以得知是从 20880 开始(包括20880).<br>这也就解释了, 为啥 <code>pbs.dubbo.protocol.default.port=-1</code>配置项, 实际对应的开启端口号是 20880 啦.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122203404.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122203097.png"></p><h3 id="dubbo多端口telnet原则"><a href="#dubbo多端口telnet原则" class="headerlink" title="dubbo多端口telnet原则"></a>dubbo多端口telnet原则</h3><p>如上, 暴露了 20880~20884 5个端口, 用于线程池隔离.<br>实际:</p><ol><li>每个端口, 都是启动了一个NettyServer<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122203903.png"></li><li>因此每个端口, 都可以telnet上去.</li><li>telnet每个端口执行 ls 列举出来本机暴露的dubbo服务都是一样的(会把所有其他端口暴露的服务也都枚举出来). 不会因为telnet 20880, 就只列举出暴露在20880端口的服务. 参见: <code>com.alibaba.dubbo.rpc.protocol.dubbo.telnet.ListTelnetHandler</code><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122204305.png"></li></ol><h3 id="dubbo版本号隔离"><a href="#dubbo版本号隔离" class="headerlink" title="dubbo版本号隔离"></a>dubbo版本号隔离</h3><p>用来区分多套预发环境.<br>但实际看了下, 多套预发环境provider的版本号都是1.0.0, 而不是通过版本号来进行隔离的. 那么consumer实际怎么做的路由?<br>&#x2F;&#x2F; TODO:  核心代码附录<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122204657.png"></p><h3 id="dubbo序列化"><a href="#dubbo序列化" class="headerlink" title="dubbo序列化"></a>dubbo序列化</h3><ul><li>使用console手动invoke, 用的是json序列化.</li><li>而consumer真正调用时用的是hessian2序列化, 因此针对这种序列化差异导致的错误问题, 是无法验证到的. 需要编码测试的时候注意.</li></ul><h3 id="dubbo-ls-x2F-invoke"><a href="#dubbo-ls-x2F-invoke" class="headerlink" title="dubbo ls&#x2F;invoke"></a>dubbo ls&#x2F;invoke</h3><p>如何查看当前host下依赖的所有dubbo服务?</p><ol><li>通过telnet localhost xxxx 进入dubbo管控页面, 执行 <code>ls</code>命令, 只能列出自身作为provider对外暴露的所有服务.</li><li>而无法列出自身host作为consumer依赖到的所有服务.  &#x2F;&#x2F; 查看了dubbo文档, 目前没有办法通过telnet查看到.</li></ol><h3 id="dubbo如何查到某台host中某个接口提供的所有方法"><a href="#dubbo如何查到某台host中某个接口提供的所有方法" class="headerlink" title="dubbo如何查到某台host中某个接口提供的所有方法"></a>dubbo如何查到某台host中某个接口提供的所有方法</h3><h4 id="方案1-telnet查看"><a href="#方案1-telnet查看" class="headerlink" title="方案1 telnet查看"></a>方案1 telnet查看</h4><p><code>ls -l com.xxx.SampleService</code><br>telnet localhost  20880  telnet localhost  20881 telnet localhost  20882 都能登上去, 实际方法列表也相同.  参见: <a href="#th8th">dubbo多端口telnet原则</a></p><h4 id="方案2-registry查看"><a href="#方案2-registry查看" class="headerlink" title="方案2 registry查看"></a>方案2 registry查看</h4><p>在registry中查询接口, 选定host查看:<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122206622.png"></p><h3 id="dubbo如何查看console的端口"><a href="#dubbo如何查看console的端口" class="headerlink" title="dubbo如何查看console的端口"></a>dubbo如何查看console的端口</h3><h4 id="方案1-通过查看应用配置文件"><a href="#方案1-通过查看应用配置文件" class="headerlink" title="方案1: 通过查看应用配置文件"></a>方案1: 通过查看应用配置文件</h4><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122207808.png"></p><blockquote><p>这种方式最直接, 也最有效. 缺点是紧急排查问题时, 如果配置项经过了一层有一层的自动替换, 不一定能很快找出实际配置值是啥.</p></blockquote><h4 id="方案2-通过查看TCP连接"><a href="#方案2-通过查看TCP连接" class="headerlink" title="方案2: 通过查看TCP连接"></a>方案2: 通过查看TCP连接</h4><ol><li><p>查看进程号PID(注意看清楚进程的USER是不是当前用户)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">fgrep</span> <span class="token variable">$&#123;appName&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看进程占用的TCP在Listen状态的端口(如果上一步获取到的PID不是当前用户的, 则需要su到PID对应的用户, 或者如下用sudo)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">lsof</span> -i -P<span class="token operator">|</span> <span class="token function">fgrep</span> <span class="token variable">$&#123;PID&#125;</span> <span class="token operator">|</span> <span class="token function">fgrep</span> LISTEN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>看到如下, 一般dubbo端口号是从20880开始的(包括20880)</p></li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122207567.png"></p><p>但如果应用配置的dubbo端口很奇怪, 不符合惯例, 那这里就只能一个一个端口来telnet试试了.</p><blockquote><p>这种方式不算非常直接, 但优点是可以不用去翻找代码, 翻找配置项. 在端口数很少的情况下, 简单有效.</p></blockquote><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/16%20%20Dubbo%20Serialize%20%E5%B1%82%EF%BC%9A%E5%A4%9A%E7%A7%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%97%E6%B3%95%EF%BC%8C%E6%80%BB%E6%9C%89%E4%B8%80%E6%AC%BE%E9%80%82%E5%90%88%E4%BD%A0.md">Dubbo Serialize 层：多种序列化算法，总有一款适合你</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;应用拓扑: systemA —- dubbo 调用 —-&amp;gt; systemB&lt;/li&gt;
&lt;li&gt;systemB应用在已有的dubbo接口类里, 新增加了一个方法methodA.&lt;/li&gt;
&lt;li&gt;systemA在调用该methodA时, 抛错. 错误信息如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;排查步骤&quot;&gt;&lt;a href=&quot;#排查步骤&quot; class=&quot;headerlink&quot; title=&quot;排查步骤&quot;&gt;&lt;/a&gt;排查步骤&lt;/h1&gt;&lt;h2 id=&quot;0x00-排查provider侧&quot;&gt;&lt;a href=&quot;#0x00-排查provider侧&quot; class=&quot;headerlink&quot; title=&quot;0x00 排查provider侧&quot;&gt;&lt;/a&gt;0x00 排查provider侧&lt;/h2&gt;&lt;p&gt;确认provider侧:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务是否正常可以执行? &amp;gt; 通过telnet localhost, 手动invoke确定是OK的.&lt;/li&gt;
&lt;li&gt;接口类&amp;amp;接口方法是否正常注册在registry上? &amp;gt; 通过查看dubbo registry, 发现接口类与接口方法是正常注册的.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;0x01-排查consumer侧&quot;&gt;&lt;a href=&quot;#0x01-排查consumer侧&quot; class=&quot;headerlink&quot; title=&quot;0x01 排查consumer侧&quot;&gt;&lt;/a&gt;0x01 排查consumer侧&lt;/h2&gt;&lt;p&gt;确认consumer侧:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是否正确依赖到了provider?&lt;ol&gt;
&lt;li&gt;通过查看 tcp ESTABLISHED 连接确定长连接已经建立.&lt;br&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122201347.png&quot;&gt;&lt;/li&gt;
&lt;li&gt;or 查看registry下发的 dubbo config 文件?  –&amp;gt; TODO: 暂时没找到, 待分析.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;请求是否正确路由到了provider的host?  &amp;#x2F;&amp;#x2F; 由于systemB有多套环境, 怀疑是请求路由到了非目标环境.&lt;ol&gt;
&lt;li&gt;动态分析: 查看 dubbo 请求日志 –&amp;gt; 没找到, 待进一步查看.&lt;/li&gt;
&lt;li&gt;静态分析: 查看 diamond 配置 + 相关代码, 是不是路由代码有误?&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;0x02-真实错误原因&quot;&gt;&lt;a href=&quot;#0x02-真实错误原因&quot; class=&quot;headerlink&quot; title=&quot;0x02 真实错误原因&quot;&gt;&lt;/a&gt;0x02 真实错误原因&lt;/h2&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://davyjones2010.github.io/tags/java/"/>
    
    <category term="dubbo" scheme="https://davyjones2010.github.io/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>NAT之端口映射(PAT)原理总结&amp;实践</title>
    <link href="https://davyjones2010.github.io/2022-06-22-linux-network-nat/"/>
    <id>https://davyjones2010.github.io/2022-06-22-linux-network-nat/</id>
    <published>2022-06-22T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>经常在家用路由器中, 看到有端口映射(PAT)选项, 但不明所以.<br>最近刚好在研究NAT, 知道了<mark>PAT本质是NAT的一种实现方式, 更确切地说是DNAT的一种实现方式</mark>.<br>因此借此机会好好研究下.</p><h1 id="DNAT总结"><a href="#DNAT总结" class="headerlink" title="DNAT总结"></a>DNAT总结</h1><h2 id="PAT作用概述"><a href="#PAT作用概述" class="headerlink" title="PAT作用概述"></a>PAT作用概述</h2><p>家用路由器中配置PAT, 本质上还是一种<code>内网穿透</code>的实现方式，或者DNAT的一种方式。<br>即需要把家里内网某台主机的某个服务, 暴露到公网上, 以便能在公网环境下访问该服务.<br>例如</p><ul><li>家庭内网网段是<code>192.168.3.0/24</code></li><li>家用路由器, 电信运营商分配的对外公网IP是<code>115.192.71.187</code></li><li>某台主机IP是<code>192.168.3.213</code>: <ul><li>暴露了8080的某个tomcat服务, 想要把这个服务暴露在公网上, 以便其他人能够访问.</li><li>暴露了远程桌面RDP端口服务, 以便在公司或者咖啡厅, 能访问到该远程桌面.</li><li>等等</li></ul></li><li>此时可以在路由器上开启端口映射(PAT), 将路由器上某个端口(如8888)与内网主机的端口(如8080)如进行映射, 所有访问{路由器IP, 8888端口}的请求, 就会被自动路由到{内网IP, 8080端口}上:</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206232339615.png"></p><p>&#x2F;&#x2F; TODO: 这里挖个坑, 内网穿透除了PAT外, 还有其他方案, 例如 <code>花生壳</code>, 后边新开篇章讲下原理.</p><h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>本质上是家用路由器保存了这么一张NAT表:<br><code>&#123;publicIp, publicPort&#125;</code> —映射到—&gt; <code>&#123;localIp, localPort&#125;</code></p><h2 id="PAT路由流程"><a href="#PAT路由流程" class="headerlink" title="PAT路由流程"></a>PAT路由流程</h2><h3 id="0X00-外部用户-–-gt-路由器"><a href="#0X00-外部用户-–-gt-路由器" class="headerlink" title="0X00: 外部用户 –&gt; 路由器"></a>0X00: 外部用户 –&gt; 路由器</h3><ol><li>二层帧: <code>&#123;remoteMac, remoteIp, remotePort&#125;, &#123;publicMac, publicIp, publicPort&#125;</code></li></ol><h3 id="0X01-路由器-–-gt-内网Server"><a href="#0X01-路由器-–-gt-内网Server" class="headerlink" title="0X01: 路由器 –&gt; 内网Server:"></a>0X01: 路由器 –&gt; 内网Server:</h3><ol><li>目标 publicMac &#x3D;&#x3D; router’s publicMac，网卡接收，解析三层IP包</li><li>进入prerouting阶段：(DNAT作用在preroute阶段)<ol><li>查NAT表（DNAT条目）: <code>&#123;publicIp, publicPort&#125;</code> –&gt; <code>&#123;localIp, localPort&#125;</code></li><li>修改三层IP包 <code>&#123;remoteIp, remotePort&#125;</code> –&gt; <code>&#123;localIp, localPort&#125;</code></li></ol></li><li>由于此时targetIp是 localIp, !&#x3D; publicIp，因此不会走入INPUT流程，因此也就不会把数据包交给上层应用。</li><li>进入FORWARD&#x2F;ROUTE阶段：<ol><li>如果没有开启ip_forwarding，则流程到此结束。直接把IP包丢弃掉。</li><li>查看路由表，<code>route -n</code>，找到往localIp网段发送数据包，应该使用的网卡与网卡对应的Mac地址（例如 gatewayMac）</li></ol></li><li>封装二层帧<ol><li>发ARP广播: what’s localIp’s mac addr, tell publicMac</li><li>获取ARP缓存表项: {localIp} –&gt; {localMac}</li><li>修改帧内容为: <code>&#123;gatewayMac, remoteIp, remotePort&#125;, &#123;localMac, localIp, localPort&#125;</code></li></ol></li><li>通过对应的网卡发出二层帧。</li></ol><p><img data-src="https://p.k8s.li/iptables.png"></p><h3 id="0X02-Server端处理"><a href="#0X02-Server端处理" class="headerlink" title="0X02: Server端处理:"></a>0X02: Server端处理:</h3><ol><li>接收如下IP帧<br><code>&#123;gatewayMac, remoteIp, remotePort&#125;, &#123;localMac, localIp, localPort&#125;</code></li><li>目标 localMac &#x3D;&#x3D; Server localMac, 网卡接收(无需开启混杂模式), 否则丢弃</li><li>目标 localIp &#x3D;&#x3D; Server localIp, TCP&#x2F;IP协议栈接收. <ol><li>是否有可能IP不匹配? 如何处理? –&gt; 是否开启了ip_forwarding？ 具体参见</li></ol></li><li>server端将TCP数据包转给对应应用层程序处理</li></ol><h3 id="0X03-Server-–回包–-gt-路由器"><a href="#0X03-Server-–回包–-gt-路由器" class="headerlink" title="0X03: Server –回包–&gt; 路由器:"></a>0X03: Server –回包–&gt; 路由器:</h3><ol><li>Server处理完毕, 生成回包, 由于remoteIp不在网段:<br><code>&#123;localIp, localPort&#125;, &#123;remoteIp, remotePort&#125;</code></li><li>Server发送ARP广播, 查找默认网关(server端事先配置好了网关的IP)的MAC地址 {gatewayIp} –&gt; {gatewayMac}</li><li>Server封装二层帧, 发送给路由器:<br><code>&#123;localMac, localIp, localPort&#125;, &#123;gatewayMac, remoteIp, remotePort&#125;</code></li></ol><h3 id="0X04-路由器PAT处理回包"><a href="#0X04-路由器PAT处理回包" class="headerlink" title="0X04: 路由器PAT处理回包"></a>0X04: 路由器PAT处理回包</h3><p>后经查证，<mark> 针对回包，不会再过iptables</mark>，进行如下NAT反向查表了。<br>实际看了下，确实没有同时创建出如下反向的iptables规则。<br>而是<mark>由kernel模块conntrack进行维护完成{mac, ip, port}的替换。<mark></p><ol><li><del>收到二层帧:<br><code>&#123;localMac, localIp, localPort&#125;, &#123;gatewayMac, remoteIp, remotePort&#125;</code></del></li><li><del>反向查找NAT表:<br><code>&#123;localIp, localPort&#125; --&gt; &#123;publicIp, publicPort&#125;</code></del></li><li><del>修改三层包(替换掉localIp, localPort):<br><code>&#123;publicIp, publicPort&#125;, &#123;remoteIp, remotePort&#125;</code></del></li><li><del>二层帧修改(修改掉localMac, gatewayMac):<br><code>&#123;publicMac, publicIp, publicPort&#125;, &#123;remoteMac, remoteIp, remotePort&#125;</code></del></li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>路由器本身是有多个网卡的, 内网中是 {gatewayMac, gatewayIp}, 对应的公网是 {publicMac, publicIp}</p><h1 id="SNAT总结"><a href="#SNAT总结" class="headerlink" title="SNAT总结"></a>SNAT总结</h1><p>&#x2F;&#x2F; TODO: 如何作用在postrouting阶段？</p><h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><p>核心是路由器怎么创建NAT表? 使用iptables么? 怎么操作iptables能实现相同功能? </p><h1 id="实践-amp-验证"><a href="#实践-amp-验证" class="headerlink" title="实践&amp;验证"></a>实践&amp;验证</h1><p>&#x2F;&#x2F; TODO: </p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul><li><a href="https://blog.k8s.li/linux-net-and-iptables.html#%E5%85%B3%E7%B3%BB">Linux 网络和 iptables 运行原理</a></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>最近研究关于网络, 有一堆的概念, 一堆的坑要填, 这里先列出来: </p><ul><li>几张表, 作用是啥? 分别如何查看表项? <ul><li>cam表</li><li>arp缓存表</li><li>nat表</li><li>dns缓存表</li></ul></li><li>几种设备: <ul><li>三层交换机与二层交换机区别?</li><li>Linux网桥与交换机有啥区别?</li></ul></li><li>几个技术细节<ul><li>网卡混杂模式? 啥时候下开启? 应用场景是啥?</li><li>会不会收到MAC地址匹配, 但IP地址不匹配的IP包? 具体咋处理? 直接丢弃? 还是可以使用? </li><li>ip forwarding 是啥? 为啥NAT模式下需要开启? 为啥不默认开启? </li><li>ip隧道的原理是啥? </li><li>lvs的几种工作原理再研究, 再实践验证</li><li>组播的应用场景是啥? 很重要么?</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;经常在家用路由器中, 看到有端口映射(PAT)选项, 但不明所以.&lt;br&gt;最近刚好在研究NAT, 知道了&lt;mark&gt;PAT本质是NAT的一种实现方式, 更确切地说是DNAT的一种实现方式&lt;/mark&gt;.&lt;br&gt;因此借此机会好好研究下.&lt;/p&gt;
&lt;h1 id=&quot;DNAT总结&quot;&gt;&lt;a href=&quot;#DNAT总结&quot; class=&quot;headerlink&quot; title=&quot;DNAT总结&quot;&gt;&lt;/a&gt;DNAT总结&lt;/h1&gt;&lt;h2 id=&quot;PAT作用概述&quot;&gt;&lt;a href=&quot;#PAT作用概述&quot; class=&quot;headerlink&quot; title=&quot;PAT作用概述&quot;&gt;&lt;/a&gt;PAT作用概述&lt;/h2&gt;&lt;p&gt;家用路由器中配置PAT, 本质上还是一种&lt;code&gt;内网穿透&lt;/code&gt;的实现方式，或者DNAT的一种方式。&lt;br&gt;即需要把家里内网某台主机的某个服务, 暴露到公网上, 以便能在公网环境下访问该服务.&lt;br&gt;例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;家庭内网网段是&lt;code&gt;192.168.3.0/24&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;家用路由器, 电信运营商分配的对外公网IP是&lt;code&gt;115.192.71.187&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;某台主机IP是&lt;code&gt;192.168.3.213&lt;/code&gt;: &lt;ul&gt;
&lt;li&gt;暴露了8080的某个tomcat服务, 想要把这个服务暴露在公网上, 以便其他人能够访问.&lt;/li&gt;
&lt;li&gt;暴露了远程桌面RDP端口服务, 以便在公司或者咖啡厅, 能访问到该远程桌面.&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此时可以在路由器上开启端口映射(PAT), 将路由器上某个端口(如8888)与内网主机的端口(如8080)如进行映射, 所有访问{路由器IP, 8888端口}的请求, 就会被自动路由到{内网IP, 8080端口}上:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206232339615.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; TODO: 这里挖个坑, 内网穿透除了PAT外, 还有其他方案, 例如 &lt;code&gt;花生壳&lt;/code&gt;, 后边新开篇章讲下原理.&lt;/p&gt;
&lt;h2 id=&quot;原理概述&quot;&gt;&lt;a href=&quot;#原理概述&quot; class=&quot;headerlink&quot; title=&quot;原理概述&quot;&gt;&lt;/a&gt;原理概述&lt;/h2&gt;&lt;p&gt;本质上是家用路由器保存了这么一张NAT表:&lt;br&gt;&lt;code&gt;&amp;#123;publicIp, publicPort&amp;#125;&lt;/code&gt; —映射到—&amp;gt; &lt;code&gt;&amp;#123;localIp, localPort&amp;#125;&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://davyjones2010.github.io/tags/linux/"/>
    
    <category term="iaas" scheme="https://davyjones2010.github.io/tags/iaas/"/>
    
    <category term="network" scheme="https://davyjones2010.github.io/tags/network/"/>
    
    <category term="cloud-computing" scheme="https://davyjones2010.github.io/tags/cloud-computing/"/>
    
    <category term="nat" scheme="https://davyjones2010.github.io/tags/nat/"/>
    
    <category term="pat" scheme="https://davyjones2010.github.io/tags/pat/"/>
    
  </entry>
  
  <entry>
    <title>Linux虚拟网络与网络设备</title>
    <link href="https://davyjones2010.github.io/2022-06-19-linux-virtual-network/"/>
    <id>https://davyjones2010.github.io/2022-06-19-linux-virtual-network/</id>
    <published>2022-06-19T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>使用VMWare或者KVM设置VM网络时, 通常会有几种网络模式: </p><ul><li>网桥模式(Bridge模式)</li><li>NAT模式</li></ul><p>之前一直比较迷惑, 不是特别清楚区别, 最近研究终于搞懂了, 总结如下: </p><h1 id="网桥模式"><a href="#网桥模式" class="headerlink" title="网桥模式"></a>网桥模式</h1><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><ol><li>本质上把Linux网桥看做一个二层的交换机.</li><li>VM连接到该网桥, 获取访问外网能力.</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202216042.png" alt="linux-bridge"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>因此</p><ol><li>VM的IP与Host的IP是在同一个网段上的</li><li>VM在网络中的位置与Host是并列的</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202214199.png" alt="VM"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202215507.png" alt="Host"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202216645.png" alt="VM Route Table"></p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><p>网桥操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brctl show<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>安装工具</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> net-tools -yyum <span class="token function">install</span> bridge-utils -y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>配置</p></li></ul><h1 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h1><h2 id="本质-1"><a href="#本质-1" class="headerlink" title="本质"></a>本质</h2><ol><li>本质上是Host看做一个NAT设备</li><li>VM连接到该NAT设备上, 获取访问外网能力.</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202212554.png"></p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>因此</p><ol><li>VM的IP与Host的IP不在同一个网段</li><li>VM在网络中的位置是从属于Host</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202159960.png" alt="VM在192.168.230.0/24网段"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202200319.png" alt="Host在192.168.3.0/24网段"></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>&#x2F;&#x2F; TODO:</p><h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><p>这里 VM的网桥模式 与 docker的网桥&#x2F;Bridge模式 是有很大区别的。</p><ul><li>VM 网桥&#x2F;桥接模式: VM与HOST在同一个网段。</li><li>Docker Bridge模式： Docker容器与HOST不在同一个网段。<blockquote><p>Bridge 是 docker 默认的网络模式。<br>原理跟 vmware 的 NAT 模式相同。<br>安装 docker 时，会给宿主机创建一个 docker0 网卡，该网卡会与一个虚拟交换机相连，<br>当容器以 Bridge 模式创建启动时，会给容器创建一个虚拟网卡，该网卡分配的 IP 与宿主机的 docker0 所在同一个局域网内 (一般是 172.16.0.0)。<br>然后过程就和 vmware 的 NAT 模式完全相同。</p></blockquote></li></ul><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul><li><a href="https://learnku.com/docs/go-micro-build/1.0/explain-the-network-mode-of-vmware-and-docker/8879"> Vmware和Docker的网络模式讲解</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;使用VMWare或者KVM设置VM网络时, 通常会有几种网络模式: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网桥模式(Bridge模式)&lt;/li&gt;
&lt;li&gt;NAT模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前一直比较迷惑, 不是特别清楚区别, 最近研究终于搞懂了, 总结如下: &lt;/p&gt;
&lt;h1 id=&quot;网桥模式&quot;&gt;&lt;a href=&quot;#网桥模式&quot; class=&quot;headerlink&quot; title=&quot;网桥模式&quot;&gt;&lt;/a&gt;网桥模式&lt;/h1&gt;&lt;h2 id=&quot;本质&quot;&gt;&lt;a href=&quot;#本质&quot; class=&quot;headerlink&quot; title=&quot;本质&quot;&gt;&lt;/a&gt;本质&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;本质上把Linux网桥看做一个二层的交换机.&lt;/li&gt;
&lt;li&gt;VM连接到该网桥, 获取访问外网能力.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202216042.png&quot; alt=&quot;linux-bridge&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;p&gt;因此&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://davyjones2010.github.io/tags/linux/"/>
    
    <category term="iaas" scheme="https://davyjones2010.github.io/tags/iaas/"/>
    
    <category term="network" scheme="https://davyjones2010.github.io/tags/network/"/>
    
    <category term="cloud-computing" scheme="https://davyjones2010.github.io/tags/cloud-computing/"/>
    
    <category term="nat" scheme="https://davyjones2010.github.io/tags/nat/"/>
    
    <category term="pat" scheme="https://davyjones2010.github.io/tags/pat/"/>
    
  </entry>
  
  <entry>
    <title>大学对我的影响</title>
    <link href="https://davyjones2010.github.io/2022-06-17-university-summary/"/>
    <id>https://davyjones2010.github.io/2022-06-17-university-summary/</id>
    <published>2022-06-17T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.341Z</updated>
    
    <content type="html"><![CDATA[<p>一年一度如火如荼的高考季结束. 蓦然回首, 自己已然高中毕业13年, 大学也毕业9年了.<br>9年时间, 改变了很多, 足以把一个鲜衣怒马, 意气风发, 唇红齿白的少年, 变成而今房贷和车贷缠身, 视力与体力俱下, 惶惶不可终日的油腻中年.</p><p>但最近也一直在酝酿与反思, 这短短四年的大学生活, 究竟带给了我什么?<br>当我在收到外卖, 外卖员说都怪自己没上大学, 才落得今天下苦力.<br>当我在坐网约车, 司机说要不是自己没上大学, 也不至于现在每天被公司压榨.</p><p>四年的生活, 有什么样的魔力, 真的足以把人群完成阶级划分么?<br>现在把杂乱的思绪总结成文, 聊以慰藉.</p><h1 id="一-让我看到了一个更大的世界"><a href="#一-让我看到了一个更大的世界" class="headerlink" title="一: 让我看到了一个更大的世界"></a>一: 让我看到了一个更大的世界</h1><hr><p>这个话说得可能有点儿大, 有点儿虚, 但确实上大学, 让我这个小镇青年, 有机会第一次离开了那个只有60万人口的小城市,<br>进入到一个二三线城市, 看到了一个更大的世界.</p><h2 id="地理上的冲击"><a href="#地理上的冲击" class="headerlink" title="地理上的冲击"></a>地理上的冲击</h2><p>家乡处于豫西北一个不起眼的角落, 三面环山的盆地, 剩余一面被黄河阻隔.<br>伟大的太行山与王屋山交汇于此. <br>而我从小生活在太行山脚下, 听着愚公移山的故事长大. <br>18岁前从来没有离开过那片大山. <br>年少的我一直很好奇山的后边是什么? 会不会是一片蔚蓝色的大海呢? 会不会是一个喧嚣繁华, 高楼林立, 霓虹闪烁的都市呢?<br>曾经跟随奶奶上坟, 翻越了眼前那座大山, 发现在山的后边, 仍然是山, 是无穷无尽绵延不绝的山, 是目之所及毫无颓势的山脉.<br>沮丧至极.  </p><blockquote><p>没有人知道为什么 <br/><br>太阳总下到山的那一边 <br/><br>没有人能够告诉我  <br/><br>山里面有没有住着神仙 <br/><br>多少的日子里总是 <br/><br>一个人面对着天空发呆 <br/><br>就这么好奇就这么幻想 <br/><br>这么孤单的童年 <br/></p></blockquote><p>而上大学给了我一次机会,<br>能光明正大理直气壮地彻底逃离这片群山,<br>毅然决然地选择离家2000公里外的厦门.</p><p>我来自大山, <br>我要奔赴向大海. </p><p>第一次到海边, 第一次吃到芒果荔枝肯德基麦当劳, </p><blockquote><p>父母在, 不远游. <br/><br>游必有方. <br/></p></blockquote><h2 id="文化上的冲击"><a href="#文化上的冲击" class="headerlink" title="文化上的冲击"></a>文化上的冲击</h2><p>同学都来自五湖四海, </p><h2 id="思想上的冲击"><a href="#思想上的冲击" class="headerlink" title="思想上的冲击"></a>思想上的冲击</h2><p>很快就体会到了贫富差距与阶级差异.<br>当我还在省吃俭用只为买个100多元的<code>蓝魔MP3</code>, 甚至兴奋地睡不着时, 隔壁宿舍的同学就已经开始用<code>iPod touch</code>通过陀螺仪玩赛车游戏了.<br>当我还在用<code>小灵通</code>的时候, 室友就已经开始用<code>iPhone 3Gs</code>了. 当第一次试用, 彻底颠覆了我的想象, 才知道原来手机可以是这样的. </p><blockquote><p>每次室友手机解锁时, 经典的”咔哒”声音, 令我羡慕, 至今仍在我耳边回响, 是我永远逾越不了的鸿沟.</p></blockquote><p>当我为了省钱, 选择花费120元, 硬座坐43小时火车跨越四千里回家, 腰酸背痛, 双腿浮肿时; 室友与爸妈选择坐飞机, 去香港购物度假.<br>当我知道室友原来竟然没有参加高考, 直接通过竞赛保送到大学; 而我却几乎拼出了半条命, 才得以在当年100万考生中杀出了一条血路.<br>当看到室友的班级通讯录里, 前四五十都是清一色的清北浙交; 我们河南的同伴</p><p>很庆幸自己没有因为这些差异导致走向消极与虚无, 走向愤怒与反抗, 而是接受这些冲击, 这就是生活.<br>然后一点一点地再努力一些, </p><p>当然, 外卖员, 网约车司机可能也是一样, 借由来城市打工.</p><h1 id="二-让我拥有了独立思考与探索知识的能力"><a href="#二-让我拥有了独立思考与探索知识的能力" class="headerlink" title="二: 让我拥有了独立思考与探索知识的能力"></a>二: 让我拥有了独立思考与探索知识的能力</h1><hr><p>第一次在同学宿舍, 看到了墙外的世界.<br>批判型思维.<br>成长型思维.</p><h1 id="三-让我拥有了破除任何神话人物的信心与勇气"><a href="#三-让我拥有了破除任何神话人物的信心与勇气" class="headerlink" title="三: 让我拥有了破除任何神话人物的信心与勇气"></a>三: 让我拥有了破除任何神话人物的信心与勇气</h1><hr><p>正是因为接受了思想上的冲击, 所以至今我心底里从不会崇拜或者神话任何一个人.<br>相信自己</p><h1 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h1><hr><p>最近也在看&lt;规模&gt;这本书, 城市, 真的会让生活更美好么? </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一年一度如火如荼的高考季结束. 蓦然回首, 自己已然高中毕业13年, 大学也毕业9年了.&lt;br&gt;9年时间, 改变了很多, 足以把一个鲜衣怒马, 意气风发, 唇红齿白的少年, 变成而今房贷和车贷缠身, 视力与体力俱下, 惶惶不可终日的油腻中年.&lt;/p&gt;
&lt;p&gt;但最近也一直在酝酿与反思, 这短短四年的大学生活, 究竟带给了我什么?&lt;br&gt;当我在收到外卖, 外卖员说都怪自己没上大学, 才落得今天下苦力.&lt;br&gt;当我在坐网约车, 司机说要不是自己没上大学, 也不至于现在每天被公司压榨.&lt;/p&gt;
&lt;p&gt;四年的生活, 有什么样的魔力, 真的足以把人群完成阶级划分么?&lt;br&gt;现在把杂乱的思绪总结成文, 聊以慰藉.&lt;/p&gt;
&lt;h1 id=&quot;一-让我看到了一个更大的世界&quot;&gt;&lt;a href=&quot;#一-让我看到了一个更大的世界&quot; class=&quot;headerlink&quot; title=&quot;一: 让我看到了一个更大的世界&quot;&gt;&lt;/a&gt;一: 让我看到了一个更大的世界&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;这个话说得可能有点儿大, 有点儿虚, 但确实上大学, 让我这个小镇青年, 有机会第一次离开了那个只有60万人口的小城市,&lt;br&gt;进入到一个二三线城市, 看到了一个更大的世界.&lt;/p&gt;
&lt;h2 id=&quot;地理上的冲击&quot;&gt;&lt;a href=&quot;#地理上的冲击&quot; class=&quot;headerlink&quot; title=&quot;地理上的冲击&quot;&gt;&lt;/a&gt;地理上的冲击&lt;/h2&gt;&lt;p&gt;家乡处于豫西北一个不起眼的角落, 三面环山的盆地, 剩余一面被黄河阻隔.&lt;br&gt;伟大的太行山与王屋山交汇于此. &lt;br&gt;而我从小生活在太行山脚下, 听着愚公移山的故事长大. &lt;br&gt;18岁前从来没有离开过那片大山. &lt;br&gt;年少的我一直很好奇山的后边是什么? 会不会是一片蔚蓝色的大海呢? 会不会是一个喧嚣繁华, 高楼林立, 霓虹闪烁的都市呢?&lt;br&gt;曾经跟随奶奶上坟, 翻越了眼前那座大山, 发现在山的后边, 仍然是山, 是无穷无尽绵延不绝的山, 是目之所及毫无颓势的山脉.&lt;br&gt;沮丧至极.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;没有人知道为什么 &lt;br&gt;&lt;br&gt;太阳总下到山的那一边 &lt;br&gt;&lt;br&gt;没有人能够告诉我  &lt;br&gt;&lt;br&gt;山里面有没有住着神仙 &lt;br&gt;&lt;br&gt;多少的日子里总是 &lt;br&gt;&lt;br&gt;一个人面对着天空发呆 &lt;br&gt;&lt;br&gt;就这么好奇就这么幻想 &lt;br&gt;&lt;br&gt;这么孤单的童年 &lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而上大学给了我一次机会,&lt;br&gt;能光明正大理直气壮地彻底逃离这片群山,&lt;br&gt;毅然决然地选择离家2000公里外的厦门.&lt;/p&gt;</summary>
    
    
    
    
    <category term="weekend" scheme="https://davyjones2010.github.io/tags/weekend/"/>
    
    <category term="diary" scheme="https://davyjones2010.github.io/tags/diary/"/>
    
    <category term="books" scheme="https://davyjones2010.github.io/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>Docker的一些总结II</title>
    <link href="https://davyjones2010.github.io/2022-06-11-docker-summary-2/"/>
    <id>https://davyjones2010.github.io/2022-06-11-docker-summary-2/</id>
    <published>2022-06-11T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="exec到容器的原理"><a href="#exec到容器的原理" class="headerlink" title="exec到容器的原理"></a>exec到容器的原理</h1><p>本质是在host上新创建一个进程, 加入到已存在的docker容器的Linux Namespace中.</p><h2 id="1-查看已有docker容器的namespace信息"><a href="#1-查看已有docker容器的namespace信息" class="headerlink" title="1. 查看已有docker容器的namespace信息"></a>1. 查看已有docker容器的namespace信息</h2><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206122047763.svg"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">ps</span><span class="token function">docker</span> inspect --format <span class="token string">'&#123;&#123; .State.Pid &#125;&#125;'</span> dockerContainerId<span class="token function">sudo</span> <span class="token function">ls</span> -l /proc/<span class="token variable">$pid</span>/ns<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2-通过setns-系统调用-将新进程加入到已有docker容器的namespace中"><a href="#2-通过setns-系统调用-将新进程加入到已有docker容器的namespace中" class="headerlink" title="2. 通过setns()系统调用, 将新进程加入到已有docker容器的namespace中"></a>2. 通过setns()系统调用, 将新进程加入到已有docker容器的namespace中</h2><p>核心代码如下: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">int main<span class="token punctuation">(</span>int argc, char *argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>int fd<span class="token punctuation">;</span>fd <span class="token operator">=</span> open<span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>, O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>if<span class="token punctuation">(</span>setns<span class="token punctuation">(</span>fd, <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">==</span>-1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>errExit<span class="token punctuation">(</span><span class="token string">"setns"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>execvp<span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>, <span class="token operator">&amp;</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>errExit<span class="token punctuation">(</span><span class="token string">"execvp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./set_ns /proc/<span class="token variable">$pid</span>/ns/net /bin/sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>argv[1]: 即当前新进程要加入的Namesapce文件路径</li><li>argv[2]: 即新进程要在Namesapce里运行的程序</li></ul><h2 id="3-验证"><a href="#3-验证" class="headerlink" title="3. 验证"></a>3. 验证</h2><p>如下样例, 通过exec进入容器, 在容器内编写并运行了一个<code>tmp.sh</code>脚本.<br>可以看到, <mark>实际上是在host上新建了一个进程, 且该进程与docker容器共享同一份namespace.</mark></p><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206122112834.svg"></p><h1 id="volume的原理"><a href="#volume的原理" class="headerlink" title="volume的原理"></a>volume的原理</h1><ul><li>允许将宿主机上指定的目录或者文件挂载到容器中读取和修改</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -v /test myimageid<span class="token function">docker</span> run -v /home:/test myimageid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>第一种方式, 没有显式声明宿主机目录, Docker默认在宿主机上创建一个临时目录<code>/var/lib/docker/volumes/[volume_id]/_data</code>, 然后把它挂载到容器的<code>/test</code>目录</li><li>第二种方式, 把宿主机的<code>/home</code>目录挂载到Docker的<code>/test</code>目录下</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206122150473.svg"></p><ul><li>这里用到的挂载技术, 就是<font color='red'>Linux的绑定挂载(bind mount)机制</font>. <mark>允许将一个目录或者文件, 而不是整个设备挂载到指定目录上.</mark></li><li>并且在挂载点上进行的任何操作, 只是发生在被挂载的目录或者文件上, 而原挂载点的内容会被隐藏起来, 且不受影响.</li></ul><h2 id="bind-mount-样例"><a href="#bind-mount-样例" class="headerlink" title="bind mount 样例"></a>bind mount 样例</h2><ul><li>将 <code>test2/</code> 目录挂载到 <code>test/</code> 目录(挂载点)下, 之后所有在<code>test/</code>下的修改在<code>test2/</code>下都能看到, 反之亦然.</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mount</span> --bind test2 <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>将 <code>test2/</code> 从 <code>test/</code> 目录(挂载点) 卸载掉, 之后<code>test/</code>维持一个空的挂载点, 所有变更都落到了<code>test2/</code>下</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">umount</span> <span class="token builtin class-name">test</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206122208304.svg"></p><h1 id="单机容器网络原理"><a href="#单机容器网络原理" class="headerlink" title="单机容器网络原理"></a>单机容器网络原理</h1><h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><blockquote><p>本质是通过 docker0网桥 + VethPair 实现单机间多个docker容器互联</p></blockquote><ul><li>docker0网桥 工作在数据链路层. 类似一个虚拟交换机. 维护 CAM表(交换机通过MAC地址学习维护的 端口与MAC地址的对应表)</li><li>各个容器通过 VethPair 与docker0网桥连接</li><li>从host-&gt;container, 路由规则, 需要通过 docker0 网桥; docker0网桥查询CAM表, 直接把请求转发到相应端口即可.</li><li>从container -&gt; container, 通过 veth pair 到达 docker0 网桥; docker0网桥查询CAM表, 直接把请求转发到相应端口即可.</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li>查看网桥信息</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brctl show<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看路由表</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">route<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206122305851.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206122305137.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206122305508.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206122305564.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;exec到容器的原理&quot;&gt;&lt;a href=&quot;#exec到容器的原理&quot; class=&quot;headerlink&quot; title=&quot;exec到容器的原理&quot;&gt;&lt;/a&gt;exec到容器的原理&lt;/h1&gt;&lt;p&gt;本质是在host上新创建一个进程, 加入到已存在的docker容器的Linux Namespace中.&lt;/p&gt;
&lt;h2 id=&quot;1-查看已有docker容器的namespace信息&quot;&gt;&lt;a href=&quot;#1-查看已有docker容器的namespace信息&quot; class=&quot;headerlink&quot; title=&quot;1. 查看已有docker容器的namespace信息&quot;&gt;&lt;/a&gt;1. 查看已有docker容器的namespace信息&lt;/h2&gt;&lt;p&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206122047763.svg&quot;&gt;&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;docker&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ps&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;docker&lt;/span&gt; inspect --format &lt;span class=&quot;token string&quot;&gt;&#39;&amp;#123;&amp;#123; .State.Pid &amp;#125;&amp;#125;&#39;&lt;/span&gt; dockerContainerId
&lt;span class=&quot;token function&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ls&lt;/span&gt; -l /proc/&lt;span class=&quot;token variable&quot;&gt;$pid&lt;/span&gt;/ns&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;2-通过setns-系统调用-将新进程加入到已有docker容器的namespace中&quot;&gt;&lt;a href=&quot;#2-通过setns-系统调用-将新进程加入到已有docker容器的namespace中&quot; class=&quot;headerlink&quot; title=&quot;2. 通过setns()系统调用, 将新进程加入到已有docker容器的namespace中&quot;&gt;&lt;/a&gt;2. 通过setns()系统调用, 将新进程加入到已有docker容器的namespace中&lt;/h2&gt;&lt;p&gt;核心代码如下: &lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;int main&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;int argc, char *argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;#123;&lt;/span&gt;
	int fd&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	fd &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; open&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;, O_RDONLY&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	if&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;setns&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;fd, &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt;-1&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;#123;&lt;/span&gt;
		errExit&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;setns&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;&amp;#125;&lt;/span&gt;
	execvp&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;, &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	errExit&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;execvp&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;&amp;#125;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;./set_ns /proc/&lt;span class=&quot;token variable&quot;&gt;$pid&lt;/span&gt;/ns/net /bin/sh&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;argv[1]: 即当前新进程要加入的Namesapce文件路径&lt;/li&gt;
&lt;li&gt;argv[2]: 即新进程要在Namesapce里运行的程序&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="k8s" scheme="https://davyjones2010.github.io/tags/k8s/"/>
    
    <category term="docker" scheme="https://davyjones2010.github.io/tags/docker/"/>
    
    <category term="container" scheme="https://davyjones2010.github.io/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析Kubernetes笔记</title>
    <link href="https://davyjones2010.github.io/2022-06-11-k8s-deep-dive/"/>
    <id>https://davyjones2010.github.io/2022-06-11-k8s-deep-dive/</id>
    <published>2022-06-11T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.341Z</updated>
    
    <content type="html"><![CDATA[<p>很久没有看到这么一本书了, 虽然刚拿到手感觉很薄, 只有不到400页, 价格也贵, 99元.<br>比起<a href="https://book.douban.com/subject/33444476/">k8s权威指南</a>这种大部头, 略显单薄.<br>但实际翻看前两章之后, 欣喜万分. 越往后看, 愈发觉得鞭辟入里.<br>从底层原理出发, 没有废话, 深入且细致地讲解出docker&#x2F;k8s实现的各种细节.<br>有效地解释了自己心中的诸多疑惑. 物有所值. </p><hr><h1 id="一些疑惑解释"><a href="#一些疑惑解释" class="headerlink" title="一些疑惑解释"></a>一些疑惑解释</h1><h2 id="多进程-x2F-富容器"><a href="#多进程-x2F-富容器" class="headerlink" title="多进程&#x2F;富容器"></a>多进程&#x2F;富容器</h2><ul><li>Q: 如果docker中起了多个进程, 那么在宿主机上是怎样的? 是多个进程 or docker进程中的多个线程?</li><li>A: 在宿主机上是多个进程. 本质上是通过新建进程, 将新进程加入到已经存在的Namespace中实现.</li></ul><hr><ul><li>Q: 富容器是如何实现的?</li><li>A:</li></ul><hr><ul><li><p>Q: docker exec 到容器中执行命令, 理论上容器也新开了个进程执行该命令(也就类似富容器了), 是如何实现的? </p></li><li><p>A: </p></li><li><p>Q: 富容器模式有什么缺点? 为啥不推荐使用富容器? </p><ul><li>A:</li></ul></li></ul><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;很久没有看到这么一本书了, 虽然刚拿到手感觉很薄, 只有不到400页, 价格也贵, 99元.&lt;br&gt;比起&lt;a href=&quot;https://book.douban.com/subject/33444476/&quot;&gt;k8s权威指南&lt;/a&gt;这种大部头, 略显单薄.&lt;br&gt;但实际翻看前两章之后, 欣喜万分. 越往后看, 愈发觉得鞭辟入里.&lt;br&gt;从底层原理出发, 没有废话, 深入且细致地讲解出docker&amp;#x2F;k8s实现的各种细节.&lt;br&gt;有效地解释了自己心中的诸多疑惑. 物有所值. &lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;一些疑惑解释&quot;&gt;&lt;a href=&quot;#一些疑惑解释&quot; class=&quot;headerlink&quot; title=&quot;一些疑惑解释&quot;&gt;&lt;/a&gt;一些疑惑解释&lt;/h1&gt;&lt;h2 id=&quot;多进程-x2F-富容器&quot;&gt;&lt;a href=&quot;#多进程-x2F-富容器&quot; class=&quot;headerlink&quot; title=&quot;多进程&amp;#x2F;富容器&quot;&gt;&lt;/a&gt;多进程&amp;#x2F;富容器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Q: 如果docker中起了多个进程, 那么在宿主机上是怎样的? 是多个进程 or docker进程中的多个线程?&lt;/li&gt;
&lt;li&gt;A: 在宿主机上是多个进程. 本质上是通过新建进程, 将新进程加入到已经存在的Namespace中实现.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Q: 富容器是如何实现的?&lt;/li&gt;
&lt;li&gt;A:&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Q: docker exec 到容器中执行命令, 理论上容器也新开了个进程执行该命令(也就类似富容器了), 是如何实现的? &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A: &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Q: 富容器模式有什么缺点? 为啥不推荐使用富容器? &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网络模型&quot;&gt;&lt;/a&gt;网络模型&lt;/h2&gt;</summary>
    
    
    
    
    <category term="books" scheme="https://davyjones2010.github.io/tags/books/"/>
    
    <category term="k8s" scheme="https://davyjones2010.github.io/tags/k8s/"/>
    
    <category term="2022" scheme="https://davyjones2010.github.io/tags/2022/"/>
    
    <category term="docker" scheme="https://davyjones2010.github.io/tags/docker/"/>
    
    <category term="container" scheme="https://davyjones2010.github.io/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>asciinema使用笔记</title>
    <link href="https://davyjones2010.github.io/2022-06-10-asciinema/"/>
    <id>https://davyjones2010.github.io/2022-06-10-asciinema/</id>
    <published>2022-06-10T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><ul><li><a href="https://github.com/asciinema/asciinema">asciinema</a></li><li><a href="https://github.com/marionebl/svg-term-cli">svg-term-cli</a></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew <span class="token function">install</span> nodejs<span class="token function">npm</span> <span class="token function">install</span> -g svg-term-cli<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="生成录屏文件-cast"><a href="#生成录屏文件-cast" class="headerlink" title="生成录屏文件.cast"></a>生成录屏文件.cast</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">asciinema rec a.cast<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>Ctrl + D 结束录屏</code></p><h1 id="本地播放录屏文件"><a href="#本地播放录屏文件" class="headerlink" title="本地播放录屏文件"></a>本地播放录屏文件</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">asciinema play a.cast<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="cast文件转成-svg文件"><a href="#cast文件转成-svg文件" class="headerlink" title=".cast文件转成.svg文件"></a>.cast文件转成.svg文件</h1><p>需要先安装 <a href="https://github.com/marionebl/svg-term-cli">svg-term-cli</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> a.cast <span class="token operator">|</span> svg-term --out a.svg --term iterm2 --profile mymatrix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p><a href="https://asciinema.org/docs/config">$HOME&#x2F;.config&#x2F;asciinema&#x2F;config</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;安装软件&quot;&gt;&lt;a href=&quot;#安装软件&quot; class=&quot;headerlink&quot; title=&quot;安装软件&quot;&gt;&lt;/a&gt;安装软件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/asciinema/asciinema&quot;&gt;asciinema&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/marionebl/svg-term-cli&quot;&gt;svg-term-cli&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;brew &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; nodejs
&lt;span class=&quot;token function&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; -g svg-term-cli&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&quot;生成录屏文件-cast&quot;&gt;&lt;a href=&quot;#生成录屏文件-cast&quot; class=&quot;headerlink&quot; title=&quot;生成录屏文件.cast&quot;&gt;&lt;/a&gt;生成录屏文件.cast&lt;/h1&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;asciinema rec a.cast&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Ctrl + D 结束录屏&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;本地播放录屏文件&quot;&gt;&lt;a href=&quot;#本地播放录屏文件&quot; class=&quot;headerlink&quot; title=&quot;本地播放录屏文件&quot;&gt;&lt;/a&gt;本地播放录屏文件&lt;/h1&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;asciinema play a.cast&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;cast文件转成-svg文件&quot;&gt;&lt;a href=&quot;#cast文件转成-svg文件&quot; class=&quot;headerlink&quot; title=&quot;.cast文件转成.svg文件&quot;&gt;&lt;/a&gt;.cast文件转成.svg文件&lt;/h1&gt;&lt;p&gt;需要先安装 &lt;a href=&quot;https://github.com/marionebl/svg-term-cli&quot;&gt;svg-term-cli&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="mac" scheme="https://davyjones2010.github.io/tags/mac/"/>
    
    <category term="tools" scheme="https://davyjones2010.github.io/tags/tools/"/>
    
    <category term="asciinema" scheme="https://davyjones2010.github.io/tags/asciinema/"/>
    
    <category term="svg" scheme="https://davyjones2010.github.io/tags/svg/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Transactional AOP 实现原理研究</title>
    <link href="https://davyjones2010.github.io/2022-06-06-spring-tx-annonation/"/>
    <id>https://davyjones2010.github.io/2022-06-06-spring-tx-annonation/</id>
    <published>2022-06-06T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>书接上回 <a href="https://davyjones2010.github.io/2022-06-03-spring-annotation-on-interface/">SpringBoot基于Interface的Annotation在AOP中如何生效I</a>,<br>里边只是简略地说明了Spring中 @Transactional 只能在jdk proxy场景下生效, 在cglib场景下不生效, 但没有研究具体代码实现.<br>本文详细探究下.</p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="0-Spring-AOP整体流程"><a href="#0-Spring-AOP整体流程" class="headerlink" title="0. Spring AOP整体流程"></a>0. Spring AOP整体流程</h2><p>Spring把所有Bean初始化完成, 容器启动前, 会遍历容器中的每个bean, 执行方法, 尝试找到可用的advisor, 生成新的增强bean, 方法入口: <code>org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#findEligibleAdvisors</code><br>详细步骤: </p><ol><li>从Spring Context里找到所有Advisors: <code>org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#findCandidateAdvisors</code></li><li>根据Advisors里的PointCuts&#x2F;JoinPoints定义, 判断该bean是否可以被该Advisor增强. <code>org.springframework.aop.support.AopUtils#canApply(org.springframework.aop.Advisor, java.lang.Class&lt;?&gt;, boolean)</code></li><li>获取到该bean可以被增强的advisors列表</li><li>根据配置<code>spring.aop.proxy-target-class=true/false</code>, 使用Cglib或者JDK生成代理bean. <code>org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy</code></li><li>之后从Spring容器中获取bean(getBean或者通过@Autowired等自动注入), 实际上获取到的是代理bean.</li></ol><h2 id="1-Transactional-的JoinPoint-x2F-PointCut定义"><a href="#1-Transactional-的JoinPoint-x2F-PointCut定义" class="headerlink" title="1. @Transactional 的JoinPoint&#x2F;PointCut定义"></a>1. @Transactional 的JoinPoint&#x2F;PointCut定义</h2><ul><li>JoinPoint or PointCut, 在AOP里即是类似SQL中where的条件, 即哪些符合条件的class&#x2F;bean&#x2F;method需要被增强.</li><li>JoinPoint标准接口定义如下: 核心是<code>matches</code>方法.</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">StaticMethodMatcher</span> <span class="token keyword">implements</span> <span class="token class-name">MethodMatcher</span> <span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// should never be invoked because isRuntime() returns false</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token string">"Illegal MethodMatcher usage"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>@Transactional</code> 使用的是: <code>org.springframework.transaction.interceptor.TransactionAttributeSourcePointcut</code>, 而<mark>该pointcut, 会按照类继承关系向上寻找, 找到接口层面定义的annotation.</mark> </li><li>详细测试代码参见: <a href="https://github.com/DavyJones2010/head-first-spring/blob/feature/20220603_annotation_on_interface/src/test/java/edu/xmu/kunlun/headfirst/spring/tx/aop/BeanFactoryTransactionAttributeSourceAdvisorTest.java">edu.xmu.kunlun.headfirst.spring.tx.aop.BeanFactoryTransactionAttributeSourceAdvisorTest#matchesTest</a></li></ul><h2 id="2-Transactional-的Advice定义"><a href="#2-Transactional-的Advice定义" class="headerlink" title="2. @Transactional 的Advice定义"></a>2. @Transactional 的Advice定义</h2><ul><li>Advice, 在AOP里即是类似SQL中聚合函数, 即需要对符合条件的class&#x2F;bean&#x2F;method做什么处理.</li><li>Advice标准接口详细定义如下:</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MethodInterceptor</span> <span class="token keyword">extends</span> <span class="token class-name">Interceptor</span> <span class="token punctuation">&#123;</span><span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nonnull</span> <span class="token class-name">MethodInvocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>@Transactional</code> 使用的是: <code>org.springframework.transaction.interceptor.TransactionInterceptor</code>, 即会在<code>invocation.proceed();</code>前后分别开启与提交事务.</li></ul><h2 id="3-Transactional-的Advisor定义"><a href="#3-Transactional-的Advisor定义" class="headerlink" title="3. @Transactional 的Advisor定义"></a>3. @Transactional 的Advisor定义</h2><ul><li>Advisor or Aspect, 就是 JoinPoint + Advice, 同时需要作为bean注册在Spring中, 方便Spring容器启动时, 执行<code>从Spring Context里找到所有Advisors</code>步骤.</li><li><code>@Transactional</code> 使用的是: <code>org.springframework.transaction.interceptor.BeanFactoryTransactionAttributeSourceAdvisor</code></li><li>所以我们一般都会在 Aspect 上打上 @Aspect + @Component 的标签</li></ul><h2 id="4-Transactional-的AdvisorBean初始化-amp-组装"><a href="#4-Transactional-的AdvisorBean初始化-amp-组装" class="headerlink" title="4. @Transactional 的AdvisorBean初始化&amp;组装"></a>4. @Transactional 的AdvisorBean初始化&amp;组装</h2><ul><li>代码位置: <code>org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration#transactionAdvisor</code></li><li>本质是在 <code>@Configuration</code> 里通过 <code>@Bean</code> new出Bean<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206072232406.png"></li></ul><h2 id="完整样例"><a href="#完整样例" class="headerlink" title="完整样例"></a>完整样例</h2><ul><li>如下样例:</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Aspect</span> <span class="token comment">// 向Spring容器说明是个Aspect/Advisor</span><span class="token annotation punctuation">@Component</span> <span class="token comment">// 向Spring容器注册, 方便找到该bean</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PerfAspect</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"@annotation(Perf)"</span><span class="token punctuation">)</span> <span class="token comment">// 作为PointCut定义</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">perf</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span> <span class="token comment">//方法体作为Advice</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> methodName <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">getSignature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>methodName <span class="token operator">+</span> <span class="token string">" start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            o <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>methodName <span class="token operator">+</span> <span class="token string">" finished cost: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> o<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="实际验证"><a href="#实际验证" class="headerlink" title="实际验证"></a>实际验证</h1><h2 id="强制使用cglib-接口上的-Transactional-能否被正常增强"><a href="#强制使用cglib-接口上的-Transactional-能否被正常增强" class="headerlink" title="强制使用cglib, 接口上的 @Transactional 能否被正常增强?"></a>强制使用cglib, 接口上的 @Transactional 能否被正常增强?</h2><ul><li>在springboot配置里, <code>spring.aop.proxy-target-class=true</code></li><li><a href="https://github.com/DavyJones2010/head-first-spring/blob/feature/20220603_annotation_on_interface/src/test/java/edu/xmu/kunlun/headfirst/spring/tx/TransApiTest.java">TransApiTest#updateTest代码样例</a></li><li>如下发现<code>TransApi</code>是被cglib正常增强, 类名: <code>class edu.xmu.kunlun.headfirst.spring.tx.TransApiImpl$$EnhancerBySpringCGLIB$$2586b9e2</code>, 事务能被正常启动</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206062333446.png"></p><h2 id="强制使用jdk-proxy-接口上的-Transactional-能否被正常增强"><a href="#强制使用jdk-proxy-接口上的-Transactional-能否被正常增强" class="headerlink" title="强制使用jdk proxy, 接口上的 @Transactional 能否被正常增强?"></a>强制使用jdk proxy, 接口上的 @Transactional 能否被正常增强?</h2><ul><li>在springboot配置里, <code>spring.aop.proxy-target-class=false</code></li><li><a href="https://github.com/DavyJones2010/head-first-spring/blob/feature/20220603_annotation_on_interface/src/test/java/edu/xmu/kunlun/headfirst/spring/tx/TransApiTest.java">TransApiTest#updateTest代码样例</a></li><li>如下发现<code>TransApi</code>是被jdk正常增强, 类名: <code>class com.sun.proxy.$Proxy56</code>, 事务能被正常启动</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206062335278.png"></p><ul><li>httodo: 这里与spring官方文档说明有所不同. 根据上述代码分析, 其实到底能不能增强, 与到底使用cglib还是使用jdk-proxy没啥关系, 只与JoinPoint&#x2F;PointCut的实现有关系. 待最终探究确认.</li></ul><h1 id="Code-Samples"><a href="#Code-Samples" class="headerlink" title="Code Samples"></a>Code Samples</h1><ul><li><a href="https://github.com/DavyJones2010/head-first-spring/tree/feature/20220603_annotation_on_interface">本篇博文里完整的spring aop code sample</a></li></ul><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;书接上回 &lt;a href=&quot;https://davyjones2010.github.io/2022-06-03-spring-annotation-on-interface/&quot;&gt;SpringBoot基于Interface的Annotation在AOP中如何生效I&lt;/a&gt;,&lt;br&gt;里边只是简略地说明了Spring中 @Transactional 只能在jdk proxy场景下生效, 在cglib场景下不生效, 但没有研究具体代码实现.&lt;br&gt;本文详细探究下.&lt;/p&gt;
&lt;h1 id=&quot;代码分析&quot;&gt;&lt;a href=&quot;#代码分析&quot; class=&quot;headerlink&quot; title=&quot;代码分析&quot;&gt;&lt;/a&gt;代码分析&lt;/h1&gt;&lt;h2 id=&quot;0-Spring-AOP整体流程&quot;&gt;&lt;a href=&quot;#0-Spring-AOP整体流程&quot; class=&quot;headerlink&quot; title=&quot;0. Spring AOP整体流程&quot;&gt;&lt;/a&gt;0. Spring AOP整体流程&lt;/h2&gt;&lt;p&gt;Spring把所有Bean初始化完成, 容器启动前, 会遍历容器中的每个bean, 执行方法, 尝试找到可用的advisor, 生成新的增强bean, 方法入口: &lt;code&gt;org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#findEligibleAdvisors&lt;/code&gt;&lt;br&gt;详细步骤: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从Spring Context里找到所有Advisors: &lt;code&gt;org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#findCandidateAdvisors&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根据Advisors里的PointCuts&amp;#x2F;JoinPoints定义, 判断该bean是否可以被该Advisor增强. &lt;code&gt;org.springframework.aop.support.AopUtils#canApply(org.springframework.aop.Advisor, java.lang.Class&amp;lt;?&amp;gt;, boolean)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取到该bean可以被增强的advisors列表&lt;/li&gt;
&lt;li&gt;根据配置&lt;code&gt;spring.aop.proxy-target-class=true/false&lt;/code&gt;, 使用Cglib或者JDK生成代理bean. &lt;code&gt;org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;之后从Spring容器中获取bean(getBean或者通过@Autowired等自动注入), 实际上获取到的是代理bean.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-Transactional-的JoinPoint-x2F-PointCut定义&quot;&gt;&lt;a href=&quot;#1-Transactional-的JoinPoint-x2F-PointCut定义&quot; class=&quot;headerlink&quot; title=&quot;1. @Transactional 的JoinPoint&amp;#x2F;PointCut定义&quot;&gt;&lt;/a&gt;1. @Transactional 的JoinPoint&amp;#x2F;PointCut定义&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JoinPoint or PointCut, 在AOP里即是类似SQL中where的条件, 即哪些符合条件的class&amp;#x2F;bean&amp;#x2F;method需要被增强.&lt;/li&gt;
&lt;li&gt;JoinPoint标准接口定义如下: 核心是&lt;code&gt;matches&lt;/code&gt;方法.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;StaticMethodMatcher&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MethodMatcher&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&amp;#123;&lt;/span&gt;

	&lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Method&lt;/span&gt; method&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; targetClass&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;&amp;#123;&lt;/span&gt;
		&lt;span class=&quot;token comment&quot;&gt;// should never be invoked because isRuntime() returns false&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UnsupportedOperationException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Illegal MethodMatcher usage&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;&amp;#125;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;&amp;#125;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Transactional&lt;/code&gt; 使用的是: &lt;code&gt;org.springframework.transaction.interceptor.TransactionAttributeSourcePointcut&lt;/code&gt;, 而&lt;mark&gt;该pointcut, 会按照类继承关系向上寻找, 找到接口层面定义的annotation.&lt;/mark&gt; &lt;/li&gt;
&lt;li&gt;详细测试代码参见: &lt;a href=&quot;https://github.com/DavyJones2010/head-first-spring/blob/feature/20220603_annotation_on_interface/src/test/java/edu/xmu/kunlun/headfirst/spring/tx/aop/BeanFactoryTransactionAttributeSourceAdvisorTest.java&quot;&gt;edu.xmu.kunlun.headfirst.spring.tx.aop.BeanFactoryTransactionAttributeSourceAdvisorTest#matchesTest&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://davyjones2010.github.io/tags/java/"/>
    
    <category term="spring" scheme="https://davyjones2010.github.io/tags/spring/"/>
    
    <category term="spring-boot" scheme="https://davyjones2010.github.io/tags/spring-boot/"/>
    
    <category term="aop" scheme="https://davyjones2010.github.io/tags/aop/"/>
    
    <category term="interface" scheme="https://davyjones2010.github.io/tags/interface/"/>
    
    <category term="spring-tx" scheme="https://davyjones2010.github.io/tags/spring-tx/"/>
    
  </entry>
  
  <entry>
    <title>MySQL连接池重要参数配置原理研究</title>
    <link href="https://davyjones2010.github.io/2022-06-05-mysql-conn-params/"/>
    <id>https://davyjones2010.github.io/2022-06-05-mysql-conn-params/</id>
    <published>2022-06-05T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h1><ul><li>initialSize: 初始化时connection数量, 每个connection实际是一条与DB的TCP连接</li><li>maxActive: 最大连接池数量, 对应于maxPoolSize</li><li>minIdle: 最小连接池数量, 对应与minPoolSize</li><li>maxWait: 获取连接等待超时的时间, 具体详解参见: <a href="#maxwait%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3">maxWait参数详解</a></li><li>timeBetweenEvictionRunsMillis: 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</li><li>minEvictableIdleTimeMillis: 配置一个连接在池中最小生存的时间，单位是毫秒</li><li>maxEvictableIdleTimeMillis:  配置一个连接在池中最大生存的时间，单位是毫秒</li><li>maxPoolPreparedStatementPerConnectionSize: PS Cache.暂时不管</li></ul><h2 id="maxWait参数详解"><a href="#maxWait参数详解" class="headerlink" title="maxWait参数详解"></a>maxWait参数详解</h2><ul><li>参数释义: <a href="https://www.jianshu.com/p/1ff2bd62dd45">https://www.jianshu.com/p/1ff2bd62dd45</a></li></ul><ol><li>即客户端从连接池中获取connection的最大等待时长</li><li>如果不配置, 默认为-1, 即客户端会一直等待. 这样显然是不合适的.</li><li>client从连接池中获取connection等待超时, 错误信息如下:<pre class="line-numbers language-none"><code class="language-none">Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0    at com.alibaba.druid.pool.DruidDataSource.getConnectionInternal(DruidDataSource.java:1722)    at com.alibaba.druid.pool.DruidDataSource.getConnectionDirect(DruidDataSource.java:1402)    at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:5059)    at com.alibaba.druid.filter.logging.LogFilter.dataSource_getConnection(LogFilter.java:886)    at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:5055)    at com.alibaba.druid.filter.FilterAdapter.dataSource_getConnection(FilterAdapter.java:2756)    at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:5055)    at com.alibaba.druid.filter.stat.StatFilter.dataSource_getConnection(StatFilter.java:680)    at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:5055)    at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1380)    at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1372)    at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:109)    at org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:262)    ... 11 more<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ul><li>maxWait参数的坑: <a href="https://tech.youzan.com/shu-ju-ku-lian-jie-chi-pei-zhi/">https://tech.youzan.com/shu-ju-ku-lian-jie-chi-pei-zhi/</a></li><li>扩展阅读: Druid锁的公平模式, <a href="https://github.com/alibaba/druid/wiki/Druid%E9%94%81%E7%9A%84%E5%85%AC%E5%B9%B3%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98">https://github.com/alibaba/druid/wiki/Druid%E9%94%81%E7%9A%84%E5%85%AC%E5%B9%B3%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98</a></li></ul><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="项目1配置样例"><a href="#项目1配置样例" class="headerlink" title="项目1配置样例"></a>项目1配置样例</h2><ul><li>initialSize: 100</li><li>maxActive: 200</li><li>minIdle: 100</li><li>maxWait: 6000</li></ul><p>注意, 这个是单机的连接配置, 考虑到分布式环境:</p><ul><li>初始化情况下, db承受的连接数是 initialSize<em>nodeCount &#x3D; 100</em>81 &#x3D; 8100</li><li>压力最大情况下, db承受的连接数是 initialSize<em>nodeCount &#x3D; 200</em>81 &#x3D; 16200</li></ul><h2 id="项目2配置项"><a href="#项目2配置项" class="headerlink" title="项目2配置项"></a>项目2配置项</h2><ul><li>initialSize: 未配置</li><li>maxActive: 300</li><li>minIdle: 30</li><li>maxWait: 60000</li></ul><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol><li>当客户端并发度超过最大连接数时, 会怎样?<ol><li>连接池中连接数, 从min –&gt; max 的增长策略是怎样的?</li><li>当增长到max之后, 请求线程会等待maxWait, 如果还是获取不到, 则抛错.</li></ol></li><li>当MySQL服务端连接数超过机器能承受的最大连接数时, 会怎样?</li><li>MySQL服务端一般能支持的最大连接数是多少?<ol><li>取决于物理机&#x2F;虚拟机的配置.</li></ol></li><li>什么是MySQL的session? 与connection是啥关系?<ol><li><a href="https://www.zhihu.com/question/30325800">https://www.zhihu.com/question/30325800</a></li><li>和网站的一个session差不多吧，只不过session是把key放在cookie里面，数据库连接是把key放在客户端的library的内存里（比如.Net Sql Client)。对MS SQL来说，这个连接的协议叫TDS，底下可以走多种传输层协议，比如tcpip，也可以named pipe。而MySQL就又有自己的协议。</li><li>com.taobao.pamirs.transaction.TBConnection#queryDBSessionID 只有oracle有sessionId.</li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;重要参数&quot;&gt;&lt;a href=&quot;#重要参数&quot; class=&quot;headerlink&quot; title=&quot;重要参数&quot;&gt;&lt;/a&gt;重要参数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;initialSize: 初始化时connection数量, 每个connection实际是一条与DB的TCP连接&lt;/li&gt;
&lt;li&gt;maxActive: 最大连接池数量, 对应于maxPoolSize&lt;/li&gt;
&lt;li&gt;minIdle: 最小连接池数量, 对应与minPoolSize&lt;/li&gt;
&lt;li&gt;maxWait: 获取连接等待超时的时间, 具体详解参见: &lt;a href=&quot;#maxwait%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3&quot;&gt;maxWait参数详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;timeBetweenEvictionRunsMillis: 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒&lt;/li&gt;
&lt;li&gt;minEvictableIdleTimeMillis: 配置一个连接在池中最小生存的时间，单位是毫秒&lt;/li&gt;
&lt;li&gt;maxEvictableIdleTimeMillis:  配置一个连接在池中最大生存的时间，单位是毫秒&lt;/li&gt;
&lt;li&gt;maxPoolPreparedStatementPerConnectionSize: PS Cache.暂时不管&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;maxWait参数详解&quot;&gt;&lt;a href=&quot;#maxWait参数详解&quot; class=&quot;headerlink&quot; title=&quot;maxWait参数详解&quot;&gt;&lt;/a&gt;maxWait参数详解&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;参数释义: &lt;a href=&quot;https://www.jianshu.com/p/1ff2bd62dd45&quot;&gt;https://www.jianshu.com/p/1ff2bd62dd45&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;即客户端从连接池中获取connection的最大等待时长&lt;/li&gt;
&lt;li&gt;如果不配置, 默认为-1, 即客户端会一直等待. 这样显然是不合适的.&lt;/li&gt;
&lt;li&gt;client从连接池中获取connection等待超时, 错误信息如下:&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;Caused by: com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 3000, active 4, maxActive 4, creating 0
    at com.alibaba.druid.pool.DruidDataSource.getConnectionInternal(DruidDataSource.java:1722)
    at com.alibaba.druid.pool.DruidDataSource.getConnectionDirect(DruidDataSource.java:1402)
    at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:5059)
    at com.alibaba.druid.filter.logging.LogFilter.dataSource_getConnection(LogFilter.java:886)
    at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:5055)
    at com.alibaba.druid.filter.FilterAdapter.dataSource_getConnection(FilterAdapter.java:2756)
    at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:5055)
    at com.alibaba.druid.filter.stat.StatFilter.dataSource_getConnection(StatFilter.java:680)
    at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:5055)
    at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1380)
    at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1372)
    at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:109)
    at org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:262)
    ... 11 more&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;maxWait参数的坑: &lt;a href=&quot;https://tech.youzan.com/shu-ju-ku-lian-jie-chi-pei-zhi/&quot;&gt;https://tech.youzan.com/shu-ju-ku-lian-jie-chi-pei-zhi/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;扩展阅读: Druid锁的公平模式, &lt;a href=&quot;https://github.com/alibaba/druid/wiki/Druid%E9%94%81%E7%9A%84%E5%85%AC%E5%B9%B3%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98&quot;&gt;https://github.com/alibaba/druid/wiki/Druid%E9%94%81%E7%9A%84%E5%85%AC%E5%B9%B3%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;实战&quot;&gt;&lt;a href=&quot;#实战&quot; class=&quot;headerlink&quot; title=&quot;实战&quot;&gt;&lt;/a&gt;实战&lt;/h1&gt;&lt;h2 id=&quot;项目1配置样例&quot;&gt;&lt;a href=&quot;#项目1配置样例&quot; class=&quot;headerlink&quot; title=&quot;项目1配置样例&quot;&gt;&lt;/a&gt;项目1配置样例&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;initialSize: 100&lt;/li&gt;
&lt;li&gt;maxActive: 200&lt;/li&gt;
&lt;li&gt;minIdle: 100&lt;/li&gt;
&lt;li&gt;maxWait: 6000&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意, 这个是单机的连接配置, 考虑到分布式环境:&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://davyjones2010.github.io/tags/java/"/>
    
    <category term="mysql" scheme="https://davyjones2010.github.io/tags/mysql/"/>
    
    <category term="database" scheme="https://davyjones2010.github.io/tags/database/"/>
    
    <category term="connection-pool" scheme="https://davyjones2010.github.io/tags/connection-pool/"/>
    
    <category term="druid" scheme="https://davyjones2010.github.io/tags/druid/"/>
    
  </entry>
  
  <entry>
    <title>爱死机第三季观后感</title>
    <link href="https://davyjones2010.github.io/2022-06-04-love-death-robots/"/>
    <id>https://davyjones2010.github.io/2022-06-04-love-death-robots/</id>
    <published>2022-06-04T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.341Z</updated>
    
    <content type="html"><![CDATA[<p>在这个阴雨连绵的端午, Netflix的爱死机第三季, 如期而至, 惊喜万分.<br>不需要任何PPT大话, 这个NETFLIX的Logo在我心中就意味着 <mark>奈飞出品, 必属竞品</mark></p><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206051149708.png"></p><hr><p>第一集, 例行的机器人来到已经荒废的地球, 参观了各个阶层人群在末日时刻的,<br>例行地以局外人的角度幽默吐槽.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206051150581.png"><br><img data-src="https://s2.loli.net/2022/06/05/7g9AGjZH4t132ve.png" alt="1-1"><br><img data-src="https://s2.loli.net/2022/06/05/9XMwt2LFOshYeWp.png" alt="1-2"><br><img data-src="https://s2.loli.net/2022/06/05/wYeOh4a3FDqpIoE.png" alt="1-3"><br><img data-src="https://s2.loli.net/2022/06/05/QoUclBknD3W59wP.png" alt="1-4"><br><img data-src="https://s2.loli.net/2022/06/05/zp3IlVw6Ai79fYv.png" alt="1-5"></p><hr><p>最负盛誉的第九集, Jibaro</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在这个阴雨连绵的端午, Netflix的爱死机第三季, 如期而至, 惊喜万分.&lt;br&gt;不需要任何PPT大话, 这个NETFLIX的Logo在我心中就意味着 &lt;mark&gt;奈飞出品, 必属竞品&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206051149708.png&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;第一集, 例行的机器人来到已经荒废的地球, 参观了各个阶层人群在末日时刻的,&lt;br&gt;例行地以局外人的角度幽默吐槽.&lt;br&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206051150581.png&quot;&gt;&lt;br&gt;&lt;img data-src=&quot;https://s2.loli.net/2022/06/05/7g9AGjZH4t132ve.png&quot; alt=&quot;1-1&quot;&gt;&lt;br&gt;&lt;img data-src=&quot;https://s2.loli.net/2022/06/05/9XMwt2LFOshYeWp.png&quot; alt=&quot;1-2&quot;&gt;&lt;br&gt;&lt;img data-src=&quot;https://s2.loli.net/2022/06/05/wYeOh4a3FDqpIoE.png&quot; alt=&quot;1-3&quot;&gt;&lt;br&gt;&lt;img data-src=&quot;https://s2.loli.net/2022/06/05/QoUclBknD3W59wP.png&quot; alt=&quot;1-4&quot;&gt;&lt;br&gt;&lt;img data-src=&quot;https://s2.loli.net/2022/06/05/zp3IlVw6Ai79fYv.png&quot; alt=&quot;1-5&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最负盛誉的第九集, Jibaro&lt;/p&gt;
</summary>
    
    
    
    
    <category term="2022" scheme="https://davyjones2010.github.io/tags/2022/"/>
    
    <category term="movie" scheme="https://davyjones2010.github.io/tags/movie/"/>
    
    <category term="movie-list" scheme="https://davyjones2010.github.io/tags/movie-list/"/>
    
    <category term="love-death-robots" scheme="https://davyjones2010.github.io/tags/love-death-robots/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot基于Interface的Annotation在AOP中如何生效</title>
    <link href="https://davyjones2010.github.io/2022-06-02-spring-annotation-on-interface/"/>
    <id>https://davyjones2010.github.io/2022-06-02-spring-annotation-on-interface/</id>
    <published>2022-06-02T16:00:00.000Z</published>
    <updated>2022-08-07T10:51:31.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>SpringBoot项目代码里, 新增了一个 <code>@Perf</code> 的annotation, 希望增加该annotation的方法, 能自动打印出方法的执行耗时.<br>实际代码结构中, 使用了FilterChain模式, 会有多个Filter(例如10+个)实现同一个接口.<br>因此想着把 <code>@Perf</code> 打在接口层面, 希望所有实现类都能继承该annotation, 从而不用在每个子类的Filter方法里重复打上annotation.<br>但发现实际没有生效.</p><h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>在stackoverflow里, 类似的问题也是一堆,<br>总结下来原因是如下两个:  </p><ol><li>method 上的 annotation 没有被继承下来. 参见如下继承原则详解. </li><li>spring 在对类&#x2F;对象进行进行增强(weaving)时, 校验bean是否需要被增强 <code>@Around(&quot;@annotation(Perf)&quot;)</code>, 只会校验bean对应的class上的annotation, 而不会向上回溯父类&#x2F;接口上是否被打了该annotation.</li></ol><h2 id="1-Java-Annotation的继承原则"><a href="#1-Java-Annotation的继承原则" class="headerlink" title="1. Java Annotation的继承原则"></a>1. Java Annotation的继承原则</h2><h3 id="1-1-Annotation继承原则"><a href="#1-1-Annotation继承原则" class="headerlink" title="1.1 Annotation继承原则:"></a>1.1 Annotation继承原则:</h3><blockquote><p>Java中作用在方法层面的annotation不能被继承<br>Java中作用在interface层面的annotation不能被继承<br>Java中打在class层面的annotation默认不能被继承, 但如果annotation被打上@Inherited标签, 则可以被子类继承</p></blockquote><ul><li>原则参见: <a href="http://www.eclipse.org/aspectj/doc/released/adk15notebook/annotations.html#annotation-inheritance">annotation-inheritance</a></li><li>详细演示测试代码参见: <a href="https://github.com/DavyJones2010/head-first-spring/blob/feature/20220603_annotation_on_interface/src/test/java/edu/xmu/kunlun/headfirst/spring/annotation/AnnotationTest.java">edu.xmu.kunlun.headfirst.spring.annotation.AnnotationTest</a></li></ul><h3 id="1-2-为啥会有这种继承原则"><a href="#1-2-为啥会有这种继承原则" class="headerlink" title="1.2 为啥会有这种继承原则?"></a>1.2 为啥会有这种继承原则?</h3><p>上述原则看起来比较复杂, 且不可思议. 如果死记硬背, 效率太低. 需要从设计者角度来考虑下为啥不直接都能继承就好?<br>想清楚原因, 这些原则自然就明白了. 自己查询了stackoverflow, 根本原因是<font color='red'>为了避免歧义</font>. 详细场景分析如下: </p><ol><li><p>为啥作用在方法层面的annotation不能被继承?<br>因为java interface是多继承的<br>原因样例参见: <a href="https://github.com/DavyJones2010/head-first-spring/blob/feature/20220603_annotation_on_interface/src/main/java/edu/xmu/kunlun/headfirst/spring/annotation2/Sub2.java">edu.xmu.kunlun.headfirst.spring.annotation2.Sub2</a> </p></li><li><p>为啥作用在interface层面的annotation不能被继承?<br>因为java interface是多实现的.<br>如果class同时实现了多个interface, 每个interface都实现同一个annotation(但对应annotation的参数不同), 那么当前class使用的该是哪个annotation(with参数)?<br>这种场景下, 在OOP中术语叫做 <a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">diamond inheritance</a></p></li><li><p>为啥作用在class层面的annotation可以被继承?<br>因为java class是单继承的. 所以不会有interface的问题.</p></li></ol><h3 id="1-3-问题总结"><a href="#1-3-问题总结" class="headerlink" title="1.3 问题总结"></a>1.3 问题总结</h3><p>因此可以得知, Filter接口的 filter() 方法上的 annotation 没有被继承下来.</p><h2 id="2-Spring-AOP-增强原理与原则"><a href="#2-Spring-AOP-增强原理与原则" class="headerlink" title="2. Spring AOP 增强原理与原则"></a>2. Spring AOP 增强原理与原则</h2><h3 id="2-1-Spring-AOP-中几个重要概念"><a href="#2-1-Spring-AOP-中几个重要概念" class="headerlink" title="2.1 Spring AOP 中几个重要概念"></a>2.1 Spring AOP 中几个重要概念</h3><ul><li>AOP proxy: an object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy will be a JDK dynamic proxy or a CGLIB proxy.</li><li>Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.<br>所以, 最关键问题是由于 Spring Boot Weaving 时根据annotation没有weave上去, 而跟使用何种类型的 AOP Proxy 无关!</li></ul><h3 id="2-2-Spring-AOP-Weaving-核心代码"><a href="#2-2-Spring-AOP-Weaving-核心代码" class="headerlink" title="2.2 Spring AOP Weaving 核心代码"></a>2.2 Spring AOP Weaving 核心代码</h3><p>weaving的几种类型:</p><ul><li>compile time weaving: 在编译期生成增强类, 例如使用 AspectJ compiler  </li><li>run time (or load time) weaving: 在运行期, 实时地校验是否符合条件,</li></ul><h3 id="2-3-Spring-AOP-Weaving-核心逻辑"><a href="#2-3-Spring-AOP-Weaving-核心逻辑" class="headerlink" title="2.3 Spring AOP Weaving 核心逻辑"></a>2.3 Spring AOP Weaving 核心逻辑</h3><p>Spring AOP Weaving是load time weaving, 即在Spring容器构建完所有的bean之后, 完成容器启动前执行的, 使用的是aspectj weaver</p><ul><li><p>核心代码参见: <code>org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean</code></p></li><li><p>而针对该问题, 即判断该Aspect能否应用在该类型上, 核心逻辑如下:<br><code>org.springframework.aop.support.AopUtils#canApply(org.springframework.aop.Pointcut, java.lang.Class&lt;?&gt;, boolean)</code><br>即判断 <code>@Perf</code> 能否应用在 <code>edu.xmu.kunlun.headfirst.spring.service.impl.FilterA</code> 对象上:<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206051422714.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206051424707.png"></p></li><li><p>而看实际实现如下, 是直接根据targetClass来判断, 确实没有向上继续寻找父类&#x2F;接口层面是否有声明 <code>@Perf</code>, 因此返回是false:<br><code>org.springframework.aop.aspectj.AspectJExpressionPointcut#matches(java.lang.reflect.Method, java.lang.Class&lt;?&gt;, boolean)</code><br> <img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206051438400.png"></p></li><li><p>再来思考下, 为啥不向上继续寻找? 这个就又回到了 第一个问题, Java Annotation的继承原则; 如果向上寻找, 有可能在同一层次找到多个同样的annotation, 但with不同的参数. 在这种情况下, Spring根本就不知道该以哪个为准了! 如下述例子:</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Perf</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">boolean</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Perf</span><span class="token punctuation">(</span>print <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Filter</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Perf</span><span class="token punctuation">(</span>print <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AnotherFilter</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 如果Spring Weaving会向上(父类/接口)寻找, 那么到底以哪个为准? print=false or print=true??</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FilterA</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span><span class="token punctuation">,</span> <span class="token class-name">AnotherFilter</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>再回到最初的问题, 如何能解决该问题?</p><h2 id="方案1-打在子类方法上"><a href="#方案1-打在子类方法上" class="headerlink" title="方案1: 打在子类方法上"></a>方案1: 打在子类方法上</h2><p>将<code>@Perf</code>打在各个子类的实现里, 缺点是: 非常麻烦, 后续有其他子类, 都需要记得打上annotation.</p><h2 id="方案2-修改pointcut条件"><a href="#方案2-修改pointcut条件" class="headerlink" title="方案2: 修改pointcut条件"></a>方案2: 修改pointcut条件</h2><p>不使用annotation作为pointcut的匹配条件, 而采用如下表达式:<br><code>@Around(&quot;execution(public * edu.xmu.kunlun.headfirst.spring.service.Filter+.doFilter(..))&quot;)</code></p><ul><li>优点: <code>edu.xmu.kunlun.headfirst.spring.service.Filter</code>的所有子类的<code>doFilter</code>都会被自动增强.</li><li>缺点: 如果有其他接口例如<code>edu.xmu.kunlun.headfirst.spring.service.Weighter</code>的所有实现需要被增强, 则需要修改pointcut表达式, 不方便. </li><li><a href="https://github.com/DavyJones2010/head-first-spring/blob/feature/20220603_annotation_on_interface/src/main/java/edu/xmu/kunlun/headfirst/spring/aspect/PerfAspect2.java">代码样例 edu.xmu.kunlun.headfirst.spring.aspect.PerfAspect2</a></li></ul><h2 id="方案3-自定义实现pointcut"><a href="#方案3-自定义实现pointcut" class="headerlink" title="方案3: 自定义实现pointcut"></a>方案3: 自定义实现pointcut</h2><p>参照Spring Transactional能力, 自己实现新的Advisor, 其中最主要是修改pointcut</p><ul><li>第一步: 创建自定义pointcut: <a href="https://github.com/DavyJones2010/head-first-spring/blob/feature/20220603_annotation_on_interface/src/main/java/edu/xmu/kunlun/headfirst/spring/aspect2/PerfAdvisor.java">edu.xmu.kunlun.headfirst.spring.aspect2.PerfAdvisor#pointcut</a></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">StaticMethodMatcherPointcut</span> pointcut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticMethodMatcherPointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 直接使用spring工具包，来获取method上的注解（会找父类上的注解）</span>        <span class="token keyword">return</span> <span class="token class-name">AnnotatedElementUtils</span><span class="token punctuation">.</span><span class="token function">hasAnnotation</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> <span class="token class-name">Perf2</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第二步: 创建自定义advice: <a href="https://github.com/DavyJones2010/head-first-spring/blob/feature/20220603_annotation_on_interface/src/main/java/edu/xmu/kunlun/headfirst/spring/aspect2/PerfInterceptor.java">edu.xmu.kunlun.headfirst.spring.aspect2.PerfInterceptor</a></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PerfInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">MethodInvocation</span> invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> className <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">getThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> methodName <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>className <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> methodName <span class="token operator">+</span> <span class="token string">" start on PerfInterceptor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            o <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>className <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> methodName <span class="token operator">+</span> <span class="token string">" on PerfInterceptor"</span> <span class="token operator">+</span> <span class="token string">" finished cost: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> o<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第三步: 创建自定义advisor, 并且以bean形式暴露给Spring容器: <a href="https://github.com/DavyJones2010/head-first-spring/blob/feature/20220603_annotation_on_interface/src/main/java/edu/xmu/kunlun/headfirst/spring/aspect2/PerfAdvisor.java">edu.xmu.kunlun.headfirst.spring.aspect2.PerfAdvisor</a></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PerfAdvisor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractBeanFactoryPointcutAdvisor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">StaticMethodMatcherPointcut</span> pointcut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticMethodMatcherPointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 直接使用spring工具包，来获取method上的注解（会找父类上的注解）</span>            <span class="token keyword">return</span> <span class="token class-name">AnnotatedElementUtils</span><span class="token punctuation">.</span><span class="token function">hasAnnotation</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> <span class="token class-name">Perf2</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Advice</span> advice <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerfInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Pointcut</span> <span class="token function">getPointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> pointcut<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Advice</span> <span class="token function">getAdvice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> advice<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第四步: 测试: <a href="https://github.com/DavyJones2010/head-first-spring/blob/feature/20220603_annotation_on_interface/src/test/java/edu/xmu/kunlun/headfirst/spring/aspect2/Perf2Test.java">edu.xmu.kunlun.headfirst.spring.aspect2.Perf2Test</a></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Perf2Test</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token class-name">FilterChain</span> chain<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        chain<span class="token punctuation">.</span><span class="token function">filterAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案:"></a>最终方案:</h2><p>如上分析Spring AOP相关源码</p><ul><li><code>方案3: 自定义实现pointcut</code> 虽然可以满足要求, 但存在两个问题: <ul><li>性能问题: 核心使用的<code>AnnotatedElementUtils.hasAnnotation(method, Perf2.class);</code>, 性能可能不佳</li><li>逻辑问题: 针对<code>Diamond Inheritance</code>场景, 结果会很奇怪, 不符合预期</li></ul></li><li>这也是避免后续踩坑的最佳实践了. </li><li>个人使用 <code>方案1</code> 作为了最终方案.</li></ul><h1 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h1><h2 id="Spring接口层面支持的-Transactional-annotation"><a href="#Spring接口层面支持的-Transactional-annotation" class="headerlink" title="Spring接口层面支持的 @Transactional annotation"></a>Spring接口层面支持的 @Transactional annotation</h2><p>如<a href="https://cloud.tencent.com/developer/article/1832305">接口上注解 AOP 拦截不到场景兼容实例演示</a> 文中所言:<br>Spring本身支持的 <code>@Transactional</code> annotation, 是可以打在interface上, 然后子类就自动实现了transaction相关增强的功能.<br>那么Spring具体是怎么实现的呢?</p><ul><li>Spring官方的解答如下:</li></ul><blockquote><p>The Spring team recommends that you annotate only concrete classes (and methods of concrete classes) with the @Transactional annotation, as opposed to annotating interfaces.<br>You certainly can place the @Transactional annotation on an interface (or an interface method),<br>but this works only as you would expect it to if you use interface-based proxies.<br>The fact that Java annotations are not inherited from interfaces means that,<br>if you use class-based proxies (proxy-target-class&#x3D;”true”) or the weaving-based aspect (mode&#x3D;”aspectj”),<br>the transaction settings are not recognized by the proxying and weaving infrastructure,<br>and the object is not wrapped in a transactional proxy.</p></blockquote><p>实际上, 也引发了很多讨论: </p><ul><li><a href="https://stackoverflow.com/questions/3120143/where-should-i-put-transactional-annotation-at-an-interface-definition-or-at-a">Where should I put @Transactional annotation: at an interface definition or at an implementing class?</a></li><li>文中推荐或者说Spring团队推荐 <code>@Transactional</code> 最好要打在<code>concrete classes</code>上, 而不要打在interface上.</li><li>因为 <mark><font color='red'>如果使用的如果不是JDK Based Proxy(or interface-based proxy), 则该annotation是不生效的!!!</font></mark></li><li>所以<mark>如果要用在interface上, 一定要知道当前使用的proxy是哪种.</mark> </li><li>而在实际上, 本身Spring&#x2F;SpringBoot的默认proxy方式一直在变, 我们很难弄明确清楚(或者要弄清楚需要费很大劲儿). 下文会详细说明.</li></ul><h2 id="SpringBoot中默认代理方式"><a href="#SpringBoot中默认代理方式" class="headerlink" title="SpringBoot中默认代理方式"></a>SpringBoot中默认代理方式</h2><p>根据 <a href="https://www.springcloud.io/post/2022-01/springboot-aop/#gsc.tab=0">AOP in Spring Boot, is it a JDK dynamic proxy or a Cglib dynamic proxy?</a> 文中说明,<br>Spring默认的AOP Proxy与SpringBoot默认的是有区别的 </p><h3 id="Spring默认AOP-Proxy"><a href="#Spring默认AOP-Proxy" class="headerlink" title="Spring默认AOP Proxy"></a>Spring默认AOP Proxy</h3><ul><li>If the proxy object implements the interface, then use the JDK dynamic proxy, otherwise it is the Cglib dynamic proxy.</li><li>If the proxy object does not implement an interface, then it is a direct Cglib dynamic proxy.</li></ul><h3 id="SpringBoot默认AOP-Proxy"><a href="#SpringBoot默认AOP-Proxy" class="headerlink" title="SpringBoot默认AOP Proxy"></a>SpringBoot默认AOP Proxy</h3><p>又根据SpringBoot 1.0 与 SpringBoot 2.0 版本有所区分: </p><ul><li><p>SpringBoot 1.0 AOP Proxy原则: 默认用 JDK proxy</p><blockquote><p>If the developer has set spring.aop.proxy-target-class to false, then the JDK proxy is used.<br>If the developer has spring.aop.proxy-target-class set to true, then the Cglib proxy is used.<br>If the developer did not configure the spring.aop.proxy-target-class property in the first place, then the JDK proxy is used.</p></blockquote></li><li><p>SpringBoot 2.0 AOP Proxy原则: 默认用 Cglib</p><blockquote><p>If the developer has set spring.aop.proxy-target-class to false, then the JDK proxy is used.<br>If the developer has spring.aop.proxy-target-class set to true, then the Cglib proxy is used.<br>If the developer did not configure the spring.aop.proxy-target-class property in the first place, then the Cglib proxy is used.</p></blockquote></li></ul><h3 id="其他好玩儿的"><a href="#其他好玩儿的" class="headerlink" title="其他好玩儿的"></a>其他好玩儿的</h3><ul><li>之前线上也有过一次故障, 如下<code>nestedHystrixWrappedGetCurrentThreadId</code>方法调用, 调用到的 <code>hystrixWrappedGetCurrentThreadId</code> 则实际没有被增强.</li><li>是因为调用 <code>hystrixWrappedGetCurrentThreadId</code> 实际是由 被代理对象(target) 调用的, 而不是由 代理对象(proxy) 调用的. 具体样例参见: <a href="https://github.com/DavyJones2010/head-first-spring/blob/feature/20220603_annotation_on_interface/src/test/java/edu/xmu/kunlun/headfirst/spring/service/impl/UserSvcTest.java">edu.xmu.kunlun.headfirst.spring.service.impl.UserSvcTest</a></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@HystrixWrapper</span><span class="token punctuation">(</span>commandGroupKey <span class="token operator">=</span> <span class="token string">"blog"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">hystrixWrappedGetCurrentThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">getCurrentThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">nestedHystrixWrappedGetCurrentThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">hystrixWrappedGetCurrentThreadId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li><code>@Transactional</code> <mark>不要打在接口上, 一定要打在实现类上!!</mark></li><li>显式声明<code>spring.aop.proxy-target-class=true</code>, <mark>让Spring&#x2F;SpringBoot项目统一都用cglib作为proxy方式. </mark> <code>As a reminder, to always use CGLIB, just set the “spring.aop.proxy-target-class” property to true.</code></li></ul><blockquote><p>Before using CGLIB,<br>ensure your codebase always uses pre-existing AOP annotations (such as @Transactional) on concrete classes<br>instead of only on interfaces.<br>Interface-only AOP annotations will be ignored when CGLIB is enabled.<br>Changing when @Transactional aspects are triggered could lead to items not being saved to the database,<br>or poor performance due to transactional boundary shifting.</p></blockquote><h1 id="Code-Samples"><a href="#Code-Samples" class="headerlink" title="Code Samples"></a>Code Samples</h1><ul><li>后续尽量会在每个知识点里, 都增加对应的完整可运行的code sample, 便于各位学习研究.</li><li>随着该问题的深入研究, 搞明白了asm, cglib, jdk dynamic proxy, aspectj等的关系, 愈发觉得还是得多搜索英文资料.</li><li><a href="https://github.com/DavyJones2010/head-first-spring/tree/feature/20220603_annotation_on_interface">本篇博文里完整的spring aop code sample</a></li></ul><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul><li><a href="https://www.credera.com/insights/aspect-oriented-programming-in-spring-boot-part-2-spring-jdk-proxies-vs-cglib-vs-aspectj">Aspect-Oriented Programming in Spring Boot Part 2: Spring JDK Proxies vs CGLIB vs AspectJ</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;SpringBoot项目代码里, 新增了一个 &lt;code&gt;@Perf&lt;/code&gt; 的annotation, 希望增加该annotation的方法, 能自动打印出方法的执行耗时.&lt;br&gt;实际代码结构中, 使用了FilterChain模式, 会有多个Filter(例如10+个)实现同一个接口.&lt;br&gt;因此想着把 &lt;code&gt;@Perf&lt;/code&gt; 打在接口层面, 希望所有实现类都能继承该annotation, 从而不用在每个子类的Filter方法里重复打上annotation.&lt;br&gt;但发现实际没有生效.&lt;/p&gt;
&lt;h1 id=&quot;原因分析&quot;&gt;&lt;a href=&quot;#原因分析&quot; class=&quot;headerlink&quot; title=&quot;原因分析&quot;&gt;&lt;/a&gt;原因分析&lt;/h1&gt;&lt;p&gt;在stackoverflow里, 类似的问题也是一堆,&lt;br&gt;总结下来原因是如下两个:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;method 上的 annotation 没有被继承下来. 参见如下继承原则详解. &lt;/li&gt;
&lt;li&gt;spring 在对类&amp;#x2F;对象进行进行增强(weaving)时, 校验bean是否需要被增强 &lt;code&gt;@Around(&amp;quot;@annotation(Perf)&amp;quot;)&lt;/code&gt;, 只会校验bean对应的class上的annotation, 而不会向上回溯父类&amp;#x2F;接口上是否被打了该annotation.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-Java-Annotation的继承原则&quot;&gt;&lt;a href=&quot;#1-Java-Annotation的继承原则&quot; class=&quot;headerlink&quot; title=&quot;1. Java Annotation的继承原则&quot;&gt;&lt;/a&gt;1. Java Annotation的继承原则&lt;/h2&gt;&lt;h3 id=&quot;1-1-Annotation继承原则&quot;&gt;&lt;a href=&quot;#1-1-Annotation继承原则&quot; class=&quot;headerlink&quot; title=&quot;1.1 Annotation继承原则:&quot;&gt;&lt;/a&gt;1.1 Annotation继承原则:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Java中作用在方法层面的annotation不能被继承&lt;br&gt;Java中作用在interface层面的annotation不能被继承&lt;br&gt;Java中打在class层面的annotation默认不能被继承, 但如果annotation被打上@Inherited标签, 则可以被子类继承&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原则参见: &lt;a href=&quot;http://www.eclipse.org/aspectj/doc/released/adk15notebook/annotations.html#annotation-inheritance&quot;&gt;annotation-inheritance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;详细演示测试代码参见: &lt;a href=&quot;https://github.com/DavyJones2010/head-first-spring/blob/feature/20220603_annotation_on_interface/src/test/java/edu/xmu/kunlun/headfirst/spring/annotation/AnnotationTest.java&quot;&gt;edu.xmu.kunlun.headfirst.spring.annotation.AnnotationTest&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-为啥会有这种继承原则&quot;&gt;&lt;a href=&quot;#1-2-为啥会有这种继承原则&quot; class=&quot;headerlink&quot; title=&quot;1.2 为啥会有这种继承原则?&quot;&gt;&lt;/a&gt;1.2 为啥会有这种继承原则?&lt;/h3&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://davyjones2010.github.io/tags/java/"/>
    
    <category term="spring" scheme="https://davyjones2010.github.io/tags/spring/"/>
    
    <category term="spring-boot" scheme="https://davyjones2010.github.io/tags/spring-boot/"/>
    
    <category term="aop" scheme="https://davyjones2010.github.io/tags/aop/"/>
    
    <category term="interface" scheme="https://davyjones2010.github.io/tags/interface/"/>
    
  </entry>
  
</feed>
