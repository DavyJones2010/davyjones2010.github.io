<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coders@Work</title>
  
  
  <link href="https://davyjones2010.github.io/atom.xml" rel="self"/>
  
  <link href="https://davyjones2010.github.io/"/>
  <updated>2022-11-02T14:44:57.609Z</updated>
  <id>https://davyjones2010.github.io/</id>
  
  <author>
    <name>Davy Walker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>K8s部署使用错误排查</title>
    <link href="https://davyjones2010.github.io/2022-11-01-k8s-trouble-shooting/"/>
    <id>https://davyjones2010.github.io/2022-11-01-k8s-trouble-shooting/</id>
    <published>2022-11-01T13:45:41.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/docker/for-mac/issues/1317">https://github.com/docker/for-mac/issues/1317</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Normal   Pulling    8s               kubelet            Pulling image <span class="token string">"docker.io/nginx:1.23"</span>Warning  Failed     8s               kubelet            Failed to pull image <span class="token string">"docker.io/nginx:1.23"</span><span class="token builtin class-name">:</span> rpc error: code <span class="token operator">=</span> Unknown desc <span class="token operator">=</span> Error response from daemon: Get <span class="token string">"https://registry-1.docker.io/v2/"</span><span class="token builtin class-name">:</span> dial tcp: lookup registry-1.docker.io on <span class="token number">192.168</span>.64.1:53: server misbehavingWarning  Failed     8s               kubelet            Error: ErrImagePullNormal   BackOff    6s <span class="token punctuation">(</span>x2 over 7s<span class="token punctuation">)</span>  kubelet            Back-off pulling image <span class="token string">"docker.io/nginx:1.23"</span>Warning  Failed     6s <span class="token punctuation">(</span>x2 over 7s<span class="token punctuation">)</span>  kubelet            Error: ImagePullBackOff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/docker/for-mac/issues/1317&quot;&gt;https://github.com/docker/for-mac/issues/1317&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;Normal   Pulling    8s               kubelet            Pulling image &lt;span class=&quot;token string&quot;&gt;&quot;docker.io/nginx:1.23&quot;&lt;/span&gt;
Warning  Failed     8s               kubelet            Failed to pull image &lt;span class=&quot;token string&quot;&gt;&quot;docker.io/nginx:1.23&quot;&lt;/span&gt;&lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt; rpc error: code &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Unknown desc &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Error response from daemon: Get &lt;span class=&quot;token string&quot;&gt;&quot;https://registry-1.docker.io/v2/&quot;&lt;/span&gt;&lt;span class=&quot;token builtin class-name&quot;&gt;:&lt;/span&gt; dial tcp: lookup registry-1.docker.io on &lt;span class=&quot;token number&quot;&gt;192.168&lt;/span&gt;.64.1:53: server misbehaving
Warning  Failed     8s               kubelet            Error: ErrImagePull
Normal   BackOff    6s &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x2 over 7s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;  kubelet            Back-off pulling image &lt;span class=&quot;token string&quot;&gt;&quot;docker.io/nginx:1.23&quot;&lt;/span&gt;
Warning  Failed     6s &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x2 over 7s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;  kubelet            Error: ImagePullBackOff&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;




</summary>
    
    
    
    
    <category term="k8s" scheme="https://davyjones2010.github.io/tags/k8s/"/>
    
    <category term="kubectl" scheme="https://davyjones2010.github.io/tags/kubectl/"/>
    
    <category term="trouble-shooting" scheme="https://davyjones2010.github.io/tags/trouble-shooting/"/>
    
  </entry>
  
  <entry>
    <title>十万个为什么之--为什么磁盘需要分区与挂载?</title>
    <link href="https://davyjones2010.github.io/2022-08-30-disk-partition/"/>
    <id>https://davyjones2010.github.io/2022-08-30-disk-partition/</id>
    <published>2022-08-30T03:41:13.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>经常会有个疑问</p><ul><li>为什么磁盘需要进行分区, 不分区直接按照文件夹划分有啥问题? 这个在Windows下尤其有疑问.</li><li>为啥需要挂载? 直接插入设备, 为啥不能像Windows下U盘一样直接热插拔? Linux下为啥还需要手动挂载下?</li></ul><h1 id="为啥需要分区"><a href="#为啥需要分区" class="headerlink" title="为啥需要分区?"></a>为啥需要分区?</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>习惯了使用Linux&#x2F;Mac之后, 完全没有分区的概念了.</p><ul><li>Linux&#x2F;Ubuntu装机步骤:<ul><li>一整块磁盘, 选定文件系统类型, 进行格式化.</li><li>直接在磁盘上安装操作系统, 就可以开始使用了.</li></ul></li><li>Mac甚至无需装机, 开机直接使用.</li></ul><p>实际使用过程中, 不分区有如下优势:</p><ul><li>软件安装: 无需关注需要把软件安装在哪个盘(C盘&#x2F;D盘&#x2F;E盘…), 通常只需要默认路径就好;</li><li>文件下载存储: 无需关注文件要保存在哪个盘, 只需要关注保存在哪个目录即可.</li></ul><blockquote><p>因此完全不用担心到底分几个区, 每个分区大小多少, C盘满了如何扩容之类的问题.</p></blockquote><p>因此, 在攒了台Windows机器之后, 犹豫要不要分多个区. 后来事实教会了我怎么做人.</p><blockquote><p>Win10很无节操地会在C盘预留30GB+的空间, 还要放虚拟内存文件等, 导致可怜的C盘立刻存储报警.</p></blockquote><h2 id="个人实践理解"><a href="#个人实践理解" class="headerlink" title="个人实践理解"></a>个人实践理解</h2><p>个人使用下来, 唯一的理由就是: <strong>分区隔离, 方便无损重装系统.</strong></p><p>Mac&#x2F;Linux上, 几乎无需也没有重装过系统. 但<strong>在Windows下, 重装系统简直是常态</strong>. </p><blockquote><p>垃圾(病毒)软件太多, 连所谓的纯净镜像也根本不纯净.</p></blockquote><ul><li>都想往注册表里偷偷塞东西. 清理注册表, 一不小心就会把系统清理蓝屏.</li><li>或者有病毒, 直接系统崩溃.</li></ul><blockquote><p>解决方案</p></blockquote><ul><li>要么通过PE进入系统, 找到问题点, 进行修复. </li><li>要么直接重装系统. </li><li>找到问题点太麻烦, 所以还是无脑一键重装吧.</li></ul><p>但重装系统, 就需要把分区重新格式化. 想想吧, 辛苦安装的软件, 设定的配置, 保存的文件, 都会随着格式化被完全抹除!<br>所以还是分区吧, 只格式化C盘就好. 软件啊, 文件啊, 配置啊, 都放到其他盘里好了.</p><h2 id="其他专业理由"><a href="#其他专业理由" class="headerlink" title="其他专业理由"></a>其他专业理由</h2><p>参照知乎 <a href="https://www.zhihu.com/question/47538075/answer/107737383">其实windows分区是不是分C盘和D盘就好了？</a> 回答.</p><ul><li>病毒泛滥, 会把系统搞Crash, 需要频繁重装系统.</li><li>早期的FAT16&#x2F;32文件系统支持的单个分区容量有限. FAT32最大文件系统总容量 128GB, 在现在随便一个硬盘就是1TB+, 无法充分利用磁盘空间.</li><li>xp之前的windows系列操作系统本身稳定性堪忧，很容易因为用户操作、软件故障崩溃甚至破坏。尤其是经常折腾的桌面系统。这就导致用户不得不频繁重装系统。</li><li>操作系统权限&amp;软件兼容问题: 现在win10管理员权限小了，某些软件装在C盘会有权限问题，比如notepad++装在C盘，直接运行的话是不能保存自定义配置的</li></ul><blockquote><p>所以在Windows下, 还是老老实实分区吧! 当然在严肃的企业场景, 也推荐按照系统盘与数据盘进行下区分.</p></blockquote><h1 id="为啥需要挂载"><a href="#为啥需要挂载" class="headerlink" title="为啥需要挂载?"></a>为啥需要挂载?</h1><h1 id="磁盘-amp-文件系统的扩展知识"><a href="#磁盘-amp-文件系统的扩展知识" class="headerlink" title="磁盘&amp;文件系统的扩展知识"></a>磁盘&amp;文件系统的扩展知识</h1><h2 id="磁盘-分区-文件系统-关系"><a href="#磁盘-分区-文件系统-关系" class="headerlink" title="磁盘, 分区, 文件系统 关系"></a>磁盘, 分区, 文件系统 关系</h2><p>如下: </p><pre class="mermaid">erDiagram    DiskDevice ||--|{ Partition : contain    Partition ||--|| FileSystem : format</pre><h3 id="磁盘-x2F-块设备-gt-分区"><a href="#磁盘-x2F-块设备-gt-分区" class="headerlink" title="磁盘&#x2F;块设备 -&gt; 分区"></a>磁盘&#x2F;块设备 -&gt; 分区</h3><p>一个磁盘设备(HDD, SSD, U盘等), 可以划分为多个分区. 分区方式有MBR, GPT两种.<br>那么磁盘分区的元信息写在哪里? </p><ul><li>是存储在文件系统中么? 此时磁盘还没有文件系统, 所以应该不是以文件形式保存, 所以我们也就无法直接在操作系统里找到这个文件并操作.</li><li>是存储在裸设备的固定位置(它在硬盘上的三维地址为（柱面，磁头，扇区）＝（0，0，1）。)</li><li>通过 <code>lsblk</code> 命令查看已经挂载的块设备<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@662fd3213ce8:/data<span class="token comment"># lsblk</span>NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTvda    <span class="token number">254</span>:0    <span class="token number">0</span> <span class="token number">59</span>.6G  <span class="token number">0</span> disk`-vda1 <span class="token number">254</span>:1    <span class="token number">0</span> <span class="token number">59</span>.6G  <span class="token number">0</span> part /etc/hosts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="分区-gt-文件系统"><a href="#分区-gt-文件系统" class="headerlink" title="分区 -&gt; 文件系统"></a>分区 -&gt; 文件系统</h3><p>一个分区对应一个文件系统. 因此同一个磁盘设备的多个分区, 各个分区都可以格式化成不同的文件系统类型.</p><ul><li>通过 <code>df -h</code> 命令查看分区<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@662fd3213ce8:/data<span class="token comment"># df -h</span>Filesystem      Size  Used Avail Use% Mounted onoverlay          59G  <span class="token number">2</span>.7G   53G   <span class="token number">5</span>% /tmpfs            64M     <span class="token number">0</span>   64M   <span class="token number">0</span>% /devshm              64M     <span class="token number">0</span>   64M   <span class="token number">0</span>% /dev/shm/dev/vda1        59G  <span class="token number">2</span>.7G   53G   <span class="token number">5</span>% /datatmpfs           <span class="token number">3</span>.9G     <span class="token number">0</span>  <span class="token number">3</span>.9G   <span class="token number">0</span>% /proc/acpitmpfs           <span class="token number">3</span>.9G     <span class="token number">0</span>  <span class="token number">3</span>.9G   <span class="token number">0</span>% /sys/firmware<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="文件系统类型描述元数据"><a href="#文件系统类型描述元数据" class="headerlink" title="文件系统类型描述元数据"></a>文件系统类型描述元数据</h3><div class="note warning"><p>TODO: 暂时还没搜索到相关信息.</p></div><h3 id="文件系统内部目录-amp-文件元数据"><a href="#文件系统内部目录-amp-文件元数据" class="headerlink" title="文件系统内部目录&amp;文件元数据:"></a>文件系统内部目录&amp;文件元数据:</h3><ul><li>例如ext4, 以inode形式保存. 包括文件大小, 权限信息, gmtCreated, gmtModified, 包含的block数量, 存储在磁盘的位置(柱面) 等</li><li>可以使用 stat 命令查看</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@662fd3213ce8:/data<span class="token comment"># stat dump.rdb</span>  File: dump.rdb  Size: <span class="token number">105</span>       Blocks: <span class="token number">8</span>          IO Block: <span class="token number">4096</span>   regular <span class="token function">file</span>Device: fe01h/65025dInode: <span class="token number">1055693</span>     Links: <span class="token number">1</span>Access: <span class="token punctuation">(</span>0600/-rw-------<span class="token punctuation">)</span>  Uid: <span class="token punctuation">(</span>  <span class="token number">999</span>/   redis<span class="token punctuation">)</span>   Gid: <span class="token punctuation">(</span>  <span class="token number">999</span>/   redis<span class="token punctuation">)</span>Access: <span class="token number">2022</span>-10-12 <span class="token number">16</span>:01:07.043330092 +0000Modify: <span class="token number">2022</span>-06-26 <span class="token number">10</span>:16:40.880774990 +0000Change: <span class="token number">2022</span>-06-26 <span class="token number">10</span>:16:40.896774990 +0000 Birth: <span class="token number">2022</span>-06-26 <span class="token number">10</span>:16:40.869774990 +0000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="note warning"><p>TODO: 分析下stat的具体信息含义, 尤其是 Device 相关的, 是不是操作系统直接就按照这个信息去寻找到文件的柱面范围了?</p></div><h3 id="分区名称规范"><a href="#分区名称规范" class="headerlink" title="分区名称规范"></a>分区名称规范</h3><ul><li>在Linux系统中，硬盘分区命名为sda1－sda4或者hda1－hda4</li></ul><div class="note warning"><p>TODO: 自己找个U盘试下划分成多个分区, 每个分区不同的文件系统类型?</p></div><h2 id="为啥磁盘需要挂载才能使用"><a href="#为啥磁盘需要挂载才能使用" class="headerlink" title="为啥磁盘需要挂载才能使用?"></a>为啥磁盘需要挂载才能使用?</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;经常会有个疑问&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么磁盘需要进行分区, 不分区直接按照文件夹划分有啥问题? 这个在Windows下尤其有疑问.&lt;/li&gt;
&lt;li&gt;为啥需要挂载? 直接插入设备, 为啥不能像Windows下U盘一样直接热插拔? Linux下为啥还需要手动挂载下?&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;为啥需要分区&quot;&gt;&lt;a href=&quot;#为啥需要分区&quot; class=&quot;headerlink&quot; title=&quot;为啥需要分区?&quot;&gt;&lt;/a&gt;为啥需要分区?&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;习惯了使用Linux&amp;#x2F;Mac之后, 完全没有分区的概念了.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux&amp;#x2F;Ubuntu装机步骤:&lt;ul&gt;
&lt;li&gt;一整块磁盘, 选定文件系统类型, 进行格式化.&lt;/li&gt;
&lt;li&gt;直接在磁盘上安装操作系统, 就可以开始使用了.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Mac甚至无需装机, 开机直接使用.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际使用过程中, 不分区有如下优势:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件安装: 无需关注需要把软件安装在哪个盘(C盘&amp;#x2F;D盘&amp;#x2F;E盘…), 通常只需要默认路径就好;&lt;/li&gt;
&lt;li&gt;文件下载存储: 无需关注文件要保存在哪个盘, 只需要关注保存在哪个目录即可.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;因此完全不用担心到底分几个区, 每个分区大小多少, C盘满了如何扩容之类的问题.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="十万个为什么" scheme="https://davyjones2010.github.io/categories/%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="linux" scheme="https://davyjones2010.github.io/tags/linux/"/>
    
    <category term="disk" scheme="https://davyjones2010.github.io/tags/disk/"/>
    
    <category term="os" scheme="https://davyjones2010.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>瞎折腾洋垃圾电脑笔记</title>
    <link href="https://davyjones2010.github.io/2022-08-13-computer-diy/"/>
    <id>https://davyjones2010.github.io/2022-08-13-computer-diy/</id>
    <published>2022-08-13T13:39:48.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾佬的周末, 没事儿就是瞎折腾, 自从在B站被种草了洋垃圾, 按耐不住心中的冲动, 决定也用洋垃圾组装一台能数框框的电脑, 玩玩儿游戏, 压榨压榨性能.</p><h1 id="为啥要使用洋垃圾"><a href="#为啥要使用洋垃圾" class="headerlink" title="为啥要使用洋垃圾"></a>为啥要使用洋垃圾</h1><ul><li>一: 穷, </li><li>二: 玩,</li></ul><h1 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h1><blockquote><p>几乎都是从海鲜市场淘来的</p><ul><li>优点是便宜, 性价比高; </li><li>缺点是电气特性衰减不明确, 长期稳定性没有保障.</li></ul></blockquote><p>但对于偶尔玩一玩游戏, 不是长期高负荷跑渲染等, 整体还OK. 目标是<strong>1000元</strong>左右搞定.</p><h2 id="详细清单"><a href="#详细清单" class="headerlink" title="详细清单"></a>详细清单</h2><table><thead><tr><th>配件名称</th><th>品牌</th><th>数量</th><th>价格</th><th>详细说明</th></tr></thead><tbody><tr><td>CPU</td><td><a href="https://ark.intel.com/content/www/us/en/ark/products/83357/intel-xeon-processor-e52630l-v3-20m-cache-1-80-ghz.html">Intel® Xeon® Processor E5-2630L v3</a></td><td>1</td><td>80</td><td>Haswell; 8Core 16HT; 22 nm制程; Base 1.8GHz, Burst 2.90 GHz; 20MB L3 Cache; 55W TDP</td></tr><tr><td>主板</td><td><a href="https://item.taobao.com/item.htm?id=676047268901">X99寨板</a></td><td>1</td><td>250</td><td></td></tr><tr><td>内存</td><td>威刚万紫千红</td><td>4</td><td>160 + 200</td><td>8GB; DDR4 2133MHz; 强迫症4条必须插满, 组成4通道^_^</td></tr><tr><td>闪存</td><td><a href="https://www.intel.com/content/www/us/en/products/sku/134583/intel-ssd-760p-series-256gb-m-2-80mm-pcie-3-1-x4-3d2-tlc/specifications.html">Intel® SSD 760P</a></td><td>1</td><td>160</td><td>256GB; PCIe 3.1 x4 接口, NVMe</td></tr><tr><td>显卡</td><td>蓝宝石RX460</td><td>1</td><td>350</td><td>4GB显存; 无需单独供电; HDMI + VGA + DP 接口</td></tr><tr><td>电源</td><td>鑫谷全模组</td><td>1</td><td>120</td><td>550W, 整体绰绰有余了</td></tr><tr><td>CPU散热器</td><td>长城霄龙400</td><td>1</td><td>45</td><td>4铜管, 3针脚</td></tr><tr><td>机箱</td><td>待挑选</td><td>1</td><td>??</td><td>??</td></tr></tbody></table><p>合计 <code>80 + 250 + 160 + 200 + 160 + 350 + 120 + 45 = 1,365</code><br>现在显卡电源都还没到, 希望组装上去之后一次点亮, 就可以说声”真香!”啦.</p><h2 id="主板细节"><a href="#主板细节" class="headerlink" title="主板细节"></a>主板细节</h2><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208132325729.png"></p><div class="note info"><p>x99含义<br>所谓的x99主板, 代表的其实是<code>Intel X99 chipset</code>, 是Intel的PCH(Platform Controller Hub)即南桥芯片, 定义了主板的规范, 如下:<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208140001662.png"></p></div><p>其他细节: </p><ul><li>CPU插槽: 单路; LGA2011, 因此是2011个针脚;</li><li>CPU只支持DDR4内存, 但主板支持DDR3(问了店家, 主板同时也支持DDR4), 现在DDR4普遍价格比较贵, 没办法使用闲鱼上价格巨便宜的DDR3 ECC内存.</li><li></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="CPU型号"><a href="#CPU型号" class="headerlink" title="CPU型号"></a>CPU型号</h3><p>买的时候没有看清楚CPU型号, 以为是 <code>E5-2630 V3</code>, 结果实际是 <code>E5-2630L V3</code>, 才知道多了的这个<code>L</code>代表<mark>低功耗(Low Power)</mark>, 基频只有<code>1.8GHz</code>不能忍.<br>因此就又淘了如下两个能够适配X99主板的CPU, 准备到时候各自对比测试下:</p><table><thead><tr><th>配件名称</th><th>品牌</th><th>数量</th><th>价格</th><th>详细说明</th></tr></thead><tbody><tr><td>CPU</td><td><a href="https://ark.intel.com/content/www/us/en/ark/products/83357/intel-xeon-processor-e52630l-v3-20m-cache-1-80-ghz.html">Intel® Xeon® Processor E5-2630L v3</a></td><td>1</td><td>80</td><td>8Core 16HT; 22 nm制程; Base 1.8GHz, Burst 2.90 GHz; 20MB L3 Cache; 55W TDP</td></tr><tr><td>CPU</td><td><a href="https://ark.intel.com/content/www/us/en/ark/products/81706/intel-xeon-processor-e52660-v3-25m-cache-2-60-ghz.html">Intel® Xeon® Processor E5-2660 v3</a></td><td>1</td><td>100</td><td>10Core 20HT; 22 nm制程; Base 2.60 GHz, Burst 3.3 GHz; 25MB L3 Cache; 105W TDP</td></tr><tr><td>CPU</td><td><a href="https://ark.intel.com/content/www/us/en/ark/products/83352/intel-xeon-processor-e52620-v3-15m-cache-2-40-ghz.html">Intel® Xeon® Processor E5-2620 v3</a></td><td>1</td><td>20</td><td>6Core 12HT; 22 nm制程; Base 2.40 GHz, Burst 3.20 GHz; 15MB L3 Cache; 85W TDP; 你不能对一个20块钱的CPU要求更多了! :)</td></tr></tbody></table><div class="note info"><blockquote><p>CPU盖子上的<code>Costa Rica</code>, <code>Malay</code> 代表啥意思?<br>Just to clear something up, the markings on the back of the CPU refer to the packaging site - not the manufacturing site of the actual silicon chip itself.<br>也就是说<mark>代表的是封装工厂的地点</mark>, <code>Malay</code> 代表 <code>Malaysia</code></p></blockquote></div><h3 id="ECC内存"><a href="#ECC内存" class="headerlink" title="ECC内存"></a>ECC内存</h3><div class="note warning"><p>内存买成ECC却不能用 ECC内存到底是什么鬼?</p></div><ul><li>这是因为一般的电脑为了速度，一般都是不支持ECC内存，而ECC内存由于有校验这一步骤，一般都多用在服务器领域，<mark>普通的家用主板一般都是不支持的</mark>，而且对于服务器，还要区分REG-ECC和纯ECC的区别，REG是带寄存器的ECC内存，可以支持更大的单条容量，但是由于有寄存器的存在，延迟会更高。</li></ul><h3 id="CPU散热器"><a href="#CPU散热器" class="headerlink" title="CPU散热器"></a>CPU散热器</h3><div class="note warning"><p>主板上<code>CPU FAN</code>是4针的, 买来的散热器风扇是3针的. 区别是啥? 怎么插?</p></div><blockquote><p>2针, 3针与4针风扇区别?</p></blockquote><ul><li>2针的散热风扇（结构简单，但不能测速）: 一个用于供电、一个用于接地，不过没有测速功能。目前2针的散热风扇已经在市场上大量采用，但是2针的风扇在变速等方面上已经不能满足要求了</li><li>3针的散热风扇（VC电压调速，灵活性欠佳）: 第三条线, 主要是起着测速的作用，通过主板能够侦测到风扇是否在转、转速为多少，但是3针散热风扇的调速是通过调整风扇电压来实现的，此外，能不能调速还需要看下主板是否支持，显然这种调节转速并不够灵活，不能实时反映CPU状态的信息，还需要在主板BIOS中进行各种设置。</li><li>4针的散热风扇（更加灵活更加智能的调速）: 4针的散热风扇是在3针基础上又多了一根PWM线（ 脉宽调变），所谓的PWM线就是利用PWM机制来调节风扇转速，而风扇电压是恒定的，避免了控制电压来变速的一系列弊端。而PWM风扇无需依赖主板BIOS，更加省心方便。PWM脉冲信号可以输出不同的占空比（Duty Cycle），0-100%之间的占空比就能调节出不同的风扇转速，所以能够做到精确、灵活控制。</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208140950640.png"></p><blockquote><p>3针怎么插入主板4针接口中?</p></blockquote><ul><li>兼容, 有防呆机制.</li></ul><p>总体来说, 风扇踩坑了, 但也够用了:</p><ol><li>应该购买6铜管</li><li>应该购买4针的</li></ol><h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><h3 id="成品图"><a href="#成品图" class="headerlink" title="成品图"></a>成品图</h3><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208172253812.png"></p><h3 id="数框框"><a href="#数框框" class="headerlink" title="数框框"></a>数框框</h3><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208172318658.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208172253927.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208172254393.png"></p><h2 id="升级潜力-amp-计划"><a href="#升级潜力-amp-计划" class="headerlink" title="升级潜力&amp;计划"></a>升级潜力&amp;计划</h2><p>整体CPU还是比较强悍的, 有很大升级潜力</p><h3 id="主板升级"><a href="#主板升级" class="headerlink" title="主板升级"></a>主板升级</h3><ul><li>升级成两路, 看有没必要吧, 这样电费吃不消, 电源可能也要升级; <a href="https://post.smzdm.com/p/aoo8wewm/pic_3/#bigImg">X99双路主板简评</a> 指明了方向</li></ul><h3 id="CPU升级"><a href="#CPU升级" class="headerlink" title="CPU升级"></a>CPU升级</h3><ul><li>X99整体还支持V4(Broadwell)的CPU, 例如 <code>E5-2660 V4</code>, 16年上市, 14nm制程. 全部列表参见: </li><li>2699 v3: 650RMB左右</li><li><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208141020764.png"></li></ul><h3 id="内存升级"><a href="#内存升级" class="headerlink" title="内存升级"></a>内存升级</h3><ul><li>ECC内存: 这几个CPU都支持ECC内存, 等下批服务器淘汰, 或者DDR5主流, 就可以低价淘几个DDR4 ECC内存;</li><li>容量升级: CPU支持 <code>192GB * 4 = 768GB</code> 主板支持<code>32GB*4=128GB</code>; 当前是<code>8GB*4=32GB</code>, 有很大升级潜力, 等内存价格下降吧~</li><li>频率升级: CPU限制最大支持2133MHz, 导致最新的3200MHz都没法用(能用, 但会自动降频到2133MHz).</li></ul><h1 id="学到了啥"><a href="#学到了啥" class="headerlink" title="学到了啥"></a>学到了啥</h1><h2 id="常用主板型号"><a href="#常用主板型号" class="headerlink" title="常用主板型号"></a>常用主板型号</h2><ul><li>X79<ul><li>Sandy Bridge-E, Ivy Bridge-E</li><li>Quad-channel DDR3, up to two DIMMs per channel</li></ul></li><li>X99<ul><li>Haswell-E, Broadwell-E</li><li>Quad-channel DDR4, up to two DIMMs per channel</li></ul></li></ul><h2 id="家用机箱型号"><a href="#家用机箱型号" class="headerlink" title="家用机箱型号"></a>家用机箱型号</h2><ul><li>E-ATX</li><li>ATX</li><li>M-ATX</li><li>ITX</li></ul><h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><blockquote><p>Q: 鞋盒机箱, 如何无开关开机?<br>A: 直接螺丝刀戳主板, 连接针脚.<br><img data-src="http://p8.itc.cn/images01/20200823/5eb93a0ca39443f68d7d3392fc3615ea.jpeg"></p></blockquote><h2 id="其他体悟"><a href="#其他体悟" class="headerlink" title="其他体悟"></a>其他体悟</h2><ul><li>知道了经常说的V3, V4利旧是啥了; 对这种洋垃圾CPU市场行情有了大概的认知.</li><li>计算机并非只有CPU, 还有内存, 主板, 显卡甚至电源, 散热器等; 也都是极为关键的. 尤其是这种洋垃圾, CPU跟不要钱一样, 其他组件的可扩展性与稳定性就至关重要了. 很多特性不止要看CPU是否支持, 也要看主板. 例如内存的DDR代数, 最大容量, 通道数, 最大频率, 是否支持ECC; 例如CPU插槽的针脚数;</li><li>摩尔定律的恐怖: 上边几个CPU基本都是14年Q3上市, 到今天2022年Q2, 仅仅8年左右:  <ul><li>价格: 就已经跌倒了白菜价, 以<code>E5-2660 v3</code>为例, 上市价格是<code>$1445.00</code>, 现在是<code>100RMB=$15</code>. </li><li>性能: 当前主流的12代Intel, 以家用的 <a href="https://ark.intel.com/content/www/cn/zh/ark/products/134594/intel-core-i712700k-processor-25m-cache-up-to-5-00-ghz.html">i7-12700K</a> 为例, 制程已经到了7nm; 更不用提ARM架构下的主流制程都是5nm了.</li></ul></li></ul><blockquote><p>旧时王谢堂前燕, 飞入寻常百姓家</p></blockquote><h2 id="老司机踩坑记"><a href="#老司机踩坑记" class="headerlink" title="老司机踩坑记"></a>老司机踩坑记</h2><blockquote><p>自诩为垃圾佬, 结果这次组装电脑, 结结实实把自己给教育了一番.</p></blockquote><h3 id="U盘套路"><a href="#U盘套路" class="headerlink" title="U盘套路"></a>U盘套路</h3><p>在某宝买了2个32GB的U盘, 想要分别作为win10与centos的装机PE.<br>结果在拷贝镜像到U盘的时候, 发现传输速度奇慢无比, 只有6MB&#x2F;s.<br>普通的win10镜像大小是4GB左右, 也就是全部拷贝到U盘里需要: <code>4 * 1024 / 6 / 60 = 11.3</code>, 要10min+;<br>不解, 遂问客服, 解释道是USB2.0的. 仔细看了下详情页, 硕大的”USB 2.0”仿佛在嘲讽我@-@<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208172225310.png"></p><p>What??? 都2202年了, 竟然还有USB 2.0?? 我仿佛听到了一个国际笑话.<br>个人下意识里USB2.0都已经跟鼠标&#x2F;键盘的PS&#x2F;2接口一样, 已经销声匿迹了, by default不都应该是3.0的么?</p><p>此为坑一.</p><h3 id="镜像文件套路"><a href="#镜像文件套路" class="headerlink" title="镜像文件套路"></a>镜像文件套路</h3><p>为图省事儿, 在某CSXN网站花了N多积分, 下载了个”纯净版”镜像.<br>结果一安装, 里边密密麻麻各种软件, 什么360全家桶, TX全家桶, 2345全家桶.<br>浏览器主页被修改得不像样子.<br><mark>原来伪装成纯净版啊</mark></p><p>去搜自己仍然停留在十年前的经典的 雨林X风, 深度, 系统之家等, 结果一个一个都不像样子. 一点都不<code>纯净</code>!<br>最后只能老老实实去下载官方镜像, 又不是不能用@-@</p><h3 id="2345套路"><a href="#2345套路" class="headerlink" title="2345套路"></a>2345套路</h3><p>注册表里搜索”看图王”, 不查不知道, 一查吓一跳. 密密麻麻的, 看得我神经衰弱.<br>心想一个一个删除也不是个事儿啊.<br>索性大笔一挥, 直接把父节点删除. 结果直接经典的windows蓝屏.<br>没办法, 只好拾起传统艺能, 进入PE, 重装系统!</p><ul><li>不搜不知道, 一搜吓一跳. <a href="https://www.zhihu.com/question/35188509/answer/1266544765">劣迹斑斑</a>. 原来老板已经跑路, 搞起了网贷, 区块链.</li><li>好家伙, 我直呼好家伙. 原来还想做百年企业, 天天在官网给自己倒计时呢.</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208172241888.png"></p><blockquote><p>同样是小章鱼, 差别咋就那么大呢? 瞧瞧人家 <a href="https://github.com/">GitHub</a> 多有节操.</p></blockquote><h3 id="win10无节操套路"><a href="#win10无节操套路" class="headerlink" title="win10无节操套路"></a>win10无节操套路</h3><p>安装好系统, 准备安装显卡驱动, 结果报警, C盘存储空间不足.<br>What??? 我C盘可是40GB的容量, 就装了个系统, 啥软件都没安装呢, 咋就没了?<br>每个文件夹大小加起来, 总共也才10多GB, 剩下的20GB哪里去了? 查询才知道, 原来是被微软套路了.</p><ul><li><a href="https://www.itechtics.com/reserved-storage-windows-10/">17GB的预留空间</a></li><li>5GB的休眠文件</li></ul><blockquote><p>FxxK MicroSoft!</p></blockquote><h3 id="多么痛的领悟"><a href="#多么痛的领悟" class="headerlink" title="多么痛的领悟"></a>多么痛的领悟</h3><p>想想之前, 自己被mac&#x2F;linux保护得太好了. 还一直在纳闷为啥要给硬盘分区, C盘, D盘啥的多麻烦.<br>这次我知道了, 我乖乖地分成了几个区, 安装好了GHOST工具, 乖乖给C盘打了个GHOST镜像.<br>随时准备被这些流氓软件”XX”, 随时准备重装&#x2F;恢复系统.</p><blockquote><p>没办法, Windows的生存环境实在是太恶劣了!!</p></blockquote><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul><li><a href="https://www.expreview.com/62077.html">散热风扇的2针、3针、4针都有什么区别？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;垃圾佬的周末, 没事儿就是瞎折腾, 自从在B站被种草了洋垃圾, 按耐不住心中的冲动, 决定也用洋垃圾组装一台能数框框的电脑, 玩玩儿游戏, 压榨压榨性能.&lt;/p&gt;
&lt;h1 id=&quot;为啥要使用洋垃圾&quot;&gt;&lt;a href=&quot;#为啥要使用洋垃圾&quot; class=&quot;headerlink&quot; title=&quot;为啥要使用洋垃圾&quot;&gt;&lt;/a&gt;为啥要使用洋垃圾&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一: 穷, &lt;/li&gt;
&lt;li&gt;二: 玩,&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;配置清单&quot;&gt;&lt;a href=&quot;#配置清单&quot; class=&quot;headerlink&quot; title=&quot;配置清单&quot;&gt;&lt;/a&gt;配置清单&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;几乎都是从海鲜市场淘来的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点是便宜, 性价比高; &lt;/li&gt;
&lt;li&gt;缺点是电气特性衰减不明确, 长期稳定性没有保障.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;但对于偶尔玩一玩游戏, 不是长期高负荷跑渲染等, 整体还OK. 目标是&lt;strong&gt;1000元&lt;/strong&gt;左右搞定.&lt;/p&gt;
&lt;h2 id=&quot;详细清单&quot;&gt;&lt;a href=&quot;#详细清单&quot; class=&quot;headerlink&quot; title=&quot;详细清单&quot;&gt;&lt;/a&gt;详细清单&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;配件名称&lt;/th&gt;
&lt;th&gt;品牌&lt;/th&gt;
&lt;th&gt;数量&lt;/th&gt;
&lt;th&gt;价格&lt;/th&gt;
&lt;th&gt;详细说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://ark.intel.com/content/www/us/en/ark/products/83357/intel-xeon-processor-e52630l-v3-20m-cache-1-80-ghz.html&quot;&gt;Intel® Xeon® Processor E5-2630L v3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;Haswell; 8Core 16HT; 22 nm制程; Base 1.8GHz, Burst 2.90 GHz; 20MB L3 Cache; 55W TDP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主板&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://item.taobao.com/item.htm?id=676047268901&quot;&gt;X99寨板&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;250&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;威刚万紫千红&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;160 + 200&lt;/td&gt;
&lt;td&gt;8GB; DDR4 2133MHz; 强迫症4条必须插满, 组成4通道^_^&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;闪存&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://www.intel.com/content/www/us/en/products/sku/134583/intel-ssd-760p-series-256gb-m-2-80mm-pcie-3-1-x4-3d2-tlc/specifications.html&quot;&gt;Intel® SSD 760P&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;160&lt;/td&gt;
&lt;td&gt;256GB; PCIe 3.1 x4 接口, NVMe&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;显卡&lt;/td&gt;
&lt;td&gt;蓝宝石RX460&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;350&lt;/td&gt;
&lt;td&gt;4GB显存; 无需单独供电; HDMI + VGA + DP 接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;电源&lt;/td&gt;
&lt;td&gt;鑫谷全模组&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;550W, 整体绰绰有余了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU散热器&lt;/td&gt;
&lt;td&gt;长城霄龙400&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;4铜管, 3针脚&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;机箱&lt;/td&gt;
&lt;td&gt;待挑选&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;??&lt;/td&gt;
&lt;td&gt;??&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;合计 &lt;code&gt;80 + 250 + 160 + 200 + 160 + 350 + 120 + 45 = 1,365&lt;/code&gt;&lt;br&gt;现在显卡电源都还没到, 希望组装上去之后一次点亮, 就可以说声”真香!”啦.&lt;/p&gt;
&lt;h2 id=&quot;主板细节&quot;&gt;&lt;a href=&quot;#主板细节&quot; class=&quot;headerlink&quot; title=&quot;主板细节&quot;&gt;&lt;/a&gt;主板细节&lt;/h2&gt;</summary>
    
    
    
    <category term="瞎折腾" scheme="https://davyjones2010.github.io/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="diy" scheme="https://davyjones2010.github.io/tags/diy/"/>
    
  </entry>
  
  <entry>
    <title>常用的Nginx命令与配置</title>
    <link href="https://davyjones2010.github.io/2022-08-09-nginx-scripts/"/>
    <id>https://davyjones2010.github.io/2022-08-09-nginx-scripts/</id>
    <published>2022-08-09T13:42:45.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MAC环境"><a href="#MAC环境" class="headerlink" title="MAC环境"></a>MAC环境</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew <span class="token function">install</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/local/var/www/usr/local/Cellar/nginx/1.21.3/html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置文件路径"><a href="#配置文件路径" class="headerlink" title="配置文件路径"></a>配置文件路径</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/local/etc/nginx/usr/local/etc/nginx/nginx.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="禁止通过IP访问"><a href="#禁止通过IP访问" class="headerlink" title="禁止通过IP访问"></a>禁止通过IP访问</h3><ul><li>绑定了hosts<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1 example.org www.example.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>只允许通过<code>localhost:8080</code>或者<code>example.org:8080</code>或者<code>www.example.org:8080</code>访问, </li><li>禁止通过<code>127.0.0.1:8080</code>访问, 返回502错误.<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>    listen  <span class="token number">8080</span><span class="token punctuation">;</span>    <span class="token builtin class-name">return</span> <span class="token number">502</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>    listen       <span class="token number">8080</span><span class="token punctuation">;</span>    server_name  localhost example.org www.example.org<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208092149192.png"></p><h3 id="单Host多域名-不同域名访问不同服务"><a href="#单Host多域名-不同域名访问不同服务" class="headerlink" title="单Host多域名, 不同域名访问不同服务"></a>单Host多域名, 不同域名访问不同服务</h3><ul><li>绑定了hosts<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1 example.org www.example.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>通过<code>localhost:8080</code>访问, 则访问到 <code>$NGINX_HOME/html/</code> 目录</li><li>通过<code>example.org:8080</code>或者<code>www.example.org:8080</code>访问, 则访问到 <code>$NGINX_HOME/html2/</code> 目录</li><li>禁止通过<code>127.0.0.1:8080</code>访问, 返回502错误.<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">&#123;</span>    listen  <span class="token number">8080</span><span class="token punctuation">;</span>    <span class="token builtin class-name">return</span> <span class="token number">502</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>    listen       <span class="token number">8080</span><span class="token punctuation">;</span>    server_name  example.org www.example.org<span class="token punctuation">;</span>    location / <span class="token punctuation">&#123;</span>        root html2<span class="token punctuation">;</span>        index index.html index.htm<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    error_page   <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span>  /50x.html<span class="token punctuation">;</span>    location <span class="token operator">=</span> /50x.html <span class="token punctuation">&#123;</span>        root   html2<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>server <span class="token punctuation">&#123;</span>    listen       <span class="token number">8080</span><span class="token punctuation">;</span>    server_name  localhost<span class="token punctuation">;</span>    location / <span class="token punctuation">&#123;</span>        root   html<span class="token punctuation">;</span>        index  index.html index.htm<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    error_page   <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span>  /50x.html<span class="token punctuation">;</span>    location <span class="token operator">=</span> /50x.html <span class="token punctuation">&#123;</span>        root   html<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208092152127.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208092152948.png"></li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>NGINX_HOME:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/local/Cellar/nginx/1.21.3location / <span class="token punctuation">&#123;</span>root   html<span class="token punctuation">;</span>index  index.html index.htm<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上边的html就是 NGINX_HOME&#x2F;html&#x2F;</p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew services start nginxbrew services restart nginxbrew services stop nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Nginx是如何知道本次请求-请求的是IP还是域名-如果是域名的话-多个域名如何区分"><a href="#Nginx是如何知道本次请求-请求的是IP还是域名-如果是域名的话-多个域名如何区分" class="headerlink" title="Nginx是如何知道本次请求, 请求的是IP还是域名? 如果是域名的话, 多个域名如何区分?"></a>Nginx是如何知道本次请求, 请求的是IP还是域名? 如果是域名的话, 多个域名如何区分?</h3><ul><li>如下图, 本质上还是Nginx解析HTTP协议, 根据请求行里的<code>RequestURL</code>来进行判断.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208092154665.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208092154173.png"></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MAC环境&quot;&gt;&lt;a href=&quot;#MAC环境&quot; class=&quot;headerlink&quot; title=&quot;MAC环境&quot;&gt;&lt;/a&gt;MAC环境&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;brew &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; nginx&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;内容&quot;&gt;&lt;a href=&quot;#内容&quot; class=&quot;headerlink&quot; title=&quot;内容&quot;&gt;&lt;/a&gt;内容&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;/usr/local/var/www
/usr/local/Cellar/nginx/1.21.3/html&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;h3 id=&quot;配置文件路径&quot;&gt;&lt;a href=&quot;#配置文件路径&quot; class=&quot;headerlink&quot; title=&quot;配置文件路径&quot;&gt;&lt;/a&gt;配置文件路径&lt;/h3&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;/usr/local/etc/nginx
/usr/local/etc/nginx/nginx.conf&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;禁止通过IP访问&quot;&gt;&lt;a href=&quot;#禁止通过IP访问&quot; class=&quot;headerlink&quot; title=&quot;禁止通过IP访问&quot;&gt;&lt;/a&gt;禁止通过IP访问&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;绑定了hosts&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token number&quot;&gt;127.0&lt;/span&gt;.0.1 example.org www.example.org&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;只允许通过&lt;code&gt;localhost:8080&lt;/code&gt;或者&lt;code&gt;example.org:8080&lt;/code&gt;或者&lt;code&gt;www.example.org:8080&lt;/code&gt;访问, &lt;/li&gt;
&lt;li&gt;禁止通过&lt;code&gt;127.0.0.1:8080&lt;/code&gt;访问, 返回502错误.&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;server &lt;span class=&quot;token punctuation&quot;&gt;&amp;#123;&lt;/span&gt;
    listen  &lt;span class=&quot;token number&quot;&gt;8080&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token builtin class-name&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;502&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;&amp;#125;&lt;/span&gt;

server &lt;span class=&quot;token punctuation&quot;&gt;&amp;#123;&lt;/span&gt;
    listen       &lt;span class=&quot;token number&quot;&gt;8080&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    server_name  localhost example.org www.example.org&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;&amp;#125;&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="https://davyjones2010.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="mac" scheme="https://davyjones2010.github.io/tags/mac/"/>
    
    <category term="linux" scheme="https://davyjones2010.github.io/tags/linux/"/>
    
    <category term="network" scheme="https://davyjones2010.github.io/tags/network/"/>
    
    <category term="nginx" scheme="https://davyjones2010.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>深入探究DNS流程与报文</title>
    <link href="https://davyjones2010.github.io/2022-08-08-dns-deep-dive/"/>
    <id>https://davyjones2010.github.io/2022-08-08-dns-deep-dive/</id>
    <published>2022-08-08T14:26:58.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS服务器类型"><a href="#DNS服务器类型" class="headerlink" title="DNS服务器类型"></a>DNS服务器类型</h1><h2 id="root-nameserver"><a href="#root-nameserver" class="headerlink" title="root nameserver"></a>root nameserver</h2><p>即负责<code>.</code>域名的, 全球只有13台(至于为啥只有13台, 自己google吧):  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalkerdeMBP:_assets davywalker$ <span class="token function">dig</span> baidu.com +trace<span class="token punctuation">;</span> <span class="token operator">&lt;&lt;</span><span class="token operator">>></span> DiG <span class="token number">9.10</span>.6 <span class="token operator">&lt;&lt;</span><span class="token operator">>></span> baidu.com +trace<span class="token punctuation">;</span><span class="token punctuation">;</span> global options: +cmd<span class="token builtin class-name">.</span><span class="token number">1</span>INNSm.root-servers.net.<span class="token builtin class-name">.</span><span class="token number">1</span>INNSa.root-servers.net.<span class="token builtin class-name">.</span><span class="token number">1</span>INNSh.root-servers.net.<span class="token builtin class-name">.</span><span class="token number">1</span>INNSl.root-servers.net.<span class="token builtin class-name">.</span><span class="token number">1</span>INNSi.root-servers.net.<span class="token builtin class-name">.</span><span class="token number">1</span>INNSg.root-servers.net.<span class="token builtin class-name">.</span><span class="token number">1</span>INNSj.root-servers.net.<span class="token builtin class-name">.</span><span class="token number">1</span>INNSc.root-servers.net.<span class="token builtin class-name">.</span><span class="token number">1</span>INNSk.root-servers.net.<span class="token builtin class-name">.</span><span class="token number">1</span>INNSe.root-servers.net.<span class="token builtin class-name">.</span><span class="token number">1</span>INNSf.root-servers.net.<span class="token builtin class-name">.</span><span class="token number">1</span>INNSb.root-servers.net.<span class="token builtin class-name">.</span><span class="token number">1</span>INNSd.root-servers.net.<span class="token punctuation">;</span><span class="token punctuation">;</span> Received <span class="token number">239</span> bytes from <span class="token number">192.168</span>.1.1<span class="token comment">#53(192.168.1.1) in 7 ms</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="TLD-Top-Level-Domain-nameserver"><a href="#TLD-Top-Level-Domain-nameserver" class="headerlink" title="TLD(Top Level Domain) nameserver"></a>TLD(Top Level Domain) nameserver</h2><p>即对应 <code>.com</code>, <code>.gov</code>, <code>.cn</code> 等的解析服务器. </p><h2 id="authoritative-nameserver"><a href="#authoritative-nameserver" class="headerlink" title="authoritative nameserver"></a>authoritative nameserver</h2><p>即对应 <code>.baidu.com</code> <code>.hangzhou.gov</code>, <code>gitee.cn</code> 等的解析服务器.<br>通常 authoritative nameserver 是DNS解析的最后一步</p><blockquote><p>The authoritative nameserver is usually the resolver’s last step in the journey for an IP address.</p></blockquote><h1 id="DNS查询类型"><a href="#DNS查询类型" class="headerlink" title="DNS查询类型"></a>DNS查询类型</h1><h2 id="递归式-Recursive-Query"><a href="#递归式-Recursive-Query" class="headerlink" title="递归式(Recursive Query)"></a>递归式(Recursive Query)</h2><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208092118248.png"></p><h3 id="DNS请求"><a href="#DNS请求" class="headerlink" title="DNS请求:"></a>DNS请求:</h3><p>如下, 是个请求中的标识位, 使用dig命令, </p><ul><li>如果<code>+trace</code>则请求自动禁用递归(即如下递归标识设置为false);<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082351183.png"></li><li>不加<code>+trace</code>, 则请求自动使用递归.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208092101659.png"></li></ul><h3 id="DNS响应"><a href="#DNS响应" class="headerlink" title="DNS响应:"></a>DNS响应:</h3><p>如下, </p><ul><li>代表当前LocalDNS服务器支持递归查询.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082352908.png"></li><li>与此形成鲜明对比的是ROOT根DNS服务器返回不支持递归查询.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082353697.png"></li></ul><h2 id="迭代式-Iterative-Query"><a href="#迭代式-Iterative-Query" class="headerlink" title="迭代式(Iterative Query)"></a>迭代式(Iterative Query)</h2><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208092115451.png"></p><h1 id="dig-重要参数与模式"><a href="#dig-重要参数与模式" class="headerlink" title="dig 重要参数与模式"></a><code>dig</code> 重要参数与模式</h1><h2 id="指定域名解析服务器"><a href="#指定域名解析服务器" class="headerlink" title="指定域名解析服务器"></a>指定域名解析服务器</h2><h3 id="方式1-使用-trace参数"><a href="#方式1-使用-trace参数" class="headerlink" title="方式1: 使用+trace参数:"></a>方式1: 使用<code>+trace</code>参数:</h3><p>例如 <code>dig @8.8.8.8 baidu.com +trace</code>: </p><ol><li>@8.8.8.8 则dig +trace时, 代表获取ROOT Server域名列表, 会请求8.8.8.8</li><li>之后会把每个ROOT Server的域名, 例如 a.root-servers.net b.root-servers.net 等, 请求LocalDNS(如图中的30.30.30.30), 通过递归方式(recurse&#x3D;1), 获取到对应的A记录. 注意, 这里就不再是请求 8.8.8.8 了!!</li><li>之后再请求某个ROOT Server, 获取到TLD Server的域名. 依次类推, 走正常迭代DNS方式.<br>所以 @x.x.x.x +trace, 本质上是从 8.8.8.8 获取到根域名地址. 之后还是走的正常迭代查询DNS流程.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208092122506.png"></li></ol><h3 id="方式2-不使用-trace参数"><a href="#方式2-不使用-trace参数" class="headerlink" title="方式2: 不使用+trace参数:"></a>方式2: 不使用<code>+trace</code>参数:</h3><p>例如 <code>dig @8.8.8.8 baidu.com</code></p><ol><li>@8.8.8.8 则dig时, 会请求8.8.8.8, 让8.8.8.8通过递归方式, 直接给出对应baidu.com对应的IP地址.</li><li>注意: 这种就是实际常用的正常DNS解析流程.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208092124056.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208092125582.png"></li></ol><p>如下图, 这是从浏览器里输入baidu.com之后的DNS流程, 可知是递归式的:<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208092128420.png"></p><h3 id="指定域名解析服务器总结"><a href="#指定域名解析服务器总结" class="headerlink" title="指定域名解析服务器总结"></a>指定域名解析服务器总结</h3><p>如果不指定, 则默认: </p><ol><li>请求LocalDNS, 通过 <code>cat /etc/resolv.conf</code> 可知LocalDNS的IP</li><li>让LocalDNS使用递归的方式给出结果.</li></ol><h2 id="指定使用TCP协议解析"><a href="#指定使用TCP协议解析" class="headerlink" title="指定使用TCP协议解析"></a>指定使用TCP协议解析</h2><p>默认DNS协议是基于UDP 53端口; 但也可以基于TCP 53端口完成请求.  </p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">dig</span> @8.8.8.8 baidu.com +tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="包解析"><a href="#包解析" class="headerlink" title="包解析"></a>包解析</h3><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208092204677.png"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>&#x2F;&#x2F; TODO:<br>&#x2F;&#x2F; 1. 可以思考下 DNS over TCP(DoT) 与DNS over UDP(DoU)各自的优缺点<br>&#x2F;&#x2F; 2. 近几年有 DNS over TLS; DNS over HTTP; DNS over HTTPS; 为啥会有这么多套娃协议? 是为了解决啥问题? 优缺点是啥? </p><h1 id="WireShark抓包实战"><a href="#WireShark抓包实战" class="headerlink" title="WireShark抓包实战"></a>WireShark抓包实战</h1><h2 id="简单的顶级域名DNS抓包"><a href="#简单的顶级域名DNS抓包" class="headerlink" title="简单的顶级域名DNS抓包"></a>简单的顶级域名DNS抓包</h2><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 就简单地对baidu.com进行DNS抓包</span>davywalkerdeMBP:_assets davywalker$ <span class="token function">dig</span> baidu.com +trace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="trace迭代式-WireShark分析"><a href="#trace迭代式-WireShark分析" class="headerlink" title="+trace迭代式, WireShark分析"></a><code>+trace</code>迭代式, WireShark分析</h3><h4 id="第一步-向LocalDNS发起请求-请求获取-对应的root-nameserver"><a href="#第一步-向LocalDNS发起请求-请求获取-对应的root-nameserver" class="headerlink" title="第一步: 向LocalDNS发起请求, 请求获取.对应的root nameserver"></a>第一步: 向LocalDNS发起请求, 请求获取<code>.</code>对应的root nameserver</h4><h5 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h5><p>可以看到: </p><ul><li>请求的目标IP是<code>/etc/resolv.conf</code>中对应的LocalDNS IP</li><li>请求是UDP协议, 目标LocalDNS的端口号是53</li><li>请求内容是: <code>&lt;ROOT&gt;</code>, 即根域名DNS; 类型是 <code>NS</code>, 即nameserver; 就是请求根域名的nameserver<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082303614.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082259231.png"></li></ul><h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><p>可以看到: </p><ul><li>响应内容里有13个根域名服务器的域名 </li><li>但注意: <mark>没有返回nameserver的domain对应的IP地址!!!</mark> , 经分析与推测, 由于全球13个根域名服务器的IP是<del>永远不会变</del>的(有可能会变化, <a href="https://web.archive.org/web/20130310100321/http://d.root-servers.org/renumber.html">历史上也变化过</a>), 各个domain对应的IP地址应该是<mark>通过<a href="https://www.iana.org/domains/root/files">Root Hint File</a>, 缓存在操作系统中</mark>.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082306546.png"></li></ul><h4 id="第二步-向root-nameserver请求-请求获取-com-对应的TLD’s-nameserver"><a href="#第二步-向root-nameserver请求-请求获取-com-对应的TLD’s-nameserver" class="headerlink" title="第二步: 向root nameserver请求, 请求获取.com.对应的TLD’s nameserver"></a>第二步: 向root nameserver请求, 请求获取<code>.com.</code>对应的TLD’s nameserver</h4><h5 id="请求-1"><a href="#请求-1" class="headerlink" title="请求"></a>请求</h5><p>可以看到: </p><ul><li>请求的目标IP是<code>202.12.27.33</code>, 经分析, 是<code>m.root-servers.net.</code>对应的IP地址. 应该是按照某种算法随机选的.</li><li>请求想要直接从root nameserver中获取到 baidu.com 的A记录<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082308662.png"></li></ul><h5 id="响应-1"><a href="#响应-1" class="headerlink" title="响应"></a>响应</h5><p>可以看到: </p><ul><li>响应内容里有13个<code>.com.</code>域名服务器的域名.</li><li>但注意: <mark>同时在Additional records部分, 把各个域名服务器对应的IP也都以A记录形式返回</mark>. 这个就是所谓的 <strong><a href="https://blog.csdn.net/dranker/article/details/109754755">Glue Record</a></strong>, 试想下, 如果没有返回A记录, 那么如果<code>.com.</code>返回的nameserver是<code>a.com.</code>, 那么如何获取到这个domain对应的IP? 通过DNS么? 那就无限递归了!</li><li>Additional records中<code>AAAA</code>记录, 代表的是各个域名服务器对应的IPV6地址.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082315463.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082321212.png"></li></ul><h4 id="第三步-向TLD’s-nameserver请求-请求获取baidu-com-对应的authoritative-nameserver"><a href="#第三步-向TLD’s-nameserver请求-请求获取baidu-com-对应的authoritative-nameserver" class="headerlink" title="第三步: 向TLD’s nameserver请求, 请求获取baidu.com.对应的authoritative nameserver"></a>第三步: 向TLD’s nameserver请求, 请求获取<code>baidu.com.</code>对应的authoritative nameserver</h4><h5 id="请求-2"><a href="#请求-2" class="headerlink" title="请求"></a>请求</h5><p>可以看到: </p><ul><li>请求的目标IP是<code>192.31.80.30</code>, 通过翻看上一个Glue Record, 可以知道正是<code>d.gtld-servers.net: type A, class IN, addr 192.31.80.30</code>对应的IP.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082323511.png"></li></ul><h5 id="响应-2"><a href="#响应-2" class="headerlink" title="响应"></a>响应</h5><p>可以看到: </p><ul><li>响应的内容里没有<code>baidu.com</code>的A记录信息, 而是一堆的NS记录信息, 以及NS对应的IP, 因此还需要继续往下查.</li><li>如果是查询顶级域名(例如github.com), 或者二级域名(例如login.github.com)等:  <ul><li>那么理论上这个时候就可以直接返回A记录了. 即不用再走第四步了. 此时A记录可以是个VIP, 然后根据请求具体的二级域名, 例如<code>login.github.com</code>, 通过Nginx等反向代理到对应服务即可.</li><li>但实际分析了下, 大部分网站(如下图中<code>alibaba.com</code>, <code>zhihu.com</code>, <code>aliyun.com</code>等), 都是在这里返回自己的<code>authoritative nameserver</code>, 自己思考了下原因: <ul><li>一是: 因为 TLD’s nameserver 通常是由国家或者组织统一管理的, 各个公司如果IP变化, 不好同步到 TLD 中. 而 authoritative nameserver 一般都是各个公司自己管理, 时效性与灵活性都很高. 例如可以给某些二级&#x2F;三级域名配置不同的IP.  </li><li>二是: 因为如果直接A记录注册在TLD上, 那么整个网站的所有二级&#x2F;三级域名等, 就只能有一个IP入口了. 整体风险就很大了. 如果VIP挂了, 整个网站都不可用了. 如果是不同的二级域名, 分配不同nameserver, 则</li></ul></li></ul></li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082326335.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082343058.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082343720.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082344089.png"></p><h4 id="第四步-向authoritative-nameserver请求-请求获取baidu-com-对应的ip"><a href="#第四步-向authoritative-nameserver请求-请求获取baidu-com-对应的ip" class="headerlink" title="第四步: 向authoritative nameserver请求, 请求获取baidu.com.对应的ip"></a>第四步: 向authoritative nameserver请求, 请求获取<code>baidu.com.</code>对应的ip</h4><h5 id="请求-3"><a href="#请求-3" class="headerlink" title="请求"></a>请求</h5><p>可以看到:</p><ul><li>请求的目标IP是<code>14.215.178.80</code>, 通过翻看上一个Glue Record, 可以知道正是<code>ns4.baidu.com: type A, class IN, addr 14.215.178.80</code>对应的IP.</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082345386.png"></p><h5 id="响应-3"><a href="#响应-3" class="headerlink" title="响应"></a>响应</h5><p>可以看到: </p><ul><li>正确地返回了<code>baidu.com</code>的A记录<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208082347974.png"></li></ul><h3 id="不加-trace递归式-WireShark分析"><a href="#不加-trace递归式-WireShark分析" class="headerlink" title="不加+trace递归式, WireShark分析"></a>不加<code>+trace</code>递归式, WireShark分析</h3><h4 id="第一步-向LocalDNS发起请求-请求获取aliyun-com的IP地址-A记录"><a href="#第一步-向LocalDNS发起请求-请求获取aliyun-com的IP地址-A记录" class="headerlink" title="第一步: 向LocalDNS发起请求, 请求获取aliyun.com的IP地址(A记录)"></a>第一步: 向LocalDNS发起请求, 请求获取<code>aliyun.com</code>的IP地址(A记录)</h4><h5 id="请求-4"><a href="#请求-4" class="headerlink" title="请求"></a>请求</h5><p>可以看到:</p><ul><li>请求的目标IP是<code>/etc/resolv.conf</code>中对应的LocalDNS IP<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208090001833.png"></li></ul><h5 id="响应-4"><a href="#响应-4" class="headerlink" title="响应"></a>响应</h5><p>可以看到: </p><ul><li>LocalDNS直接把DNS的A记录结果返回了. 所有的迭代操作都是LocalDNS执行的了.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208090002803.png"></li></ul><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><h2 id="域名服务器本身IP解析问题"><a href="#域名服务器本身IP解析问题" class="headerlink" title="域名服务器本身IP解析问题"></a>域名服务器本身IP解析问题</h2><p>DNS协议返回了根域名服务器的域名, 例如<code>m.root-servers.net.</code>, 但实际后续向根域名服务器发起查询TLD域名服务器的请求时, 是需要知道根域名服务器的IP的! 这个IP从哪里获取? 通过WireShark抓包, 发现返回的根域名服务器域名列表里, 没有这些域名对应的IP地址. 难道也是通过DNS解析的么? 这样就涉及到循环.<br><mark> Glue Record </mark></p><h2 id="dig请求能否使用指定”递归式”或者”迭代式”么"><a href="#dig请求能否使用指定”递归式”或者”迭代式”么" class="headerlink" title="dig请求能否使用指定”递归式”或者”迭代式”么?"></a>dig请求能否使用指定”递归式”或者”迭代式”么?</h2><blockquote><p>切换查询中的 RD（要求递归）位设置。<br>在缺省情况下设置该位，也就是说 dig 正常情形下发送递归查询。<br>当使用查询选项 +nssearch 或 +trace 时，递归自动禁用。</p></blockquote><h2 id="有CNAME的DNS请求具体是咋样的"><a href="#有CNAME的DNS请求具体是咋样的" class="headerlink" title="有CNAME的DNS请求具体是咋样的?"></a>有CNAME的DNS请求具体是咋样的?</h2><p>例如 <code>dig passport.baidu.com +trace</code>, 返回: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">passport.baidu.com. <span class="token number">1200</span> IN CNAME passport.n.shifen.com.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在dig调用流程中, 到CNAME就结束了; 因为没有继续执行<code>dig passport.n.shifen.com +trace</code></li><li>但在实际浏览器访问时, 浏览器收到CNAME记录, 会重新发一个DNS请求解析<code>passport.n.shifen.com</code>域名.</li></ul><h2 id="直接使用DNS返回的IP访问网站可以么"><a href="#直接使用DNS返回的IP访问网站可以么" class="headerlink" title="直接使用DNS返回的IP访问网站可以么?"></a>直接使用DNS返回的IP访问网站可以么?</h2><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>如下, 返回的<code>baidu.com</code>的A记录<code>39.156.66.10</code>IP地址: </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">^CdavywalkerdeMBP:~ davywalker$ <span class="token function">dig</span> baidu.com<span class="token punctuation">;</span><span class="token punctuation">;</span> QUESTION SECTION:<span class="token punctuation">;</span>baidu.com.INA<span class="token punctuation">;</span><span class="token punctuation">;</span> ANSWER SECTION:baidu.com.<span class="token number">1</span>INA<span class="token number">110.242</span>.68.66baidu.com.<span class="token number">1</span>INA<span class="token number">39.156</span>.66.10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>是否可以不用域名直接通过IP访问?</li><li>答案是<mark>不可以</mark><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208092137035.png"></li></ul><h3 id="为啥要禁止直接通过ip访问？"><a href="#为啥要禁止直接通过ip访问？" class="headerlink" title="为啥要禁止直接通过ip访问？"></a>为啥要禁止直接通过ip访问？</h3><ul><li>虚拟主机，主机上放置了N个网站，而每个网站绑定1个或以上域名，所以用域名访问主机可以解析到网站目录，但用IP的话服务器就不知道解析到哪个目录了！</li><li>为了避免别人把未备案的域名解析到自己的服务器IP而导致服务器被断网; 目前国内很多机房都要求网站主关闭空主机头，防止未备案的域名指向过来造成麻烦</li><li>可能是出于安全的考虑, 如果直接使用IP访问, 则HTTPS证书有效性就无法校验了. 这样被钓鱼了也不知道.</li></ul><h3 id="实践-如何设置禁止ip直接访问-以Nginx为例"><a href="#实践-如何设置禁止ip直接访问-以Nginx为例" class="headerlink" title="实践: 如何设置禁止ip直接访问(以Nginx为例)"></a>实践: 如何设置禁止ip直接访问(以Nginx为例)</h3><ul><li>参见官方给出的文档: <a href="http://nginx.org/en/docs/http/request_processing.html">How to prevent processing requests with undefined server names</a></li><li>实践参照: <a href="https://davyjones2010.github.io/2022-08-09-nginx-scripts/#%E7%A6%81%E6%AD%A2%E9%80%9A%E8%BF%87IP%E8%AE%BF%E9%97%AE">Nginx配置-禁止通过IP访问</a></li></ul><h3 id="实践-如何设置单Host多域名-不同域名访问不同服务-以Nginx为例"><a href="#实践-如何设置单Host多域名-不同域名访问不同服务-以Nginx为例" class="headerlink" title="实践: 如何设置单Host多域名, 不同域名访问不同服务(以Nginx为例)"></a>实践: 如何设置单Host多域名, 不同域名访问不同服务(以Nginx为例)</h3><ul><li>参见官方给出的文档: <a href="http://nginx.org/en/docs/http/request_processing.html">How to prevent processing requests with undefined server names</a></li><li>实践参照: <a href="https://davyjones2010.github.io/2022-08-09-nginx-scripts/#%E5%8D%95Host%E5%A4%9A%E5%9F%9F%E5%90%8D-%E4%B8%8D%E5%90%8C%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%90%8C%E6%9C%8D%E5%8A%A1">Nginx配置-单Host多域名, 不同域名访问不同服务</a></li></ul><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul><li><a href="https://www.cloudflare.com/learning/dns/dns-server-types/">https://www.cloudflare.com/learning/dns/dns-server-types/</a></li><li><a href="https://www.jianshu.com/p/f6ef04bf6af2">https://www.jianshu.com/p/f6ef04bf6af2</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;DNS服务器类型&quot;&gt;&lt;a href=&quot;#DNS服务器类型&quot; class=&quot;headerlink&quot; title=&quot;DNS服务器类型&quot;&gt;&lt;/a&gt;DNS服务器类型&lt;/h1&gt;&lt;h2 id=&quot;root-nameserver&quot;&gt;&lt;a href=&quot;#root-nameserver&quot; class=&quot;headerlink&quot; title=&quot;root nameserver&quot;&gt;&lt;/a&gt;root nameserver&lt;/h2&gt;&lt;p&gt;即负责&lt;code&gt;.&lt;/code&gt;域名的, 全球只有13台(至于为啥只有13台, 自己google吧):  &lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;davywalkerdeMBP:_assets davywalker$ &lt;span class=&quot;token function&quot;&gt;dig&lt;/span&gt; baidu.com +trace

&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&gt;&lt;/span&gt; DiG &lt;span class=&quot;token number&quot;&gt;9.10&lt;/span&gt;.6 &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&gt;&lt;/span&gt; baidu.com +trace
&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; global options: +cmd
&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;			&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;	IN	NS	m.root-servers.net.
&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;			&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;	IN	NS	a.root-servers.net.
&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;			&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;	IN	NS	h.root-servers.net.
&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;			&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;	IN	NS	l.root-servers.net.
&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;			&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;	IN	NS	i.root-servers.net.
&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;			&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;	IN	NS	g.root-servers.net.
&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;			&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;	IN	NS	j.root-servers.net.
&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;			&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;	IN	NS	c.root-servers.net.
&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;			&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;	IN	NS	k.root-servers.net.
&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;			&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;	IN	NS	e.root-servers.net.
&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;			&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;	IN	NS	f.root-servers.net.
&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;			&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;	IN	NS	b.root-servers.net.
&lt;span class=&quot;token builtin class-name&quot;&gt;.&lt;/span&gt;			&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;	IN	NS	d.root-servers.net.
&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; Received &lt;span class=&quot;token number&quot;&gt;239&lt;/span&gt; bytes from &lt;span class=&quot;token number&quot;&gt;192.168&lt;/span&gt;.1.1&lt;span class=&quot;token comment&quot;&gt;#53(192.168.1.1) in 7 ms&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;TLD-Top-Level-Domain-nameserver&quot;&gt;&lt;a href=&quot;#TLD-Top-Level-Domain-nameserver&quot; class=&quot;headerlink&quot; title=&quot;TLD(Top Level Domain) nameserver&quot;&gt;&lt;/a&gt;TLD(Top Level Domain) nameserver&lt;/h2&gt;&lt;p&gt;即对应 &lt;code&gt;.com&lt;/code&gt;, &lt;code&gt;.gov&lt;/code&gt;, &lt;code&gt;.cn&lt;/code&gt; 等的解析服务器. &lt;/p&gt;
&lt;h2 id=&quot;authoritative-nameserver&quot;&gt;&lt;a href=&quot;#authoritative-nameserver&quot; class=&quot;headerlink&quot; title=&quot;authoritative nameserver&quot;&gt;&lt;/a&gt;authoritative nameserver&lt;/h2&gt;&lt;p&gt;即对应 &lt;code&gt;.baidu.com&lt;/code&gt; &lt;code&gt;.hangzhou.gov&lt;/code&gt;, &lt;code&gt;gitee.cn&lt;/code&gt; 等的解析服务器.&lt;br&gt;通常 authoritative nameserver 是DNS解析的最后一步&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The authoritative nameserver is usually the resolver’s last step in the journey for an IP address.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;DNS查询类型&quot;&gt;&lt;a href=&quot;#DNS查询类型&quot; class=&quot;headerlink&quot; title=&quot;DNS查询类型&quot;&gt;&lt;/a&gt;DNS查询类型&lt;/h1&gt;</summary>
    
    
    
    <category term="技术" scheme="https://davyjones2010.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="linux" scheme="https://davyjones2010.github.io/tags/linux/"/>
    
    <category term="dns" scheme="https://davyjones2010.github.io/tags/dns/"/>
    
    <category term="network" scheme="https://davyjones2010.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins Alibaba Cloud 插件开发总结</title>
    <link href="https://davyjones2010.github.io/2022-08-07-jenkins-cloud-plugin-dev-summary/"/>
    <id>https://davyjones2010.github.io/2022-08-07-jenkins-cloud-plugin-dev-summary/</id>
    <published>2022-08-07T14:31:55.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cloud框架的架构与概念"><a href="#Cloud框架的架构与概念" class="headerlink" title="Cloud框架的架构与概念"></a>Cloud框架的架构与概念</h1><hr><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><pre class="mermaid">erDiagram    Jenkins ||--o{ hudson_slaves_Cloud : contains    hudson_slaves_Cloud {        id name    }    hudson_slaves_Cloud ||--|{ SlaveTemplate : contains    SlaveTemplate {        id templateName    }    SlaveTemplate ||--o{ AlibabaEcsSpotFollower : "provision"    AlibabaEcsSpotFollower {        id ecsInstanceId    }    AlibabaEcsSpotFollower ||--|| SlaveComputer : createComputer    SlaveComputer {        id     }</pre><h3 id="各Entity关联关系"><a href="#各Entity关联关系" class="headerlink" title="各Entity关联关系"></a>各Entity关联关系</h3><p>&#x2F;&#x2F; TODO: 待补充完善.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Jenkins</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h2 id="noDelayProvisioning"><a href="#noDelayProvisioning" class="headerlink" title="noDelayProvisioning"></a>noDelayProvisioning</h2><ul><li>当任务队列里有任务时, 自动会在 instanceFloor与instanceCap 之间进行弹性创建node.</li></ul><p>&#x2F;&#x2F; TODO: 待补充完善.</p><h1 id="其他重要信息"><a href="#其他重要信息" class="headerlink" title="其他重要信息"></a>其他重要信息</h1><p>对象序列化后XML文件路径:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token variable">$&#123;proj_path&#125;</span>/alibabacloud-ecs-plugin/work/config.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="插件开发的经验"><a href="#插件开发的经验" class="headerlink" title="插件开发的经验"></a>插件开发的经验</h1><hr><h2 id="规格选择"><a href="#规格选择" class="headerlink" title="规格选择"></a>规格选择</h2><p>在规格选择栏, 设计的时候为了简便用户选择:</p><ol><li>下拉框方式, 方便不熟悉ECS的用户选择</li><li>默认使用2C8G, 即独享型最小规格. 从而减少下拉框规格量, 便于入门.</li></ol><p>但在实际企业级场景下, 用户</p><ol><li>需要有大规格, 基本都是48C以上, 即 12xlarge, 16xlarge, 24xlarge 的规格</li><li>本身使用ECS, 对ECS规格熟悉, 有目标规格.</li></ol><h2 id="SKU选择"><a href="#SKU选择" class="headerlink" title="SKU选择"></a>SKU选择</h2><ol><li>单个CloudProvider, 只支持一个SKU, 数量可以选择多个.<br>但在实际场景下:</li><li>用户希望在多可用区, 多规格, 这样需要重复逐一配置CloudProvider, 非常麻烦.</li></ol><h2 id="系统盘类型选择"><a href="#系统盘类型选择" class="headerlink" title="系统盘类型选择"></a>系统盘类型选择</h2><p>在系统盘选择项上, 设计的时候为了简便用户上手:</p><ol><li>不需要用户填入系统盘类型, 创建ECS(RunInstances)时不传入系统盘类型&amp;大小, 从而让ECS使用的默认值, 即cloud_efficiency</li><li>不需要用户填入系统盘大小, 即使用默认的20GB</li></ol><p>但在实际场景下, 用户:</p><ol><li>选择ecs.c7.xxx规格, 7代规格不支持cloud_efficiency, 只支持cloud_essd, 即RunInstances接口必须传入cloud_essd系统盘类型</li></ol><h2 id="数据盘类型"><a href="#数据盘类型" class="headerlink" title="数据盘类型"></a>数据盘类型</h2><p>在数据盘选项上, 为了用户上手方便:</p><ol><li>默认不创建&amp;挂载系统盘, 因此不需要用户选择数据盘类型&amp;数据盘大小<br>但在实际场景下, 用户:</li><li>会有全镜像, 即镜像中既包含系统盘, 又包含数据盘</li></ol><h2 id="Master与Slave通信方式"><a href="#Master与Slave通信方式" class="headerlink" title="Master与Slave通信方式"></a>Master与Slave通信方式</h2><p>JenkinsMaster与Slave的联通方式, 设计的时候为了方便应对用户Master在云上&#x2F;其他云上&#x2F;云下等场景, 默认为Slave创建公网IP, 从而Master通过公网IP与Slave联通.<br>但在实际场景下:</p><ol><li>创建公网IP会导致频繁的攻击.<pre class="line-numbers language-java" data-language="java"><code class="language-java">【XXX】尊敬的xxxx：云安全中心检测到恶意XX<span class="token punctuation">.</span>XX<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>xxx正在尝试攻击您的服务器：XX<span class="token punctuation">.</span>XX<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>xxx（XX<span class="token operator">-</span>XX<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>），已为您创建IP拦截策略，并成功拦截该恶意IP，建议您登录云安全中心控制台安全告警页中查看IP拦截策略。若您需要放行该 IP ，您可以在IP 拦截策略中禁用安全策略。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>用户本身VPC就是在阿里云上, 通过公网连接, 会产生额外的费用.</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Cloud框架的架构与概念&quot;&gt;&lt;a href=&quot;#Cloud框架的架构与概念&quot; class=&quot;headerlink&quot; title=&quot;Cloud框架的架构与概念&quot;&gt;&lt;/a&gt;Cloud框架的架构与概念&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h2&gt;&lt;h3 id=&quot;ER图&quot;&gt;&lt;a href=&quot;#ER图&quot; class=&quot;headerlink&quot; title=&quot;ER图&quot;&gt;&lt;/a&gt;ER图&lt;/h3&gt;&lt;pre class=&quot;mermaid&quot;&gt;erDiagram
    Jenkins ||--o{ hudson_slaves_Cloud : contains
    hudson_slaves_Cloud {
        id name
    }
    hudson_slaves_Cloud ||--|{ SlaveTemplate : contains
    SlaveTemplate {
        id templateName
    }
    SlaveTemplate ||--o{ AlibabaEcsSpotFollower : &quot;provision&quot;
    AlibabaEcsSpotFollower {
        id ecsInstanceId
    }
    AlibabaEcsSpotFollower ||--|| SlaveComputer : createComputer
    SlaveComputer {
        id 
    }&lt;/pre&gt;

&lt;h3 id=&quot;各Entity关联关系&quot;&gt;&lt;a href=&quot;#各Entity关联关系&quot; class=&quot;headerlink&quot; title=&quot;各Entity关联关系&quot;&gt;&lt;/a&gt;各Entity关联关系&lt;/h3&gt;&lt;p&gt;&amp;#x2F;&amp;#x2F; TODO: 待补充完善.&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;Jenkins&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;h2 id=&quot;noDelayProvisioning&quot;&gt;&lt;a href=&quot;#noDelayProvisioning&quot; class=&quot;headerlink&quot; title=&quot;noDelayProvisioning&quot;&gt;&lt;/a&gt;noDelayProvisioning&lt;/h2&gt;</summary>
    
    
    
    <category term="技术" scheme="https://davyjones2010.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="jenkins" scheme="https://davyjones2010.github.io/tags/jenkins/"/>
    
    <category term="ci" scheme="https://davyjones2010.github.io/tags/ci/"/>
    
    <category term="ci/cd" scheme="https://davyjones2010.github.io/tags/ci-cd/"/>
    
  </entry>
  
  <entry>
    <title>瞎折腾软路由笔记</title>
    <link href="https://davyjones2010.github.io/2022-08-07-software-based-router/"/>
    <id>https://davyjones2010.github.io/2022-08-07-software-based-router/</id>
    <published>2022-08-07T12:38:43.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾佬的周末, 没事儿就是瞎折腾, 前段时间被种草了软路由, 一直心痒痒. 月底下单奢侈一把, 今天给彻底搞起来了. 现在总结下.</p><h1 id="为啥要使用软路由"><a href="#为啥要使用软路由" class="headerlink" title="为啥要使用软路由?"></a>为啥要使用软路由?</h1><p>有几个原因: </p><ol><li>家里的Android(V2RayNG), Mac(ClashX), Windows, Ubuntu等设备都有相关软件能科学上网; 但iPad, iPhone等设备, 安装小火箭, 必须要登录海外AppStore, 而且软件还收费, 太麻烦, 因此没有配置科学上网. 对强迫症患者来说, 简直是灾难.</li><li>想要对网络设备的工作原理能有更深入的理解. 例如路由器的底层工作原理, 实际的路由表是咋样的? 之前使用华为的路由器, 这些权限完全是没有的, 也没办法看到这些的. 对于越狱狂魔来说, 也同样是灾难.</li><li>家里的路由器明显感觉力不从心, 100M的带宽, 平常根本跑不满, 就开始发热. </li><li>IPTV共享: <ol><li>无法啊忍受丑陋的电信机顶盒(烽火 HG680-J), 设计得丑陋不堪, 遥控器巨难用; </li><li>只能在客厅使用, 卧室里也想连接IPTV, 但是连接不上.</li></ol></li></ol><p>软路由本质上是一个低功耗的x86机器, 应该能很好地解决上边的问题. </p><h1 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h1><table><thead><tr><th>配件名称</th><th>品牌</th><th>价格</th><th>详细说明</th></tr></thead><tbody><tr><td>主机</td><td><a href="https://detail.tmall.com/item.htm?id=673002078011&spm=a1z09.2.0.0.237b2e8dIxvpd0&_u=77rqrdmc3b6">倍控</a></td><td>729</td><td>裸机,</td></tr><tr><td>CPU</td><td><a href="https://www.intel.com/content/www/us/en/products/sku/212328/intel-celeron-processor-n5105-4m-cache-up-to-2-90-ghz/specifications.html">Intel N5105</a></td><td>无, 包含在主机里</td><td>第11代, Jasper Lake; 4Core; 10nm; Base 2GHz, Burst 2.9GHz; 4MB L3 Cache; 10W TDP</td></tr><tr><td>内存</td><td>三星</td><td>380*2</td><td>16GB * 2(组成双通道); DDR4; 3200MHz;</td></tr><tr><td>闪存</td><td>西数 SN570</td><td>350</td><td>500GB; NVME</td></tr><tr><td>网卡</td><td>Intel I225-V</td><td>无, 包含在主机里</td><td>4个物理网口&#x2F;卡; 1000Mbps</td></tr></tbody></table><p>合计: <code>729 + 380*2 + 350 = 1839</code>, 几乎可以说是目前工控机的顶配了.</p><div class="note warning"><p>内存频率限制<br>CPU支持的内存频率最大为<code>2933 MHz</code>, 因此使用的 DDR4 <code>3200MHz</code> 被自动降频到了<code>2933 MHz</code>;</p></div><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="OpenWrt安装"><a href="#OpenWrt安装" class="headerlink" title="OpenWrt安装"></a>OpenWrt安装</h2><p>裸机上安装OpenWrt, 配置步骤直接看小电视: <a href="https://www.bilibili.com/video/BV1w541157Uo?spm_id_from=333.880.my_history.page.click&amp;vd_source=25b2aadfc1b4b676c371c31423142e7b">https://www.bilibili.com/video/BV1w541157Uo?spm_id_from=333.880.my_history.page.click&amp;vd_source=25b2aadfc1b4b676c371c31423142e7b</a></p><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><ul><li>OpenClash: &#x2F;&#x2F; TODO:</li></ul><h1 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h1><p>由于家里的网络是FTTB(Fiber-To-The-Building)的, 因此没有光猫, 只有一根入户线. </p><h2 id="软路由改造前"><a href="#软路由改造前" class="headerlink" title="软路由改造前"></a>软路由改造前</h2><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208072212775.png"></p><h2 id="软路由改造后"><a href="#软路由改造后" class="headerlink" title="软路由改造后"></a>软路由改造后</h2><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208072216377.png"></p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><ol><li>安装好 <a href="https://github.com/vernesong/OpenClash">OpenClash</a> 插件, 局域网内科学上网无忧.  </li><li>直接SSH上去, 看到任何的网络相关信息:<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208072139468.png" alt="ARP表"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208072140766.png" alt="路由表"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208072141717.png" alt="网桥"></li><li>网速基本能跑满:<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208072137732.png"></li><li>IPTV共享: 目前还未实现, 涉及到组播+vLan等, 还在研究中.</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>CPU Load极低, 长期维持在0.1-;</li><li>MEM 使用比例极低, 长期可用内存维持在96%+;</li><li>资源完全没有充分利用起来!<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202208072130374.png"></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体来说, 虽然达到了部分目标, 但还是大材小用了! 后边计划有几种方案来充分压榨: </p><ul><li>多跑几个docker容器, 例如搭建Jenkins, GitLab, Nginx, Redis; 方便自己平常的压测验证. </li><li>改成裸机上刷esxi, 搭建几个虚拟机, 把OpenWrt放在其中一个虚拟机里, 其他的Ubuntu, Windows等作为日常休闲娱乐机.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;垃圾佬的周末, 没事儿就是瞎折腾, 前段时间被种草了软路由, 一直心痒痒. 月底下单奢侈一把, 今天给彻底搞起来了. 现在总结下.&lt;/p&gt;
&lt;h1 id=&quot;为啥要使用软路由&quot;&gt;&lt;a href=&quot;#为啥要使用软路由&quot; class=&quot;headerlink&quot; title=&quot;为啥要使用软路由?&quot;&gt;&lt;/a&gt;为啥要使用软路由?&lt;/h1&gt;&lt;p&gt;有几个原因: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;家里的Android(V2RayNG), Mac(ClashX), Windows, Ubuntu等设备都有相关软件能科学上网; 但iPad, iPhone等设备, 安装小火箭, 必须要登录海外AppStore, 而且软件还收费, 太麻烦, 因此没有配置科学上网. 对强迫症患者来说, 简直是灾难.&lt;/li&gt;
&lt;li&gt;想要对网络设备的工作原理能有更深入的理解. 例如路由器的底层工作原理, 实际的路由表是咋样的? 之前使用华为的路由器, 这些权限完全是没有的, 也没办法看到这些的. 对于越狱狂魔来说, 也同样是灾难.&lt;/li&gt;
&lt;li&gt;家里的路由器明显感觉力不从心, 100M的带宽, 平常根本跑不满, 就开始发热. &lt;/li&gt;
&lt;li&gt;IPTV共享: &lt;ol&gt;
&lt;li&gt;无法啊忍受丑陋的电信机顶盒(烽火 HG680-J), 设计得丑陋不堪, 遥控器巨难用; &lt;/li&gt;
&lt;li&gt;只能在客厅使用, 卧室里也想连接IPTV, 但是连接不上.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;软路由本质上是一个低功耗的x86机器, 应该能很好地解决上边的问题. &lt;/p&gt;
&lt;h1 id=&quot;配置清单&quot;&gt;&lt;a href=&quot;#配置清单&quot; class=&quot;headerlink&quot; title=&quot;配置清单&quot;&gt;&lt;/a&gt;配置清单&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;配件名称&lt;/th&gt;
&lt;th&gt;品牌&lt;/th&gt;
&lt;th&gt;价格&lt;/th&gt;
&lt;th&gt;详细说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;主机&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://detail.tmall.com/item.htm?id=673002078011&amp;spm=a1z09.2.0.0.237b2e8dIxvpd0&amp;_u=77rqrdmc3b6&quot;&gt;倍控&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;729&lt;/td&gt;
&lt;td&gt;裸机,&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://www.intel.com/content/www/us/en/products/sku/212328/intel-celeron-processor-n5105-4m-cache-up-to-2-90-ghz/specifications.html&quot;&gt;Intel N5105&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;无, 包含在主机里&lt;/td&gt;
&lt;td&gt;第11代, Jasper Lake; 4Core; 10nm; Base 2GHz, Burst 2.9GHz; 4MB L3 Cache; 10W TDP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;三星&lt;/td&gt;
&lt;td&gt;380*2&lt;/td&gt;
&lt;td&gt;16GB * 2(组成双通道); DDR4; 3200MHz;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;闪存&lt;/td&gt;
&lt;td&gt;西数 SN570&lt;/td&gt;
&lt;td&gt;350&lt;/td&gt;
&lt;td&gt;500GB; NVME&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网卡&lt;/td&gt;
&lt;td&gt;Intel I225-V&lt;/td&gt;
&lt;td&gt;无, 包含在主机里&lt;/td&gt;
&lt;td&gt;4个物理网口&amp;#x2F;卡; 1000Mbps&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;合计: &lt;code&gt;729 + 380*2 + 350 = 1839&lt;/code&gt;, 几乎可以说是目前工控机的顶配了.&lt;/p&gt;
&lt;div class=&quot;note warning&quot;&gt;&lt;p&gt;内存频率限制&lt;br&gt;CPU支持的内存频率最大为&lt;code&gt;2933 MHz&lt;/code&gt;, 因此使用的 DDR4 &lt;code&gt;3200MHz&lt;/code&gt; 被自动降频到了&lt;code&gt;2933 MHz&lt;/code&gt;;&lt;/p&gt;
&lt;/div&gt;


&lt;h1 id=&quot;安装步骤&quot;&gt;&lt;a href=&quot;#安装步骤&quot; class=&quot;headerlink&quot; title=&quot;安装步骤&quot;&gt;&lt;/a&gt;安装步骤&lt;/h1&gt;</summary>
    
    
    
    <category term="瞎折腾" scheme="https://davyjones2010.github.io/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
    <category term="linux" scheme="https://davyjones2010.github.io/tags/linux/"/>
    
    <category term="network" scheme="https://davyjones2010.github.io/tags/network/"/>
    
    <category term="open-wrt" scheme="https://davyjones2010.github.io/tags/open-wrt/"/>
    
    <category term="software-based-router" scheme="https://davyjones2010.github.io/tags/software-based-router/"/>
    
    <category term="router" scheme="https://davyjones2010.github.io/tags/router/"/>
    
  </entry>
  
  <entry>
    <title>从GitHub CLI禁止用户名密码登录引发的思考与总结</title>
    <link href="https://davyjones2010.github.io/2022-07-23-github-token-login/"/>
    <id>https://davyjones2010.github.io/2022-07-23-github-token-login/</id>
    <published>2022-07-23T16:00:00.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在本地CLI中push github代码时, 要求输入用户名密码, 但输入密码之后, 提示禁止使用密码登录.</p><ul><li>根据提示配置了半天SSH免登, 结果发现并不生效, push时仍然让输入账号名密码.</li><li>后续根据提示, 在<a href="https://github.com/settings/tokens">GitHub页面新申请了Token</a>, 然后使用 用户名+Token 登录就可以了.<br>从而引发了诸多疑问与思考.</li></ul><h1 id="GitHub访问几种方式"><a href="#GitHub访问几种方式" class="headerlink" title="GitHub访问几种方式"></a>GitHub访问几种方式</h1><h2 id="方案1-SSH方式"><a href="#方案1-SSH方式" class="headerlink" title="方案1: SSH方式"></a>方案1: SSH方式</h2><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207242155452.png"></p><p>这种方式, 可以通过配置SSH免登即可.</p><h3 id="如何支持不同Host采用不同SSHKey"><a href="#如何支持不同Host采用不同SSHKey" class="headerlink" title="如何支持不同Host采用不同SSHKey?"></a>如何支持不同Host采用不同SSHKey?</h3><p>如果在本地, 既需要配置gitee的SSH免登, 又需要配置github的SSH免登, 有需要配置其他Host的SSH免登, 怎么能让不同的Host使用不同的公私钥对?</p><ul><li>配置样例如下:</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.ssh/config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-- 为 git@gitee.com:/xxx ssh地址配置Host gitee.com  HostName gitee.com  AddKeysToAgent <span class="token function">yes</span>  UseKeychain <span class="token function">yes</span>  IdentityFile ~/.ssh/id_rsa-- 为 git@github.com:xxx/xxx ssh地址配置Host github.com  HostName github.com  AddKeysToAgent <span class="token function">yes</span>  UseKeychain <span class="token function">yes</span>  IdentityFile ~/.ssh/id_ed25519-- 其他地址默认ssh地址配置Host *  AddKeysToAgent <span class="token function">yes</span>  UseKeychain <span class="token function">yes</span>  IdentityFile ~/.ssh/id_ed25519<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>验证是否配置正确:</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>davywalker@davywalkers-MacBook-Pro ~<span class="token punctuation">]</span>$ <span class="token function">ssh</span> git@github.comPTY allocation request failed on channel <span class="token number">1</span>Hi DavyJones2010<span class="token operator">!</span> You've successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方案2-HTTPS方式"><a href="#方案2-HTTPS方式" class="headerlink" title="方案2: HTTPS方式"></a>方案2: HTTPS方式</h2><h3 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h3><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207242155904.png"></p><p>这种方式, 即背景中的案例, 必须通过 用户名+Token方式 登录, 即CLI中密码字段, 不要输入账号的密码, 而是输入Token</p><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207242158549.png"></p><p>搜索了下, <strong>从2021年8月13日开始, GitHub已经禁止了 用户名+密码方式 登录</strong></p><blockquote><p>From August 13, 2021, <br/><br>GitHub is no longer accepting account passwords when authenticating Git operations. <br/><br>You need to add a PAT (Personal Access Token) instead, <br/><br>and you can follow the below method to add a PAT on your system. <br/></p></blockquote><h3 id="GitHub密码存储位置"><a href="#GitHub密码存储位置" class="headerlink" title="GitHub密码存储位置"></a>GitHub密码存储位置</h3><p>在使用SourceTree的时候, 由于repo使用的也是HTTPS, 因此也提示输入 用户名+密码, 由于密码方式被禁用, 因此后续再push这个repo, 会一直报禁止密码登录错误.<br>但也<mark>找不到修改&#x2F;删除该密码的位置.</mark></p><p>查了下资料, 不同的操作系统, 甚至同样操作系统的不同的版本, 存储方式都不同. 这里以 <a href="https://stackoverflow.com/questions/42584934/where-is-my-remote-git-repository-password-stored-on-the-local-machine">MacOS Monterey 12.3.1版本</a> 为例:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalkerdeMacBook-Pro:~ davywalker$ <span class="token function">git</span> config credential.helperosxkeychain<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看出来是由keychain进行的管理, 在Mac的 <code>Applications -&gt; Utilties -&gt; Keychain Access</code> </p><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207252101640.png"></p><ul><li>可以看到SourceTree应用保存的GitHub Repo密码.</li><li>同时也可以看到IntelliJ IDEA保存的GitHub Repo密码, 通过显示repo密码发现, 这个密码字段其实就是签发给Intellij的 PAT(Personal Access Token)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于<font color='red'>本地配置的remote repo是HTTPS方式, 因此通过配置SSH免登方式必然是无效的.</font> </p><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207242202265.png"></p><h1 id="登录安全思考"><a href="#登录安全思考" class="headerlink" title="登录安全思考"></a>登录安全思考</h1><h2 id="为啥禁止CLI-HTTPS方式通过用户名密码登录"><a href="#为啥禁止CLI-HTTPS方式通过用户名密码登录" class="headerlink" title="为啥禁止CLI HTTPS方式通过用户名密码登录?"></a>为啥禁止CLI HTTPS方式通过用户名密码登录?</h2><p>应该是担心密码泄露.<br>但会在哪种情况下泄露密码?</p><ol><li>存储过程: 为了防止每次push都重复输入, git client应该把用户名密码存储到本机某个位置了. </li><li>传输过程: HTTPS中间人攻击, 发生概率就较小了<br>所以应该还是密码存储的风险.<br>通过页面登录, 有交互方式可以实现MFA, 但<mark>CLI方式无法进行交互从而实现MFA.</mark><br>这样从而减弱了安全性.</li></ol><h2 id="为啥通过用户名-Token方式登录-就支持呢"><a href="#为啥通过用户名-Token方式登录-就支持呢" class="headerlink" title="为啥通过用户名+Token方式登录, 就支持呢"></a>为啥通过用户名+Token方式登录, 就支持呢</h2><h3 id="几种类型的Token"><a href="#几种类型的Token" class="headerlink" title="几种类型的Token"></a>几种类型的Token</h3><ul><li>密码: 时间维度是永久有效, 不可召回. 权限范围是无限的(除非子账号). 可能是有规律的.</li><li>SecretKey: 时间维度通常是永久有效(但支持设定长期), 可以召回. 权限范围是有限的. 通常是UUID等无规律的.</li><li>RefreshToken: 时间维度是较长维度(例如可以60天), 可以召回. 权限范围是有限的. 通常是UUID等无规律的.</li><li>AccessToken: 时间维度是较短维度(例如4个小时), 可以召回(但一般不召回, 通过召回RefreshToken实现). 权限范围是优先的. 通常是UUID等无规律的.</li></ul><h3 id="几种登录方式"><a href="#几种登录方式" class="headerlink" title="几种登录方式"></a>几种登录方式</h3><ul><li>方式1: 在网页端, 通常选择密码方式登录, 但需要开启MFA以加固安全. 以该方式作为安全性最强, 权限最大的方式. </li><li>方式2: 在服务端SDK里, 通常选择SecretKey方式. SecretKey如果泄露, 可以通过方式1登录, 然后撤销SecretKey的有效性, 重新签发新的SecretKey. </li><li>方式3: 在移动端SDK里, 通常会签发一个RefreshToken+AccessToken. 每次AccessToken过期之后, 重新通过RefreshToken调用API申请新的AccessToken.</li></ul><p>因此在GitHub CLI方式登录, 其实就是从方式1(但不带MFA)降级到方案2, 一是限制权限范围, 二是可以随时撤销. </p><h2 id="其他解决方案"><a href="#其他解决方案" class="headerlink" title="其他解决方案"></a>其他解决方案</h2><ul><li>也可以将remote repo切换成<a href="https://docs.github.com/en/get-started/getting-started-with-git/managing-remote-repositories#switching-remote-urls-from-https-to-ssh">SSH方式</a>, 并配置SSH免登实现.</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在本地CLI中push github代码时, 要求输入用户名密码, 但输入密码之后, 提示禁止使用密码登录.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据提示配置了半天SSH免登, 结果发现并不生效, push时仍然让输入账号名密码.&lt;/li&gt;
&lt;li&gt;后续根据提示, 在&lt;a href=&quot;https://github.com/settings/tokens&quot;&gt;GitHub页面新申请了Token&lt;/a&gt;, 然后使用 用户名+Token 登录就可以了.&lt;br&gt;从而引发了诸多疑问与思考.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;GitHub访问几种方式&quot;&gt;&lt;a href=&quot;#GitHub访问几种方式&quot; class=&quot;headerlink&quot; title=&quot;GitHub访问几种方式&quot;&gt;&lt;/a&gt;GitHub访问几种方式&lt;/h1&gt;&lt;h2 id=&quot;方案1-SSH方式&quot;&gt;&lt;a href=&quot;#方案1-SSH方式&quot; class=&quot;headerlink&quot; title=&quot;方案1: SSH方式&quot;&gt;&lt;/a&gt;方案1: SSH方式&lt;/h2&gt;&lt;h3 id=&quot;配置方式&quot;&gt;&lt;a href=&quot;#配置方式&quot; class=&quot;headerlink&quot; title=&quot;配置方式&quot;&gt;&lt;/a&gt;配置方式&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207242155452.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种方式, 可以通过配置SSH免登即可.&lt;/p&gt;
&lt;h3 id=&quot;如何支持不同Host采用不同SSHKey&quot;&gt;&lt;a href=&quot;#如何支持不同Host采用不同SSHKey&quot; class=&quot;headerlink&quot; title=&quot;如何支持不同Host采用不同SSHKey?&quot;&gt;&lt;/a&gt;如何支持不同Host采用不同SSHKey?&lt;/h3&gt;&lt;p&gt;如果在本地, 既需要配置gitee的SSH免登, 又需要配置github的SSH免登, 有需要配置其他Host的SSH免登, 怎么能让不同的Host使用不同的公私钥对?&lt;/p&gt;</summary>
    
    
    
    
    <category term="distributed-system" scheme="https://davyjones2010.github.io/tags/distributed-system/"/>
    
    <category term="login" scheme="https://davyjones2010.github.io/tags/login/"/>
    
    <category term="token" scheme="https://davyjones2010.github.io/tags/token/"/>
    
  </entry>
  
  <entry>
    <title>由ZK的SID/ZXID与snowflake算法引发的ID生成算法探讨</title>
    <link href="https://davyjones2010.github.io/2022-07-11-zk-uuid-gen/"/>
    <id>https://davyjones2010.github.io/2022-07-11-zk-uuid-gen/</id>
    <published>2022-07-11T16:00:00.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几种生成算法"><a href="#几种生成算法" class="headerlink" title="几种生成算法"></a>几种生成算法</h1><h2 id="zk里的sid生成算法"><a href="#zk里的sid生成算法" class="headerlink" title="zk里的sid生成算法"></a>zk里的sid生成算法</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li>一个long类型, 占用64位</li><li>由ZK服务端生成的.</li><li>当客户端与ZK服务端建立好TCP连接(或者说应用层连接)之后, 生成.</li></ul><h3 id="生成规则"><a href="#生成规则" class="headerlink" title="生成规则"></a>生成规则</h3><ol><li>获取当前时间(2013-10-04 21:59:42)的毫秒表示：1380895182327 用二进制表示为：</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122157745.png"></p><ol start="2"><li>将步骤1中的数值左移24位，得到：</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122157302.png"></p><ol start="3"><li>右移8位：</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122158285.png"></p><ol start="4"><li>添加机器标识: SID. id 表示配置在myid文件中的值，通常是整数1、2、3等,假设id为2：</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122158613.png"></p><ol start="5"><li>将步骤3和步骤4得到的两个64位表示的数值进行<code>或</code>操作：</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122158687.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">initializeNextSessionId</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> nextSid<span class="token punctuation">;</span>    nextSid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Time</span><span class="token punctuation">.</span><span class="token function">currentElapsedTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>    nextSid <span class="token operator">=</span> nextSid <span class="token operator">|</span> <span class="token punctuation">(</span>id <span class="token operator">&lt;&lt;</span> <span class="token number">56</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextSid <span class="token operator">==</span> <span class="token class-name">EphemeralType</span><span class="token punctuation">.</span>CONTAINER_EPHEMERAL_OWNER<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token operator">++</span>nextSid<span class="token punctuation">;</span>  <span class="token comment">// this is an unlikely edge case, but check it just in case</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> nextSid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>{8位, 当前主机的myid} {40位, 毫秒时间戳} {16位, 单host递增序列号}<br>ZK主机启动时, 会把前 48位初始化好, 接下来每次有client链接到该host, 则后16位进行递增.</p><h3 id="线上样例"><a href="#线上样例" class="headerlink" title="线上样例"></a>线上样例</h3><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122158988.png"></p><p>例如, sid &#x3D; 0x3 518ae13bc4 16e8 本质上能拆分成:</p><ul><li>前8位: 0x3, 代表当前myid&#x3D;3, 是整个ZK集群的第3台服务器.</li><li>中间40位: 518ae13bc4, 代表初始化时时间戳. 由于移位时截断了最高位1, 因此实际的时间戳是 1518ae13bc4, 转成10进制1449733995460, 按照毫秒数转成时间戳2015-12-10 15:53:15, 可以知道该host启动是在这个时间点.</li><li>后16位: 16e8, 转成10进制, 5864, 代表是第5864个连接</li></ul><h3 id="碰撞分析"><a href="#碰撞分析" class="headerlink" title="碰撞分析"></a>碰撞分析</h3><p>思考SID产生规则, 是否有碰撞风险?</p><ol><li>前8位代表主机位, 最大支持256个主机, 如果集群有上千台服务器, 这样必然会重复, 但这样会导致碰撞么? –&gt; 不太会<ol><li>只要能保证前48位不重复, 即可以保证sid不碰撞. 因为后16位是单host粒度递增.</li></ol></li><li>前48位如何碰撞?<ol><li>即前8位相同的主机 myid&#x3D;1 (二进制 00000001) 与 myid&#x3D;257 (100000001)</li><li>在同一毫秒同时启动, 从而中间40位相同</li><li>而在实际小规模集群情况下, 基本很难产生.</li></ol></li><li>单机上, 后16位如果溢出怎么办?<ol><li>即单机上client反复创建session, 超过了2^16&#x3D;65535, 必然会重复!</li><li>经试验, 发现当后16位满了之后, 会向前边借位. 例如:<ol><li>单机上之前的sid: 0x3 764c3db1d3 768e</li><li>后续频繁创建session, 后16位满了, 变成 0x3 764c3db1d4 00e1</li></ol></li><li>看代码: 无脑地对sid做+1操作. 即使这样, 也不太会导致 中间40位碰撞. (有这个可能, 例如当前session频繁创建, 变成了 0x3 ffffffffff 768e, 接下来服务器在 ffffffffff 这个毫秒点启动, 但当前session未失效, 重新连接上去了.  从而sid从 0x3 ffffffffff 0000开始递增, 有可能重新生成了一个 0x3 ffffffffff 768e 的sid)</li></ol></li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122159565.png"></p><h2 id="zk里的zxid生成算法"><a href="#zk里的zxid生成算法" class="headerlink" title="zk里的zxid生成算法"></a>zk里的zxid生成算法</h2><h3 id="zxid组成"><a href="#zxid组成" class="headerlink" title="zxid组成"></a>zxid组成</h3><blockquote><p>The zxid has two parts: the epoch and a counter. <br/><br>In our implementation the zxid is a 64-bit number. <br/><br>We use the high order 32-bits for the epoch and the low order 32-bits for the counter.</p></blockquote><p>64位的long类型, 包含两部分: 前32位代表epoch(即选举次数); 后32位代表counter(即该zk集群中的update操作的次数, 基本是单调递增的).<br>但实际这样设计是有缺陷的:</p><ul><li>在实际场景中, quorum一般都是在较为稳定的内网环境下, 不太会因为网络问题导致发生failover选主切换; 因此epoch使用32位, 支持40亿次选举, 没啥必要.</li><li>而实际counter增长是比较迅猛的, 在支持1000qps的系统中, 50天左右counter就会溢出.</li><li>而counter溢出会导致发生一次强制选主, 从而把counter清零, 把epoch+1;</li><li>而在3.3.5版本之前, counter溢出不会选主, 存在bug, 导致zk集群整体不可用. <a href="https://issues.apache.org/jira/browse/ZOOKEEPER-1277">servers stop serving when lower 32bits of zxid roll over</a></li></ul><h3 id="zxid生成"><a href="#zxid生成" class="headerlink" title="zxid生成"></a>zxid生成</h3><ul><li>zxid必然是由leader生成, 保证单调递增, 不能由客户端生成.</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> epoch <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">long</span> counter <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">long</span> zxid <span class="token operator">=</span> epoch <span class="token operator">&lt;&lt;</span> <span class="token number">32</span> <span class="token operator">|</span> counter<span class="token punctuation">;</span><span class="token comment">// 新的update操作</span>zxid<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="zxid使用情况"><a href="#zxid使用情况" class="headerlink" title="zxid使用情况"></a>zxid使用情况</h3><p>可以使用如下脚本判断后32位使用量, 如果结果&gt;0.8, 代表使用量已经超过80%, 代表有风险.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> srvr <span class="token operator">|</span> <span class="token function">nc</span> <span class="token number">127.0</span>.0.1 <span class="token number">32188</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'/Zxid/&#123;printf "%f\n", and(strtonum($NF),0xffffffff)/2^32&#125;'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Snowflake-ID生成算法"><a href="#Snowflake-ID生成算法" class="headerlink" title="Snowflake ID生成算法"></a>Snowflake ID生成算法</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122159430.png"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>41位时间戳, 标识的时间范围是?</li></ul><p>1970-01-01 08:00:00 ~ 2039-09-07 23:47:35</p><blockquote><p>41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) 得到的值，这里的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年</p></blockquote><ul><li>10位机器id, 标识的机器数量范围是:</li></ul><p>1024 台, 5位datacenterId和 5位workerId</p><ul><li>12位序列号</li></ul><h3 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h3><p>RocketMQ, 消息ID是使用snowflake算法生成, 是由客户端产生.</p><ul><li>客户端如何知道自己的datacenterId?</li><li>可以通过配置, 也可以如下, 通过本机网卡的MAC生成, 参照：<a href="https://github.com/dromara/hutool/blob/a9310c2d305acac617ca656ea6ffc3be6cc48a4c/hutool-core/src/main/java/cn/hutool/core/util/IdUtil.java#L240">IdUtil.java</a></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 获取数据中心ID&lt;br> * 数据中心ID依赖于本地网卡MAC地址。 * &lt;p> * 此算法来自于mybatis-plus#Sequence * &lt;/p> * * @param maxDatacenterId 最大的中心ID * @return 数据中心ID * @since 5.7.3 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">getDataCenterId</span><span class="token punctuation">(</span><span class="token keyword">long</span> maxDatacenterId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span>maxDatacenterId <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"maxDatacenterId must be > 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>maxDatacenterId <span class="token operator">==</span> <span class="token class-name">Long</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        maxDatacenterId <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">long</span> id <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> mac <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">&#123;</span>        mac <span class="token operator">=</span> <span class="token class-name">NetUtil</span><span class="token punctuation">.</span><span class="token function">getLocalHardwareAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UtilException</span> ignore<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// ignore</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> mac<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0x000000FF</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> mac<span class="token punctuation">[</span>mac<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">0x0000FF00</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> mac<span class="token punctuation">[</span>mac<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">6</span><span class="token punctuation">;</span>        id <span class="token operator">=</span> id <span class="token operator">%</span> <span class="token punctuation">(</span>maxDatacenterId <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> id<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>客户端如何知道自己的工作机器ID? </li><li>根据进程PID与datacenterId生成, 参照：<a href="https://github.com/dromara/hutool/blob/a9310c2d305acac617ca656ea6ffc3be6cc48a4c/hutool-core/src/main/java/cn/hutool/core/util/IdUtil.java#L240">IdUtil.java</a></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 获取机器ID，使用进程ID配合数据中心ID生成&lt;br> * 机器依赖于本进程ID或进程名的Hash值。 * * &lt;p> * 此算法来自于mybatis-plus#Sequence * &lt;/p> * * @param datacenterId 数据中心ID * @param maxWorkerId  最大的机器节点ID * @return ID * @since 5.7.3 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">getWorkerId</span><span class="token punctuation">(</span><span class="token keyword">long</span> datacenterId<span class="token punctuation">,</span> <span class="token keyword">long</span> maxWorkerId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">StringBuilder</span> mpid <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mpid<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>datacenterId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        mpid<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">RuntimeUtil</span><span class="token punctuation">.</span><span class="token function">getPid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UtilException</span> igonre<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//ignore</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*     * MAC + PID 的 hashcode 获取16个低位     */</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>mpid<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>maxWorkerId <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="aws中资源ID生成算法"><a href="#aws中资源ID生成算法" class="headerlink" title="aws中资源ID生成算法"></a>aws中资源ID生成算法</h2><h3 id="方案1-Base36"><a href="#方案1-Base36" class="headerlink" title="方案1: Base36"></a>方案1: Base36</h3><p>代码如下, 优点是不需要占位符, 可以直接用<code>ALPHABET</code>甚至可以修改<code>ALPHABET</code>的顺序达到简单加密的效果.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Base36Test</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 26小写+26大写+10数字=62</span>    <span class="token comment">//public static String ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";</span>    <span class="token comment">// 26小写+10数字=36</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> ALPHABET <span class="token operator">=</span> <span class="token string">"0123456789abcdefghijklmnopqrstuvwxyz"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">encoding</span><span class="token punctuation">(</span><span class="token keyword">long</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"num must be greater than 0."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>        <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> num <span class="token operator">/=</span> <span class="token number">36</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>ALPHABET<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">decoding</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"str must not be empty."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            result <span class="token operator">+=</span> ALPHABET<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> dcId <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> izId <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> l <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> encoding <span class="token operator">=</span> <span class="token class-name">Base36Test</span><span class="token punctuation">.</span><span class="token function">encoding</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//int idx = (int)(Math.random() * 1024);</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        encoding <span class="token operator">=</span> <span class="token class-name">Base36Test</span><span class="token punctuation">.</span><span class="token function">encoding</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>        encoding <span class="token operator">=</span> <span class="token class-name">Base36Test</span><span class="token punctuation">.</span><span class="token function">encoding</span><span class="token punctuation">(</span><span class="token number">1023</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>        encoding <span class="token operator">=</span> <span class="token class-name">Base36Test</span><span class="token punctuation">.</span><span class="token function">encoding</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方案2-Base64"><a href="#方案2-Base64" class="headerlink" title="方案2: Base64"></a>方案2: Base64</h3><p>缺点是会有<code>=</code>占位符.</p><h1 id="时钟回拨问题"><a href="#时钟回拨问题" class="headerlink" title="时钟回拨问题"></a>时钟回拨问题</h1><ul><li>zk里的sid不太会有时钟回拨问题, 是因为时间戳是机器启动的时候生成的. 除非回拨时间特别长, 刚好回拨之后机器又重启了, 拿到了之前那个时间戳. 但考虑到实际场景, 实际不太会发生.<ul><li>机器重启不会那么频繁, 只会在启动时生成</li><li>时钟回拨, 一般都是亚秒级别的回拨</li></ul></li><li>rocketmq里snowflake, 由于是客户端每次生成时实时获取的时间戳, 因此即使回拨了几毫秒, 在生成ID速度非常快的情况下, 也有可能重复. 如何解决?<ul><li>比较挫的方案, 关闭ntp</li><li>比较好的方案: 当回拨时间小于15ms，就等时间追上来之后继续生成。</li></ul><ol><li>更好的方案, 当时间大于15ms时间我们通过<strong>更换workid</strong>来产生之前都没有产生过的来解决回拨问题。</li><li>最好的方案: 如下修改算法, 可以找2bit位作为时钟回拨位，发现有时钟回拨就将回拨位加1，达到最大位后再从0开始进行循环。</li></ol></li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122159865.png"></p><h1 id="方案比较"><a href="#方案比较" class="headerlink" title="方案比较"></a>方案比较</h1><ul><li><p>相同点: </p><ul><li>都使用long类型, 占用64位</li><li>都希望既能尽量减少碰撞, 又能反映递增趋势</li><li>组成结构都是: <code>主机编号+时间戳+递增编号</code></li></ul></li><li><p>差异点:</p><ul><li>时间戳: <ul><li>sid时间戳占用40位(完整的应该是41位, 但默认截断了最高位1); 而snowflake时间戳占用41位, 相对时间范围是79年, 绝对时间到2039年. </li><li>sid的时间戳, 是zk主机启动起来的时间戳, 之后在下次启动之前, 就不再变化了.</li><li>snowflake的时间戳, 是client相对于某个时间点的相对时间; 且是生成ID的当前时间, 下一个毫秒这个时间戳会变化.</li></ul></li></ul></li><li><p>其他</p><ul><li>zk的算法, 但单host增数量是65535(实际可以借40位, 即上千亿, 但有碰撞风险了), 适用于长连场景, 即session不会频繁创建, 从而导致后16位递增那么快.</li><li>snowflake算法, 支持单机每毫秒产生 2^12 &#x3D; 4096 个ID, 适用于创建ID非常频繁的场景.</li><li>假设, 用zk的算法来生成snowflake的id:<ul><li>如果还是机器启动时生成时间戳位, 那单机只能生成 2^16 &#x3D; 65535 个ID, 之后就只能借时间戳的位了, 可能会重复了!</li></ul></li><li>假设, 用snowflake来生成zk的sid: <ul><li>貌似没啥问题.</li></ul></li></ul></li></ul><h1 id="其他总结"><a href="#其他总结" class="headerlink" title="其他总结"></a>其他总结</h1><ol><li>sid, snowflakeID 本质上都是分布式ID生成, 需要保障几点:<ol><li>局部, 全局 唯一</li><li>趋势递增. (这点是UUID无法达到的效果, 因此不使用UUIDGen)</li></ol></li></ol><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul><li><a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></li><li><a href="https://www.cnblogs.com/jiangxinlingdu/p/8440413.html">https://www.cnblogs.com/jiangxinlingdu/p/8440413.html</a></li><li><a href="https://xie.infoq.cn/article/ed9b31c014342fd469627d42d">https://xie.infoq.cn/article/ed9b31c014342fd469627d42d</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;几种生成算法&quot;&gt;&lt;a href=&quot;#几种生成算法&quot; class=&quot;headerlink&quot; title=&quot;几种生成算法&quot;&gt;&lt;/a&gt;几种生成算法&lt;/h1&gt;&lt;h2 id=&quot;zk里的sid生成算法&quot;&gt;&lt;a href=&quot;#zk里的sid生成算法&quot; class=&quot;headerlink&quot; title=&quot;zk里的sid生成算法&quot;&gt;&lt;/a&gt;zk里的sid生成算法&lt;/h2&gt;&lt;h3 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个long类型, 占用64位&lt;/li&gt;
&lt;li&gt;由ZK服务端生成的.&lt;/li&gt;
&lt;li&gt;当客户端与ZK服务端建立好TCP连接(或者说应用层连接)之后, 生成.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;生成规则&quot;&gt;&lt;a href=&quot;#生成规则&quot; class=&quot;headerlink&quot; title=&quot;生成规则&quot;&gt;&lt;/a&gt;生成规则&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;获取当前时间(2013-10-04 21:59:42)的毫秒表示：1380895182327 用二进制表示为：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122157745.png&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;将步骤1中的数值左移24位，得到：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122157302.png&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;右移8位：&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="zookeeper" scheme="https://davyjones2010.github.io/tags/zookeeper/"/>
    
    <category term="distributed-system" scheme="https://davyjones2010.github.io/tags/distributed-system/"/>
    
    <category term="uuid" scheme="https://davyjones2010.github.io/tags/uuid/"/>
    
    <category term="snowflake" scheme="https://davyjones2010.github.io/tags/snowflake/"/>
    
    <category term="sid" scheme="https://davyjones2010.github.io/tags/sid/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络之HTTP Proxy原理与实现分析</title>
    <link href="https://davyjones2010.github.io/2022-07-10-linux-network-http-proxy/"/>
    <id>https://davyjones2010.github.io/2022-07-10-linux-network-http-proxy/</id>
    <published>2022-07-10T16:00:00.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在使用apache的HttpClient时(获取其他常用的httpclient), 经常会发现初始化时可以配置http proxy. 但有些疑问:</p><ol><li>在什么场景下需要使用http proxy?</li><li>具体http proxy怎么配置?</li><li>具体http proxy的实现原理是啥? 包括 httpClient 如何使用这个proxy? 具体的httpProxy怎么处理这种包?</li></ol><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>docker</li><li>ubuntu</li></ul><h2 id="http-proxy-服务端部署"><a href="#http-proxy-服务端部署" class="headerlink" title="http proxy 服务端部署"></a>http proxy 服务端部署</h2><p>Nginx通常是作为反向代理, 但其实也可以作为正向代理使用:  <a href="https://github.com/reiz/nginx_proxy">nginx_proxy</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run -d -p <span class="token number">9999</span>:8888 -v <span class="token variable">$&#123;<span class="token environment constant">PWD</span>&#125;</span>/nginx_allowlist.conf:/usr/local/nginx/conf/nginx.conf reiz/nginx_proxy:0.0.3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="http-proxy-客户端配置"><a href="#http-proxy-客户端配置" class="headerlink" title="http proxy 客户端配置"></a>http proxy 客户端配置</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span><span class="token class-name">HostConfiguration</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span><span class="token class-name">HttpClient</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span>methods<span class="token punctuation">.</span></span><span class="token class-name">GetMethod</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span>params<span class="token punctuation">.</span></span><span class="token class-name">HttpMethodParams</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpClientTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> ENCODING <span class="token operator">=</span> <span class="token string">"UTF-8"</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">"https://www.google.com"</span><span class="token punctuation">;</span>                <span class="token class-name">HttpClient</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">HostConfiguration</span> hostConfiguration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HostConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        hostConfiguration<span class="token punctuation">.</span><span class="token function">setProxy</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">9999</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">setHostConfiguration</span><span class="token punctuation">(</span>hostConfiguration<span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">getParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setParameter</span><span class="token punctuation">(</span>            <span class="token class-name">HttpMethodParams</span><span class="token punctuation">.</span>HTTP_CONTENT_CHARSET<span class="token punctuation">,</span> ENCODING<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">GetMethod</span> method <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetMethod</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">executeMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Code: "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">String</span> response <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getResponseBodyAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="客户端请求分析"><a href="#客户端请求分析" class="headerlink" title="客户端请求分析"></a>客户端请求分析</h2><p>不配置proxy:</p><ul><li>client —http get—&gt; <a href="http://www.google.com/">www.google.com</a></li></ul><p>配置了proxy:</p><ul><li>client — tcp —&gt; proxy — http get —&gt;  <a href="http://www.google.com/">www.google.com</a></li></ul><p>可以看到, client.executeMethod实质上是:</p><ol><li>client先与proxy建立了TCP连接.</li><li>然后将HTTP报文, 包括目标域名(即GET <a href="http://www.google.com/">http://www.google.com</a>), 作为TCP的output stream传给proxy</li><li>proxy解析tcp报文, 获取到真正的目标域名, 查找DNS获取到google.com的ip地址.</li><li>proxy与google.com建立TCP连接, 发送报文body等.</li></ol><p>这种也叫: relay, 即中继.</p><h2 id="实际连接分析"><a href="#实际连接分析" class="headerlink" title="实际连接分析"></a>实际连接分析</h2><h3 id="host上，-LISTEN了9999端口"><a href="#host上，-LISTEN了9999端口" class="headerlink" title="host上， LISTEN了9999端口"></a>host上， LISTEN了9999端口</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/PlayGround/docker/nginx-forward-proxy$ <span class="token function">netstat</span> -natp <span class="token operator">|</span> <span class="token function">fgrep</span> <span class="token number">9999</span><span class="token punctuation">(</span>Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.<span class="token punctuation">)</span>tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:9999            <span class="token number">0.0</span>.0.0:*               LISTEN      -                   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容器内部，-LISTEN了8888端口"><a href="#容器内部，-LISTEN了8888端口" class="headerlink" title="容器内部， LISTEN了8888端口"></a>容器内部， LISTEN了8888端口</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@84129a407795:/app<span class="token comment"># netstat -nat | fgrep 8888</span>tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:8888            <span class="token number">0.0</span>.0.0:*               LISTEN     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="在Host上某个java进程发起一个HTTP请求之后"><a href="#在Host上某个java进程发起一个HTTP请求之后" class="headerlink" title="在Host上某个java进程发起一个HTTP请求之后"></a>在Host上某个java进程发起一个HTTP请求之后</h3><ul><li><p>HOST上 Java 进程</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads/Clash-Linux$ <span class="token function">netstat</span> -natp <span class="token operator">|</span> <span class="token function">fgrep</span> <span class="token number">9999</span><span class="token punctuation">(</span>Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.<span class="token punctuation">)</span>tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:9999            <span class="token number">0.0</span>.0.0:*               LISTEN      -                   tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">127.0</span>.0.1:9999          <span class="token number">127.0</span>.0.1:42261         TIME_WAIT   -                   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>容器内部</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@84129a407795:/app<span class="token comment"># netstat -nat | fgrep 8888</span>tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">0.0</span>.0.0:8888            <span class="token number">0.0</span>.0.0:*               LISTEN     tcp        <span class="token number">0</span>      <span class="token number">0</span> <span class="token number">172.17</span>.0.4:8888         <span class="token number">172.17</span>.0.1:51960        TIME_WAIT  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>TODO:</p><ul><li>在访问<code>http://www.google.com</code>时，Java测试代码正常返回结果。</li><li>在访问<code>http://www.baidu.com</code>时， Java会出现如下异常，理论上由于不在nginx的白名单里应该被block的，但为啥会抛出异常？<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>IOException</span><span class="token operator">:</span> <span class="token class-name">Stream</span> closedat <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>BufferedInputStream</span><span class="token punctuation">.</span><span class="token function">getBufIfOpen</span><span class="token punctuation">(</span><span class="token class-name">BufferedInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">170</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>BufferedInputStream</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">BufferedInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">336</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span>WireLogInputStream</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">WireLogInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">69</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span>ContentLengthInputStream</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">ContentLengthInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">170</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>FilterInputStream</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">FilterInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">133</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span>AutoCloseInputStream</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">AutoCloseInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">108</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>FilterInputStream</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">FilterInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">107</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span>AutoCloseInputStream</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">AutoCloseInputStream</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">127</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span>HttpMethodBase</span><span class="token punctuation">.</span><span class="token function">getResponseBody</span><span class="token punctuation">(</span><span class="token class-name">HttpMethodBase</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">690</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span>HttpMethodBase</span><span class="token punctuation">.</span><span class="token function">getResponseBodyAsString</span><span class="token punctuation">(</span><span class="token class-name">HttpMethodBase</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">803</span><span class="token punctuation">)</span>at <span class="token class-name"><span class="token namespace">edu<span class="token punctuation">.</span>xmu<span class="token punctuation">.</span>test<span class="token punctuation">.</span>javaweb<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span></span>HttpClientProxyTest</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token class-name">HttpClientProxyTest</span><span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">31</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h1 id="再回到实践中"><a href="#再回到实践中" class="headerlink" title="再回到实践中"></a>再回到实践中</h1><h2 id="实践1：-DNS劫持-正向代理过滤域名"><a href="#实践1：-DNS劫持-正向代理过滤域名" class="headerlink" title="实践1： DNS劫持+正向代理过滤域名"></a>实践1： DNS劫持+正向代理过滤域名</h2><p>通过DNS劫持，将所有HTTP请求都定位到正向代理中，在正向代理里进行代理域名的黑白名单控制。</p><ul><li>缺点：<ul><li>DNS劫持可以被手动禁用，也可以手动指定<code>8.8.8.8</code>绕过DNS服务器（当然如果DNS请求直接都被劫持，）。</li><li>只针对HTTP请求有效，如果知道目标的IP, 可以通过IP直连上。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在使用apache的HttpClient时(获取其他常用的httpclient), 经常会发现初始化时可以配置http proxy. 但有些疑问:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在什么场景下需要使用http proxy?&lt;/li&gt;
&lt;li&gt;具体http proxy怎么配置?&lt;/li&gt;
&lt;li&gt;具体http proxy的实现原理是啥? 包括 httpClient 如何使用这个proxy? 具体的httpProxy怎么处理这种包?&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;实践&quot;&gt;&lt;a href=&quot;#实践&quot; class=&quot;headerlink&quot; title=&quot;实践&quot;&gt;&lt;/a&gt;实践&lt;/h1&gt;&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;docker&lt;/li&gt;
&lt;li&gt;ubuntu&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;http-proxy-服务端部署&quot;&gt;&lt;a href=&quot;#http-proxy-服务端部署&quot; class=&quot;headerlink&quot; title=&quot;http proxy 服务端部署&quot;&gt;&lt;/a&gt;http proxy 服务端部署&lt;/h2&gt;&lt;p&gt;Nginx通常是作为反向代理, 但其实也可以作为正向代理使用:  &lt;a href=&quot;https://github.com/reiz/nginx_proxy&quot;&gt;nginx_proxy&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;docker&lt;/span&gt; run -d -p &lt;span class=&quot;token number&quot;&gt;9999&lt;/span&gt;:8888 -v &lt;span class=&quot;token variable&quot;&gt;$&amp;#123;&lt;span class=&quot;token environment constant&quot;&gt;PWD&lt;/span&gt;&amp;#125;&lt;/span&gt;/nginx_allowlist.conf:/usr/local/nginx/conf/nginx.conf reiz/nginx_proxy:0.0.3&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;http-proxy-客户端配置&quot;&gt;&lt;a href=&quot;#http-proxy-客户端配置&quot; class=&quot;headerlink&quot; title=&quot;http proxy 客户端配置&quot;&gt;&lt;/a&gt;http proxy 客户端配置&lt;/h2&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://davyjones2010.github.io/tags/linux/"/>
    
    <category term="iaas" scheme="https://davyjones2010.github.io/tags/iaas/"/>
    
    <category term="network" scheme="https://davyjones2010.github.io/tags/network/"/>
    
    <category term="cloud-computing" scheme="https://davyjones2010.github.io/tags/cloud-computing/"/>
    
    <category term="http-proxy" scheme="https://davyjones2010.github.io/tags/http-proxy/"/>
    
    <category term="proxy" scheme="https://davyjones2010.github.io/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>记一次分布式场景下状态机设计缺陷导致的问题</title>
    <link href="https://davyjones2010.github.io/2022-07-06-state-machine-in-distributed-system/"/>
    <id>https://davyjones2010.github.io/2022-07-06-state-machine-in-distributed-system/</id>
    <published>2022-07-06T16:00:00.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li><p>为某个对象item建模, 有如下几种状态变迁, 在数据库中state字段记录:<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207072308671.png"></p></li><li><p>其中processing过程可能会持续时间较久, 10min左右</p></li><li><p>在服务端某个线程响应请求, 该对象处于processing过程中时, 服务器发布重启, 导致item状态一直卡在processing </p></li><li><p>而processing状态, <strong>本身是中间状态, 无法进行任何人肉干预&#x2F;操作</strong>, 从而导致只能临时提交数据订正, 将状态字段修改回”init”, 然后再执行一次process.</p></li></ul><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>仔细思考了下, 发现设计的时候, 根本原因是对于中间状态没有做好处理, 如背景中介绍的服务重启的处理.<br>而<mark>在分布式场景下, 服务重启是by design需要被接受的.</mark><br>这里思考了下可能的几种处理方式:</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul><li>如何区分状态机的中间状态与终态? </li><li>一条原则: <mark>终态-&gt;终态之间, 必须是可以人肉有入口触发的(而不是系统自动触发的); 必须是可重入的.</mark></li></ul><h2 id="方案1-状态机设计修改-把processing作为纯粹的中间状态"><a href="#方案1-状态机设计修改-把processing作为纯粹的中间状态" class="headerlink" title="方案1: 状态机设计修改: 把processing作为纯粹的中间状态"></a>方案1: 状态机设计修改: 把processing作为纯粹的中间状态</h2><ol><li><p>将processing从状态机中删除掉, 如下: <br/><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207072351350.png"></p></li><li><p>使用 分布式锁&#x2F;db字段锁 来实现排他功能(即item同时只能被一个线程处理, 防止多个线程同时处理一个item导致死锁&#x2F;重复计算等问题).</p><ol><li>在item执行前, 加上锁+锁超时时间(如例子中的10min); 其他线程要执行时, 无法抢到该item的锁. </li><li>item执行完成之后, 状态修改为finished之后, 再释放掉item锁.</li><li>item执行异常中断(例如服务器重启, 线程crash等): 等待锁超时. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.</li><li>item执行失败: 线程里catch住异常, 主动释放掉该item锁. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.</li></ol></li><li><p>或者使用事务:(不过本例子中不适合, 因为10min太久了, 其他执行耗时较短30s以内的可以使用该方案)  </p><ol><li>item执行前开启事务;</li><li>执行后修改状态为finished, commit事务.</li><li>item执行异常中断(例如服务器重启, 线程crash等): 事务自动回滚. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.</li><li>item执行失败: 主动回滚事务. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.</li></ol></li></ol><h2 id="方案2-状态机设计修改-把processing作为纯粹的终态"><a href="#方案2-状态机设计修改-把processing作为纯粹的终态" class="headerlink" title="方案2: 状态机设计修改: 把processing作为纯粹的终态"></a>方案2: 状态机设计修改: 把processing作为纯粹的终态</h2><ol><li><p>需要设计从processing-&gt;finished&#x2F;init的人肉触发入口.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207072354738.png"></p></li><li><p>如何防止多个线程同时触发该item从processing-&gt;finished&#x2F;init的变迁? 参见方案1中锁&#x2F;事务的方式</p></li></ol><h2 id="方案3-优雅停机"><a href="#方案3-优雅停机" class="headerlink" title="方案3: 优雅停机"></a>方案3: 优雅停机</h2><ol><li>在shutdown-hook里注册事件:<ol><li>将状态改回init. –&gt; required.</li><li>将worker线程interrupt掉. –&gt; optional, 因为即使不interrupt, 进程停止线程也会被回收.</li></ol></li><li>但该方案有很大的缺陷, 如果直接<code>kill -9</code>, 则shutdown-hook根本不会执行.</li></ol><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>最终采用了方案2, 因为从状态机中删除掉一个终态, 对现有代码改造量太大了.</p><h1 id="其他思考"><a href="#其他思考" class="headerlink" title="其他思考"></a>其他思考</h1><ol><li>状态机设计的时候, 一定要慎重考虑哪些是终态, 哪些是中间状态. 不是说因为在某个状态持续时间较长(如例子中的processing), 就要作为终态. </li><li>状态机中每个终态之间, 必须考虑可重入性; 必须要保证能人肉触发终态之间的转化. 本文的例子就是反面教材, item卡在processing这个终态, 无法进行程序上的任何操作.</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为某个对象item建模, 有如下几种状态变迁, 在数据库中state字段记录:&lt;br&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207072308671.png&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其中processing过程可能会持续时间较久, 10min左右&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在服务端某个线程响应请求, 该对象处于processing过程中时, 服务器发布重启, 导致item状态一直卡在processing &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;而processing状态, &lt;strong&gt;本身是中间状态, 无法进行任何人肉干预&amp;#x2F;操作&lt;/strong&gt;, 从而导致只能临时提交数据订正, 将状态字段修改回”init”, 然后再执行一次process.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;方案&quot;&gt;&lt;a href=&quot;#方案&quot; class=&quot;headerlink&quot; title=&quot;方案&quot;&gt;&lt;/a&gt;方案&lt;/h1&gt;&lt;p&gt;仔细思考了下, 发现设计的时候, 根本原因是对于中间状态没有做好处理, 如背景中介绍的服务重启的处理.&lt;br&gt;而&lt;mark&gt;在分布式场景下, 服务重启是by design需要被接受的.&lt;/mark&gt;&lt;br&gt;这里思考了下可能的几种处理方式:&lt;/p&gt;
&lt;h2 id=&quot;原则&quot;&gt;&lt;a href=&quot;#原则&quot; class=&quot;headerlink&quot; title=&quot;原则&quot;&gt;&lt;/a&gt;原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如何区分状态机的中间状态与终态? &lt;/li&gt;
&lt;li&gt;一条原则: &lt;mark&gt;终态-&amp;gt;终态之间, 必须是可以人肉有入口触发的(而不是系统自动触发的); 必须是可重入的.&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;方案1-状态机设计修改-把processing作为纯粹的中间状态&quot;&gt;&lt;a href=&quot;#方案1-状态机设计修改-把processing作为纯粹的中间状态&quot; class=&quot;headerlink&quot; title=&quot;方案1: 状态机设计修改: 把processing作为纯粹的中间状态&quot;&gt;&lt;/a&gt;方案1: 状态机设计修改: 把processing作为纯粹的中间状态&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将processing从状态机中删除掉, 如下: &lt;br&gt;&lt;br&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207072351350.png&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 分布式锁&amp;#x2F;db字段锁 来实现排他功能(即item同时只能被一个线程处理, 防止多个线程同时处理一个item导致死锁&amp;#x2F;重复计算等问题).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在item执行前, 加上锁+锁超时时间(如例子中的10min); 其他线程要执行时, 无法抢到该item的锁. &lt;/li&gt;
&lt;li&gt;item执行完成之后, 状态修改为finished之后, 再释放掉item锁.&lt;/li&gt;
&lt;li&gt;item执行异常中断(例如服务器重启, 线程crash等): 等待锁超时. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.&lt;/li&gt;
&lt;li&gt;item执行失败: 线程里catch住异常, 主动释放掉该item锁. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;或者使用事务:(不过本例子中不适合, 因为10min太久了, 其他执行耗时较短30s以内的可以使用该方案)  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;item执行前开启事务;&lt;/li&gt;
&lt;li&gt;执行后修改状态为finished, commit事务.&lt;/li&gt;
&lt;li&gt;item执行异常中断(例如服务器重启, 线程crash等): 事务自动回滚. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.&lt;/li&gt;
&lt;li&gt;item执行失败: 主动回滚事务. 由于仍然是init状态(终态), 因此可以重新人肉触发, 新的线程抢到锁, 重新执行.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;方案2-状态机设计修改-把processing作为纯粹的终态&quot;&gt;&lt;a href=&quot;#方案2-状态机设计修改-把processing作为纯粹的终态&quot; class=&quot;headerlink&quot; title=&quot;方案2: 状态机设计修改: 把processing作为纯粹的终态&quot;&gt;&lt;/a&gt;方案2: 状态机设计修改: 把processing作为纯粹的终态&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;需要设计从processing-&amp;gt;finished&amp;#x2F;init的人肉触发入口.&lt;br&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207072354738.png&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何防止多个线程同时触发该item从processing-&amp;gt;finished&amp;#x2F;init的变迁? 参见方案1中锁&amp;#x2F;事务的方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="learn-from-failure" scheme="https://davyjones2010.github.io/tags/learn-from-failure/"/>
    
    <category term="java" scheme="https://davyjones2010.github.io/tags/java/"/>
    
    <category term="good-design" scheme="https://davyjones2010.github.io/tags/good-design/"/>
    
    <category term="bad-design" scheme="https://davyjones2010.github.io/tags/bad-design/"/>
    
    <category term="state-machine" scheme="https://davyjones2010.github.io/tags/state-machine/"/>
    
    <category term="lock" scheme="https://davyjones2010.github.io/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>一些有意思的记录-4</title>
    <link href="https://davyjones2010.github.io/2022-07-03-random-snippets/"/>
    <id>https://davyjones2010.github.io/2022-07-03-random-snippets/</id>
    <published>2022-07-03T16:00:00.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<p>五看: 看趋势, 看市场, 看客户, 看竞争, 看自己.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;五看: 看趋势, 看市场, 看客户, 看竞争, 看自己.&lt;/p&gt;
</summary>
    
    
    
    
    <category term="soft-skills" scheme="https://davyjones2010.github.io/tags/soft-skills/"/>
    
  </entry>
  
  <entry>
    <title>记一次Dubbo应用性能优化</title>
    <link href="https://davyjones2010.github.io/2022-07-02-dubbo-app-perf-tunning/"/>
    <id>https://davyjones2010.github.io/2022-07-02-dubbo-app-perf-tunning/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>新的应用以dubbo接口对外暴露调度能力。<br>在上线前需要整体压测，确认下系统能力与瓶颈。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>目标QPS: 500+<br>目标RT: 100ms-</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042216549.png"></p><h2 id="应用框架"><a href="#应用框架" class="headerlink" title="应用框架"></a>应用框架</h2><ul><li>SpringBoot 2.5.6</li><li>Druid 1.1.22</li></ul><h2 id="机器配置清单"><a href="#机器配置清单" class="headerlink" title="机器配置清单"></a>机器配置清单</h2><ul><li>ECS规格： ecs.n4.2xlarge</li><li>2台8C16G 独享型</li><li>CPU: 2.5 GHz主频的Intel ® Xeon ®处理器</li><li>JDK 1.8</li><li>网络： 1.2Gbps，即至少支持100MB&#x2F;s的内网带宽</li></ul><h2 id="中间件配置清单"><a href="#中间件配置清单" class="headerlink" title="中间件配置清单"></a>中间件配置清单</h2><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>规格：8C32GB</li><li>支持的最大连接数量：30000</li><li>Host到Redis的Ping延时在1ms以内</li></ul><h3 id="DB-x2F-RDS"><a href="#DB-x2F-RDS" class="headerlink" title="DB&#x2F;RDS"></a>DB&#x2F;RDS</h3><ul><li>规格：mysql.x4.4xlarge.2 32C128GB</li><li>MySQL 5.7</li><li>支持的最大连接数量：20000</li><li>Host到DB的Ping延时在1ms以内</li></ul><h1 id="压测记录"><a href="#压测记录" class="headerlink" title="压测记录"></a>压测记录</h1><h2 id="第一轮压测"><a href="#第一轮压测" class="headerlink" title="第一轮压测"></a>第一轮压测</h2><h3 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h3><ul><li>压到140QPS时， RT已经飙升到8s+；</li></ul><h3 id="其他指标"><a href="#其他指标" class="headerlink" title="其他指标"></a>其他指标</h3><ul><li>cpu: 已经基本跑满了，利用率780+%；</li><li>mem: 内存占用量很低，总体稳定在34%左右。</li><li>网络： 总体入流量在10Mbps以下，出流量1Mbps以下，远远没有打到带宽上限。</li><li>磁盘： 没有频繁的磁盘IO</li><li>Java: 没有发生频繁的GC。</li></ul><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>根据应用日志，发现有如下几个问题：</p><ul><li>Redis访问<ul><li>单次schedule()请求，会连续串行调用40+次的redis get接口。</li><li>这些串行的get调用，加起来平均耗时在6s+</li></ul></li><li>其他问题：<ul><li>apache.util中Pair类型序列化问题</li></ul></li></ul><h3 id="Redis访问速度慢问题分析"><a href="#Redis访问速度慢问题分析" class="headerlink" title="Redis访问速度慢问题分析"></a>Redis访问速度慢问题分析</h3><h4 id="是否是服务端问题？"><a href="#是否是服务端问题？" class="headerlink" title="是否是服务端问题？"></a>是否是服务端问题？</h4><p>查看了Redis服务端整体性能情况：</p><ul><li>出口帶寬爲100MB，當時只利用了10%左右</li><li>CPU Usage 14% 左右</li><li>連接數：最大支持30000，當時只有3個穩定的連接</li><li>QPS: 高峯期QPS爲6000，而實例的max爲24w，使用率僅爲2.5%，遠遠沒有達到限流閾值</li></ul><h4 id="是否是客户端问题？"><a href="#是否是客户端问题？" class="headerlink" title="是否是客户端问题？"></a>是否是客户端问题？</h4><ul><li>網絡流量：10MB左右，遠遠沒有打滿。</li><li>Load: 很低，0.2以下</li></ul><h4 id="問題定位"><a href="#問題定位" class="headerlink" title="問題定位"></a>問題定位</h4><p>在這種情況下，一般就只能懷疑是client連接問題。類似HttpClient，客戶端請求都在排隊等着獲取connection。</p><ul><li>方案1： 增大連接池配置，增大最大連接數量。</li><li>方案2： 減少請求次數</li></ul><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>Redis优化：<ul><li>采用了方案2： 使用Redis的mget，而不是单个get。以减少网络交互</li><li>为啥没采用方案1？ <blockquote><p>因为 SpringBoot 1.5.x 版本默认使用Jedis作为redis client，比较好调整connection数量等。<br/><br>但 SpringBoot 2.x 版本默认使用了Lettuce作为redis client，本身基于Netty的异步IO方式实现，与Jedis不同，本身就支持单个连接被多个线程同时访问。<br>所以官方不建议配置连接池。</p></blockquote></li></ul></li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042214249.png"></p><ul><li>其他问题优化<ul><li>自己重新实现了一版Pair类型的序列化、反序列化方式</li></ul></li></ul><h2 id="第二轮压测"><a href="#第二轮压测" class="headerlink" title="第二轮压测"></a>第二轮压测</h2><h3 id="压测结果-1"><a href="#压测结果-1" class="headerlink" title="压测结果"></a>压测结果</h3><ul><li>在250QPS时，RT基本稳定在100ms以下</li><li>压到300QPS时，RT突然飙升到3s+</li><li>cpu利用率较低</li><li>内存占用量很低，总体稳定在34%左右</li><li>没有发生GC</li></ul><h3 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h3><p>根据日志打点，很容易找到当时的瓶颈就在ram-client调用鉴权服务鉴权上。</p><ul><li>RAM接口问题：</li></ul><h3 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>RAM Client优化：<ul><li>增大client的max-connections数量，增大到300。</li></ul></li></ul><blockquote><p>这里有个插曲，当增大client的max-connections数量到300之后，重新进行了一次压测，发现QPS并没有提升，RT的瓶颈仍然在访问RAM上！ <br/><br>后续看了ram-client的发布记录，发现属于ram-client的一个bug。<br/><br>ram-client使用了http-client作为内部实现。<br/><br>当前版本中，增大max-connections数量，只是增大了httpclient全局支持的connection数量，而单个host支持的connection数量仍然是默认值，即8. <br/><br>由于访问ram的endpoint就是单个host，因此相当于该配置没有生效！ <br/><br>后续升级了ram-client版本，新版本实现里，将max-connections值同时赋给了max-connections-per-host，因此相当于max-connections-per-host也被调大为300了<br/><br>关于max-connections与max-connections-per-host参数的详细解释，参见： <a href="https://davyjones2010.github.io/2022-03-15-http-client-netty/">异步HttpClient使用Netty作为SocketChannel的Provider</a></p></blockquote><h2 id="第三轮压测"><a href="#第三轮压测" class="headerlink" title="第三轮压测"></a>第三轮压测</h2><h3 id="压测结果-2"><a href="#压测结果-2" class="headerlink" title="压测结果"></a>压测结果</h3><ul><li><p>200QPS, 80ms RT</p></li><li><p>300QPS，2000ms RT</p></li><li><p>结果与上轮相比，并没有显著提升。</p></li><li><p>根据日志分析，ramclient耗时已经趋于平稳，平均10ms以下，调度耗时又上来了。</p></li></ul><h3 id="其他指标-1"><a href="#其他指标-1" class="headerlink" title="其他指标"></a>其他指标</h3><ul><li>cpu: 利用率较高，780%+</li><li>mem: 内存占用量很低，总体稳定在34%左右。</li><li>网络： 总体流量在10Mbps，远远没有打到带宽上限。</li><li>磁盘： 没有频繁的磁盘IO</li><li>Java: 没有发生频繁的GC。</li></ul><h3 id="原因分析-2"><a href="#原因分析-2" class="headerlink" title="原因分析"></a>原因分析</h3><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042215103.png"><br>根据当时的线程堆栈分析，占用CPU量最大的就是8个lettuce线程，几乎把CPU时间片占满了。<br>同时搜索了相关问题 ，发现<a href="https://gitter.im/lettuce-io/Lobby?at=5de8f93446397c721c8ed8ed">不是个例</a>。<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042215636.png"></p><h3 id="优化方案-2"><a href="#优化方案-2" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>Redis:<ul><li>使用Jedis作为Client，并且调大Jedis对应的连接池数量</li></ul></li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">spring.redis.client-type</span><span class="token punctuation">=</span><span class="token value attr-value">jedis</span><span class="token key attr-name">spring.redis.jedis.pool.max-active</span><span class="token punctuation">=</span><span class="token value attr-value">100</span><span class="token key attr-name">spring.redis.jedis.pool.max-idle</span><span class="token punctuation">=</span><span class="token value attr-value">16</span><span class="token key attr-name">spring.redis.jedis.pool.max-wait</span><span class="token punctuation">=</span><span class="token value attr-value">10000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="第四轮压测"><a href="#第四轮压测" class="headerlink" title="第四轮压测"></a>第四轮压测</h2><h3 id="压测结果-3"><a href="#压测结果-3" class="headerlink" title="压测结果"></a>压测结果</h3><ul><li>300QPS，100ms RT</li><li>350QPS，200ms RT</li><li>400QPS，2000ms RT</li></ul><h3 id="其他指标-2"><a href="#其他指标-2" class="headerlink" title="其他指标"></a>其他指标</h3><ul><li>cpu: 利用率较高，780%+</li><li>mem: 内存占用量很低，总体稳定在34%左右。</li><li>网络： 总体流量在10Mbps，远远没有打到带宽上限。</li><li>磁盘： 没有频繁的磁盘IO</li><li>Java: 没有发生频繁的GC。</li></ul><h3 id="原因分析-3"><a href="#原因分析-3" class="headerlink" title="原因分析"></a>原因分析</h3><p>打印出了当时的线程栈信息，进行了详细的分析如下：</p><table><thead><tr><th>操作</th><th>线程数量</th></tr></thead><tbody><tr><td>獲取Druid連接</td><td>442</td></tr><tr><td>歸還Druid連接</td><td>164</td></tr><tr><td>業務線程中Bind操作</td><td>107</td></tr><tr><td>Log4j打印</td><td>77</td></tr><tr><td>Jedis執行</td><td>2</td></tr></tbody></table><ul><li>大部分线程卡在Druid数据库连接池归还连接、获取连接的搶鎖阶段（lock()）</li><li>小部分线程由于bind()异步线程池队列满，导致占用了业务线程</li><li>最后一部分线程卡（blocked）在log4j打印日志</li></ul><h4 id="Druid连接池问题"><a href="#Druid连接池问题" class="headerlink" title="Druid连接池问题"></a>Druid连接池问题</h4><p>與 <a href="https://blog.csdn.net/beFocused/article/details/108533137">记一次Dubbo线程耗尽的问题-druid数据库连接池突发性能</a> 文中的問題一模一樣。</p><h4 id="异步线程队列满问题"><a href="#异步线程队列满问题" class="headerlink" title="异步线程队列满问题"></a>异步线程队列满问题</h4><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042216269.png"></p><p>隊列默認長度爲200，在200的長度滿了之後，使用的是<code>ThreadPoolExecutor.CallerRunsPolicy</code>, 即不再在異步線程裏執行，而是在caller線程中執行。<br>從而導致業務線程壓力進一步增大。</p><h4 id="Log4j日志问题"><a href="#Log4j日志问题" class="headerlink" title="Log4j日志问题"></a>Log4j日志问题</h4><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042216085.png"><br>也是比較經典的問題，使用Log2j的異步logger即可解決。</p><h3 id="优化方案-3"><a href="#优化方案-3" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li><p>Druid优化： </p><ul><li>增大连接池中initial与max的连接数量</li><li>使用非公平锁，而不是默认的公平锁。具体参见<a href="https://mp.weixin.qq.com/s/RaiU9_ioWHvomZLLKuSuGw">有赞的压测记录</a>。<pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">spring.datasource.druid.maxActive</span><span class="token punctuation">=</span><span class="token value attr-value">600</span><span class="token key attr-name">spring.datasource.druid.initialSize</span><span class="token punctuation">=</span><span class="token value attr-value">300</span><span class="token key attr-name">spring.datasource.druid.maxWait</span><span class="token punctuation">=</span><span class="token value attr-value">6000</span><span class="token key attr-name">spring.datasource.druid.minIdle</span><span class="token punctuation">=</span><span class="token value attr-value">300</span><span class="token key attr-name">spring.datasource.druid.poolPreparedStatements</span><span class="token punctuation">=</span><span class="token value attr-value">true</span><span class="token key attr-name">spring.datasource.druid.maxOpenPreparedStatements</span><span class="token punctuation">=</span><span class="token value attr-value">20</span><span class="token key attr-name">spring.datasource.druid.useUnfairLock</span><span class="token punctuation">=</span><span class="token value attr-value">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>bind线程池优化：</p><ul><li>增大队列大小，从200增大到20000</li></ul></li><li><p>log4j优化：</p><ul><li>使用log4j2的asyncLogger。</li></ul></li></ul><h2 id="第五轮压测"><a href="#第五轮压测" class="headerlink" title="第五轮压测"></a>第五轮压测</h2><h3 id="压测结果-4"><a href="#压测结果-4" class="headerlink" title="压测结果"></a>压测结果</h3><ul><li>在600QPS时，RT基本稳定在40ms以下。</li><li>由于每次调用接口，都会调用一次ram鉴权接口，ram整体限制单个租户需要小于600qps；也担心把ram接口打挂或者被ram限流，因此不再继续压测。</li><li>按照其他指标推测，<mark> 理论上可以打到1000QPS+，即单机500QPS+ </mark></li><li>终于达标了！~ 撒花庆祝~~~</li></ul><h3 id="其他指标-3"><a href="#其他指标-3" class="headerlink" title="其他指标"></a>其他指标</h3><ul><li>cpu: 利用率较低，400%左右</li><li>mem: 内存占用量很低，总体稳定在34%左右。</li><li>网络： 总体流量在10Mbps，远远没有打到带宽上限。</li><li>磁盘： 没有频繁的磁盘IO</li><li>Java: 没有发生频繁的GC。</li></ul><h1 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;新的应用以dubbo接口对外暴露调度能力。&lt;br&gt;在上线前需要整体压测，确认下系统能力与瓶颈。&lt;/p&gt;
&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;p&gt;目标QPS: 500+&lt;br&gt;目标RT: 100ms-&lt;/p&gt;
&lt;h2 id=&quot;整体架构&quot;&gt;&lt;a href=&quot;#整体架构&quot; class=&quot;headerlink&quot; title=&quot;整体架构&quot;&gt;&lt;/a&gt;整体架构&lt;/h2&gt;&lt;p&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042216549.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;应用框架&quot;&gt;&lt;a href=&quot;#应用框架&quot; class=&quot;headerlink&quot; title=&quot;应用框架&quot;&gt;&lt;/a&gt;应用框架&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SpringBoot 2.5.6&lt;/li&gt;
&lt;li&gt;Druid 1.1.22&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;机器配置清单&quot;&gt;&lt;a href=&quot;#机器配置清单&quot; class=&quot;headerlink&quot; title=&quot;机器配置清单&quot;&gt;&lt;/a&gt;机器配置清单&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ECS规格： ecs.n4.2xlarge&lt;/li&gt;
&lt;li&gt;2台8C16G 独享型&lt;/li&gt;
&lt;li&gt;CPU: 2.5 GHz主频的Intel ® Xeon ®处理器&lt;/li&gt;
&lt;li&gt;JDK 1.8&lt;/li&gt;
&lt;li&gt;网络： 1.2Gbps，即至少支持100MB&amp;#x2F;s的内网带宽&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://davyjones2010.github.io/tags/java/"/>
    
    <category term="dubbo" scheme="https://davyjones2010.github.io/tags/dubbo/"/>
    
    <category term="perf-tunning" scheme="https://davyjones2010.github.io/tags/perf-tunning/"/>
    
    <category term="redis" scheme="https://davyjones2010.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java&amp;JVM&amp;OQL 常用命令与脚本总结</title>
    <link href="https://davyjones2010.github.io/2022-07-01-java-jvm/"/>
    <id>https://davyjones2010.github.io/2022-07-01-java-jvm/</id>
    <published>2022-07-01T16:00:00.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-amp-JVM"><a href="#Java-amp-JVM" class="headerlink" title="Java&amp;JVM"></a>Java&amp;JVM</h1><h2 id="打-HeapDump"><a href="#打-HeapDump" class="headerlink" title="打 HeapDump"></a>打 HeapDump</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jmap -dump:live,file<span class="token operator">=</span>heapdump.phrof <span class="token variable">$pid</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jmap -dump:live,file<span class="token operator">=</span>heapdump.phrof -F <span class="token variable">$pid</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>一般情况下，<mark>尽量不要使用-F参数。</mark> 因为-F使用的是Linux操作系统层面的实现，而不是JVM层面的实现，会导致 打印堆信息很慢。<br/><br>如果提示第一种方式打印不出来堆的信息，需要增加-F，那么可以先检查下：</p><ol><li>Java应用进程的user_name是否与当前的user_name相同？ 如果不同，需要切换为同一个账号。</li><li>Java应用进程的Java路径是否与当前jmap命令的路径相同？ 如果不同，需要切换为同一个路径。</li></ol></blockquote><h2 id="打-ThreadDump"><a href="#打-ThreadDump" class="headerlink" title="打 ThreadDump"></a>打 ThreadDump</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">jstack <span class="token variable">$pid</span> <span class="token operator">></span> tmp.jstack<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意: 当CPU利用率高或者想看下线程卡在哪里时，<mark>最好隔几秒就打一个线程栈，每个线程栈都保留下来</mark> <br/><br>多个线程栈对比起来看，会更能更好地发现问题。</p></blockquote><h2 id="查看消耗CPU时间片最多的线程信息"><a href="#查看消耗CPU时间片最多的线程信息" class="headerlink" title="查看消耗CPU时间片最多的线程信息"></a>查看消耗CPU时间片最多的线程信息</h2><p>需要与ThreadDump一起使用，才能定位到具体是Java中哪个线程。</p><ol><li>查看消耗cpu时间片最多的进程号<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 查看瞬时消耗CPU，倒序排列<span class="token function">top</span> -o %CPU// 查看累计消耗CPU时间片，倒序排列<span class="token function">top</span> -o TIME+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ <span class="token function">top</span> -o %CPU<span class="token function">top</span> - <span class="token number">21</span>:39:35 up <span class="token number">10</span>:52,  <span class="token number">1</span> user,  load average: <span class="token number">1.47</span>, <span class="token number">1.36</span>, <span class="token number">1.14</span>Tasks: <span class="token number">325</span> total,   <span class="token number">4</span> running, <span class="token number">320</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">1</span> zombie%Cpu0  <span class="token builtin class-name">:</span>  <span class="token number">8.2</span> us,  <span class="token number">4.1</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">87.4</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.3</span> si,  <span class="token number">0.0</span> st%Cpu1  <span class="token builtin class-name">:</span>  <span class="token number">7.5</span> us,  <span class="token number">3.8</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">88.7</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> st%Cpu2  <span class="token builtin class-name">:</span> <span class="token number">11.6</span> us,  <span class="token number">2.7</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">85.4</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.3</span> si,  <span class="token number">0.0</span> st%Cpu3  <span class="token builtin class-name">:</span>  <span class="token number">8.4</span> us,  <span class="token number">3.0</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">88.6</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.0</span> si,  <span class="token number">0.0</span> stMiB Mem <span class="token builtin class-name">:</span>   <span class="token number">7823.4</span> total,    <span class="token number">172.0</span> free,   <span class="token number">5254.4</span> used,   <span class="token number">2397.0</span> buff/cacheMiB Swap:   <span class="token number">2048.0</span> total,    <span class="token number">252.2</span> free,   <span class="token number">1795.7</span> used.   <span class="token number">1107.3</span> avail Mem     PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                         <span class="token number">2318</span> davywal+  <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">5178536</span> <span class="token number">247920</span>  <span class="token number">52372</span> R  <span class="token number">12.5</span>   <span class="token number">3.1</span>  <span class="token number">24</span>:33.00 gnome-shell                                     <span class="token number">2099</span> davywal+  <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">1008428</span> <span class="token number">112204</span>  <span class="token number">78172</span> R  <span class="token number">11.2</span>   <span class="token number">1.4</span>  <span class="token number">23</span>:31.71 Xorg                                            <span class="token number">6521</span> davywal+  <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">868244</span>  <span class="token number">35580</span>  <span class="token number">23924</span> R   <span class="token number">5.9</span>   <span class="token number">0.4</span>   <span class="token number">0</span>:38.61 gnome-terminal-                                 <span class="token number">5308</span> davywal+  <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">6370752</span> <span class="token number">517952</span> <span class="token number">219108</span> S   <span class="token number">2.6</span>   <span class="token number">6.5</span>  <span class="token number">39</span>:38.79 firefox                                      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>查看进程下消耗时间片最多的线程号</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">top</span> -Hp <span class="token variable">$pid</span> -o %CPU<span class="token function">top</span> -Hp <span class="token variable">$pid</span> -o TIME+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ <span class="token function">top</span> -Hp <span class="token number">2318</span><span class="token function">top</span> - <span class="token number">21</span>:42:00 up <span class="token number">10</span>:55,  <span class="token number">1</span> user,  load average: <span class="token number">1.08</span>, <span class="token number">1.38</span>, <span class="token number">1.19</span>Threads:  <span class="token number">15</span> total,   <span class="token number">0</span> running,  <span class="token number">15</span> sleeping,   <span class="token number">0</span> stopped,   <span class="token number">0</span> zombie%Cpu<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:  <span class="token number">5.7</span> us,  <span class="token number">1.9</span> sy,  <span class="token number">0.0</span> ni, <span class="token number">92.3</span> id,  <span class="token number">0.0</span> wa,  <span class="token number">0.0</span> hi,  <span class="token number">0.1</span> si,  <span class="token number">0.0</span> stMiB Mem <span class="token builtin class-name">:</span>   <span class="token number">7823.4</span> total,    <span class="token number">158.1</span> free,   <span class="token number">5264.5</span> used,   <span class="token number">2400.9</span> buff/cacheMiB Swap:   <span class="token number">2048.0</span> total,    <span class="token number">250.8</span> free,   <span class="token number">1797.2</span> used.   <span class="token number">1092.3</span> avail Mem     PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                         <span class="token number">2318</span> davywal+  <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">5178588</span> <span class="token number">247724</span>  <span class="token number">52288</span> S   <span class="token number">5.7</span>   <span class="token number">3.1</span>  <span class="token number">24</span>:28.42 gnome-shell                                     <span class="token number">2331</span> davywal+  <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">5178588</span> <span class="token number">247724</span>  <span class="token number">52288</span> S   <span class="token number">0.0</span>   <span class="token number">3.1</span>   <span class="token number">0</span>:00.34 gmain                                           <span class="token number">2335</span> davywal+  <span class="token number">20</span>   <span class="token number">0</span> <span class="token number">5178588</span> <span class="token number">247724</span>  <span class="token number">52288</span> S   <span class="token number">0.0</span>   <span class="token number">3.1</span>   <span class="token number">0</span>:11.10 gdbus                                        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>将10进制转成16进制<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">printf</span> <span class="token string">'%x\n'</span> <span class="token environment constant">$PPID</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// <span class="token number">10</span>进制转成16进制davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ <span class="token builtin class-name">printf</span> <span class="token string">'%x\n'</span> <span class="token number">2318</span>90e// <span class="token number">16</span>进制转成10进制davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ <span class="token builtin class-name">printf</span> <span class="token string">'%d\n'</span> 0x90e<span class="token number">2318</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>查看jstack中对应的线程信息</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">fgrep</span> <span class="token string">"0x90e"</span> tmp.jstack -C <span class="token number">50</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查看JVM默认HeapSize"><a href="#查看JVM默认HeapSize" class="headerlink" title="查看JVM默认HeapSize"></a>查看JVM默认HeapSize</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">java -XX:+PrintFlagsFinal -version <span class="token operator">|</span> <span class="token function">fgrep</span> HeapSize// 查看java_home, class_path等默认配置与系统环境变量java -XshowSettings:all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>如下，默认HeapSize为130023424&#x2F;1024&#x2F;1024&#x3D;124MB<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ java -XX:+PrintFlagsFinal -version <span class="token operator">|</span> <span class="token function">fgrep</span> HeapSize    uintx ErgoHeapSizeLimit                         <span class="token operator">=</span> <span class="token number">0</span>                                   <span class="token punctuation">&#123;</span>product<span class="token punctuation">&#125;</span>    uintx HeapSizePerGCThread                       <span class="token operator">=</span> <span class="token number">87241520</span>                            <span class="token punctuation">&#123;</span>product<span class="token punctuation">&#125;</span>    uintx InitialHeapSize                          :<span class="token operator">=</span> <span class="token number">130023424</span>                           <span class="token punctuation">&#123;</span>product<span class="token punctuation">&#125;</span>    uintx LargePageHeapSizeThreshold                <span class="token operator">=</span> <span class="token number">134217728</span>                           <span class="token punctuation">&#123;</span>product<span class="token punctuation">&#125;</span>    uintx MaxHeapSize                              :<span class="token operator">=</span> <span class="token number">2051014656</span>                          <span class="token punctuation">&#123;</span>product<span class="token punctuation">&#125;</span>openjdk version <span class="token string">"1.8.0_312"</span>OpenJDK Runtime Environment <span class="token punctuation">(</span>build <span class="token number">1.8</span>.0_312-8u312-b07-0ubuntu1~20.04-b07<span class="token punctuation">)</span>OpenJDK <span class="token number">64</span>-Bit Server VM <span class="token punctuation">(</span>build <span class="token number">25.312</span>-b07, mixed mode<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ java -XshowSettings:allVM settings:    Max. Heap Size <span class="token punctuation">(</span>Estimated<span class="token punctuation">)</span>: <span class="token number">1</span>.70G    Ergonomics Machine Class: server    Using VM: OpenJDK <span class="token number">64</span>-Bit Server VMProperty settings:    awt.toolkit <span class="token operator">=</span> sun.awt.X11.XToolkit    file.encoding <span class="token operator">=</span> UTF-8    file.encoding.pkg <span class="token operator">=</span> sun.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="OQL"><a href="#OQL" class="headerlink" title="OQL"></a>OQL</h1><ul><li><p><a href="https://wiki.eclipse.org/MemoryAnalyzer/OQL">如何使用OQL</a></p></li><li><p>查询某规格类的对象</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> edu<span class="token punctuation">.</span>xmu<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>UserServiceImpl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询对象某个属性(这里只能根据类, 查到该类下所有对象的属性)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> t<span class="token punctuation">.</span>initd<span class="token punctuation">,</span> t<span class="token punctuation">.</span>initAsyn<span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>publicCloud<span class="token punctuation">)</span><span class="token punctuation">,</span> namespace<span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>regionId<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>useNuwa<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>nuwaConfigDns<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>nuwaCluster<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>rootPath<span class="token punctuation">)</span> <span class="token keyword">FROM</span> edu<span class="token punctuation">.</span>xmu<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>UserServiceImpl t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询对象某个属性(如何根据对象ID, 精确查询到该对象的某些属性?)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> t<span class="token punctuation">.</span>initd<span class="token punctuation">,</span> t<span class="token punctuation">.</span>initAsyn<span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>publicCloud<span class="token punctuation">)</span><span class="token punctuation">,</span> namespace<span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>regionId<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>useNuwa<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>nuwaConfigDns<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>nuwaCluster<span class="token punctuation">)</span><span class="token punctuation">,</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>rootPath<span class="token punctuation">)</span> <span class="token keyword">FROM</span> OBJECTS <span class="token number">0x7480633e0</span> t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>根据类的hash地址, 获取对应实例</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> instanceof <span class="token number">0x733ccc9f0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>根据对象hash值获取对象信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span>  OBJECTS <span class="token number">0xdc2819e0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>根据条件筛选出对象信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> edu<span class="token punctuation">.</span>xmu<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>UserServiceImpl t <span class="token keyword">where</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>hostType<span class="token punctuation">)</span><span class="token operator">=</span><span class="token string">"ddh.ebmec3metest"</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> edu<span class="token punctuation">.</span>xmu<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>UserServiceImpl t <span class="token keyword">where</span> toString<span class="token punctuation">(</span>t<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token operator">=</span><span class="token string">"28745-27"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java-amp-JVM&quot;&gt;&lt;a href=&quot;#Java-amp-JVM&quot; class=&quot;headerlink&quot; title=&quot;Java&amp;amp;JVM&quot;&gt;&lt;/a&gt;Java&amp;amp;JVM&lt;/h1&gt;&lt;h2 id=&quot;打-HeapDump&quot;&gt;&lt;a href=&quot;#打-HeapDump&quot; class=&quot;headerlink&quot; title=&quot;打 HeapDump&quot;&gt;&lt;/a&gt;打 HeapDump&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;jmap -dump:live,file&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;heapdump.phrof &lt;span class=&quot;token variable&quot;&gt;$pid&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;jmap -dump:live,file&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;heapdump.phrof -F &lt;span class=&quot;token variable&quot;&gt;$pid&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;一般情况下，&lt;mark&gt;尽量不要使用-F参数。&lt;/mark&gt; 因为-F使用的是Linux操作系统层面的实现，而不是JVM层面的实现，会导致 打印堆信息很慢。&lt;br&gt;&lt;br&gt;如果提示第一种方式打印不出来堆的信息，需要增加-F，那么可以先检查下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java应用进程的user_name是否与当前的user_name相同？ 如果不同，需要切换为同一个账号。&lt;/li&gt;
&lt;li&gt;Java应用进程的Java路径是否与当前jmap命令的路径相同？ 如果不同，需要切换为同一个路径。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;打-ThreadDump&quot;&gt;&lt;a href=&quot;#打-ThreadDump&quot; class=&quot;headerlink&quot; title=&quot;打 ThreadDump&quot;&gt;&lt;/a&gt;打 ThreadDump&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;jstack &lt;span class=&quot;token variable&quot;&gt;$pid&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; tmp.jstack&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意: 当CPU利用率高或者想看下线程卡在哪里时，&lt;mark&gt;最好隔几秒就打一个线程栈，每个线程栈都保留下来&lt;/mark&gt; &lt;br&gt;&lt;br&gt;多个线程栈对比起来看，会更能更好地发现问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;查看消耗CPU时间片最多的线程信息&quot;&gt;&lt;a href=&quot;#查看消耗CPU时间片最多的线程信息&quot; class=&quot;headerlink&quot; title=&quot;查看消耗CPU时间片最多的线程信息&quot;&gt;&lt;/a&gt;查看消耗CPU时间片最多的线程信息&lt;/h2&gt;</summary>
    
    
    
    
    <category term="code-snippets" scheme="https://davyjones2010.github.io/tags/code-snippets/"/>
    
    <category term="java" scheme="https://davyjones2010.github.io/tags/java/"/>
    
    <category term="jvm" scheme="https://davyjones2010.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络之原理探讨与疑问总结</title>
    <link href="https://davyjones2010.github.io/2022-06-29-linux-network-faq/"/>
    <id>https://davyjones2010.github.io/2022-06-29-linux-network-faq/</id>
    <published>2022-06-29T16:00:00.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="网卡混杂模式"><a href="#网卡混杂模式" class="headerlink" title="网卡混杂模式"></a>网卡混杂模式</h2><ul><li><p>啥是网卡混杂模式？</p></li><li><p>正常情况下，在网卡收到二层帧之后，会查看TargetMac是否与自身的Mac地址相同，如果不同，则丢弃该帧。</p></li><li><p>开启了混杂模式之后，即使MAC地址不匹配，也不会丢弃。还是会进入TCP&#x2F;IP协议栈处理。</p></li><li><p>啥时候需要开启？</p></li><li><p>&#x2F;&#x2F; TODO:</p></li><li><p>如何开启？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// 开启混杂模式<span class="token function">ifconfig</span> eth0 promisc// 取消混杂模式<span class="token function">ifconfig</span> eth0 -promisc// 内核判断网卡是否处于混杂模式是看如下标识，如果置位了0x100，则处于混杂模式<span class="token function">cat</span> /sys/class/net/eth0/flags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>是否开启了混杂模式，就能嗅探局域网（二层网）内的所有数据包了？</p></li><li><p>不一定。</p></li><li><p>针对二层如果是集线器模式，可以嗅探到。</p></li><li><p>但现在大部分二层都是交换机模式。即交换机会根据CAM表，往对应的端口转发，不会无脑地全部端口都转发，因此嗅探不到。</p></li><li><p>开启混杂模式的例子</p></li><li><p>如下，docker0网桥就开启了混杂模式。</p></li><li><p>&#x2F;&#x2F; TODO: 为啥docker0网桥开启混杂模式？具体怎么用的？</p></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ <span class="token function">cat</span> /sys/class/net/docker0/flags 0x1003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="路由器与NAT设备的关联与区别"><a href="#路由器与NAT设备的关联与区别" class="headerlink" title="路由器与NAT设备的关联与区别"></a>路由器与NAT设备的关联与区别</h2><h3 id="路由器工作原理："><a href="#路由器工作原理：" class="headerlink" title="路由器工作原理："></a>路由器工作原理：</h3><p>主要用来联通连个不同的网段，<mark>只修改sourceMac与targetMac，不修改sourceIp与targetIp</mark></p><ol><li>根据传入包指定的targetIp（传入包的MAC地址是路由器当前网卡的MAC地址，IP地址是真正的IP地址）</li><li>查询自身路由表，查找到最近的下一跳的IP地址。<code>route -n</code></li><li>再根据下一跳的IP地址，查找到对应的MAC地址。arp缓存表</li><li>修改数据包的targetMAC地址为下一跳的MAC地址，sourceMAC为当前网卡出口的mac地址</li><li>将数据包从对应网卡送出去。</li></ol><blockquote><p>路由器的核心是路由表的维护，能生成最短最优路径。<br/><br>从sourceIp到targetIp的路由路径，很可能与回包，即从targetIp返回到sourceIp的路由路径不一样。<br>取决于当时的路径中路由器的路由表情况。</p></blockquote><h3 id="NAT工作原理："><a href="#NAT工作原理：" class="headerlink" title="NAT工作原理："></a>NAT工作原理：</h3><ul><li><p>原理<br>需要修改sourceMac与targetMac。<br>同时如果是SNAT，则还要修改sourceIp。<br>如果是DNAT，则还要修改targetIp。</p></li><li><p>实现方式:<br>通过iptables可以设置nat表。<br>snat作用在postrouting阶段，dnat作用在prerouting阶段。<br>回包由内核的conntrack模块负责，不再由iptables负责。<br>详细参见 <a href="https://davyjones2010.github.io/2022-06-23-linux-network-nat">NAT之端口映射(PAT)原理总结&amp;实践</a></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由此可知，家用的路由器，是附带了SNAT（也可以配置DNAT）功能的路由器。</p><h2 id="ip-forwarding"><a href="#ip-forwarding" class="headerlink" title="ip_forwarding"></a>ip_forwarding</h2><h3 id="MAC地址匹配-但IP地址不匹配"><a href="#MAC地址匹配-但IP地址不匹配" class="headerlink" title="MAC地址匹配, 但IP地址不匹配"></a>MAC地址匹配, 但IP地址不匹配</h3><p>网卡会不会收到MAC地址与当前网卡MAC地址匹配, 但IP地址与当前网卡的IP不匹配的IP包?<br>具体咋处理? 直接丢弃? 还是可以使用?</p><ul><li>会收到。</li><li>如果开启了ip_forwarding，则会进入FORWARD&#x2F;ROUTE阶段，查看本地 route 表，进入路由与postrouting阶段，找到对应的出口网卡，将包转发出去。与路由器的功能完全一致了。</li><li>如果未开启ip_forwarding，则直接丢弃该包。</li><li>所以，NAT模式下，必须要开启ip_forwarding。</li></ul><h3 id="iptables工作原理图"><a href="#iptables工作原理图" class="headerlink" title="iptables工作原理图"></a>iptables工作原理图</h3><p>此图摘自 <a href="https://wiki.archlinux.org/title/Iptables">Archlinux 文档</a></p><pre class="line-numbers language-none"><code class="language-none">                               XXXXXXXXXXXXXXXXXX                             XXX     Network    XXX                               XXXXXXXXXXXXXXXXXX                                       +                                       |                                       v +-------------+              +------------------+ |table: filter| &lt;---+        | table: nat&#x2F;dnat  | |chain: INPUT |     |        | chain: PREROUTING| +-----+-------+     |        +--------+---------+       |             |                 |       v             |                 v [local process]     |           ****************          +--------------+       |             +---------+ Routing decision +------&gt; |table: filter |       v                         ****************          |chain: FORWARD|****************                                           +------+-------+Routing decision                                                  |****************                                                  |       |                                                          |       v                        ****************                  |+-------------+       +------&gt;  Routing decision  &lt;---------------+|table: nat   |       |         ****************|chain: OUTPUT|       |               ++-----+-------+       |               |      |               |               v      v               |      +-------------------++--------------+      |      | table: nat&#x2F;snat   ||table: filter | +----+      | chain: POSTROUTING||chain: OUTPUT |             +--------+----------++--------------+                      |                                      v                               XXXXXXXXXXXXXXXXXX                             XXX    Network     XXX                               XXXXXXXXXXXXXXXXXX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="为啥Linux默认不开启ip-forwarding"><a href="#为啥Linux默认不开启ip-forwarding" class="headerlink" title="为啥Linux默认不开启ip_forwarding?"></a>为啥Linux默认不开启ip_forwarding?</h3><p>因为在默认情况下，host只是扮演在网络中的一台主机的角色，根本不需要ip_forwarding的功能。</p><blockquote><p>A Linux machine acting as an ordinary host would not need to have IP forwarding enabled,<br>because it just generates and receives IP traffic for its own purposes</p></blockquote><h3 id="如何开启ip-forwarding"><a href="#如何开启ip-forwarding" class="headerlink" title="如何开启ip_forwarding?"></a>如何开启ip_forwarding?</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token number">1</span> <span class="token operator">></span> /proc/sys/net/ipv4/ip_forward<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>所以开启了ip_forwarding，相当于本机就具备一台路由器的能力了。<br/><br>如果再通过iptables配置了相应的nat规则，就相当于一台家用的路由器了。</p><h2 id="本地多网卡curl公网地址问题"><a href="#本地多网卡curl公网地址问题" class="headerlink" title="本地多网卡curl公网地址问题"></a>本地多网卡curl公网地址问题</h2><ul><li>如果本机有私网网卡virbr0, 公网网卡en0, 且开启了virbr0网段的SNAT规则. 则在本地curl公网地址, 则curl的出口网卡是啥? </li><li>是通过virbr0, 然后走SNAT到en0出去么?</li><li>还是直接通过en0出去?</li></ul><ol><li><p>curl 支持指定出口网卡如下(实际只是使用了对应网卡的ip地址作为SIP): 如果不指定, 则使用默认网卡. </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">// curl指定网卡出口<span class="token function">curl</span> --interface virbr0 http://www.baidu.com// mac上查看默认网卡: route -n get <span class="token number">0.0</span>.0.0 <span class="token operator">|</span> <span class="token function">grep</span> interface<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>The –interface options is used to figure determine what address on the system will be used as the source IP. <br/><br>It doesn’t magically change anything about routing.</p></blockquote></li><li><p>参见<a href="#iptables%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE">iptables工作原理图</a>, 可知从curl公网地址, 就是从local process出去, 接下来会走route, 即查看Host的路由表, 确定出口网卡与网关信息.</p></li><li><p>接下来进入postrouting(SNAT)阶段, 如果配置有SNAT规则, 且刚好命中, 则执行SNAT.</p></li><li><p>所以结论是出口网卡是en0, 而不会经过virbr0(即使指定了<code>--interface virbr0</code>).</p></li><li><p>是否会SNAT, 取决于是否指定了<code>--interface virbr0</code>, 指定了, 则会走SNAT; 未指定, 则不需要走SNAT.</p></li></ol><h2 id="本地多网卡Java应用获取HostIp问题"><a href="#本地多网卡Java应用获取HostIp问题" class="headerlink" title="本地多网卡Java应用获取HostIp问题"></a>本地多网卡Java应用获取HostIp问题</h2><ul><li>如果本机有多块网卡, 在Java中如何获取到这些IP地址? </li><li>我们通常使用获取本机IP的方式如下: <mark>当Host多块网卡时, 不好兼容, 存在严重缺陷, 尤其是在线上服务器网卡堆叠场景下!</mark></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">InetAddress</span> ip <span class="token operator">=</span> <span class="token class-name">InetAddress</span><span class="token punctuation">.</span><span class="token function">getLocalHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> hostname <span class="token operator">=</span> ip<span class="token punctuation">.</span><span class="token function">getHostName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>解决方案: </li><li>方案1: 使用 <code>NetworkInterface.getNetworkInterfaces()</code> 接口, 获取所有网卡, 然后逐个获取IP信息.</li><li>方案2: 获取本机的FQDN, 然后使用<code>InetAddress.getByName(FQDN)</code>来获取主网卡的IP信息.<ul><li>本机的FQDN可以写在配置文件里.</li></ul></li><li>Ref: <a href="https://crunchify.com/how-to-get-server-ip-address-and-hostname-in-java/">How to get Server IP Address and Hostname in Java</a></li></ul><h2 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h2><h2 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h2><h3 id="LVS-v-s-iptables-x2F-netfilters"><a href="#LVS-v-s-iptables-x2F-netfilters" class="headerlink" title="LVS v.s. iptables&#x2F;netfilters"></a>LVS v.s. iptables&#x2F;netfilters</h3><p>本质上, 两个都可以做四层的DNAT, 都是工作在内核空间. </p><ul><li>LVS: 更侧重于LoadBalancing, 实现上使用hash查表, 而不是iptables的顺序查询. 效率更高. </li><li>iptables:</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207042336674.png"></p><ul><li>可以看到, LVS本质上是与iptables配合使用</li><li>客户访问虚拟 IP（VIP）时，数据包先在主机内核空间被 PREROUTING 链检测，根据数据包的目标地址进行路由判断，若目标地址是本地，则交由 INPUT 链进行处理。</li><li>IPVS 工作于 INPUT 链，当数据包到达 INPUT 链时，会先由 IPVS 进行检查，并根据负载均衡算法选出真实服务器 IP。</li><li>IPVS 转发模式为 NAT 模式时，将数据包由 FORWARD 链进行处理后由 POST-ROUTING 链发送给真实服务器。</li><li>IPVS 转发模式为非 NAT 模式时，则将数据包由 POST-ROUTING 链发送给真实服务器。</li></ul><h3 id="LVS的几种模式分析"><a href="#LVS的几种模式分析" class="headerlink" title="LVS的几种模式分析"></a>LVS的几种模式分析</h3><p><a href="https://blog.csdn.net/Splend520/article/details/104587149">linux LVS负载均衡原理 NAT DR TUN FULLNAT 模式</a></p><h4 id="LVS-NAT-–-gt-NAT-x2F-DNAT"><a href="#LVS-NAT-–-gt-NAT-x2F-DNAT" class="headerlink" title="LVS-NAT –&gt; NAT&#x2F;DNAT"></a>LVS-NAT –&gt; NAT&#x2F;DNAT</h4><p>本质是类似iptables的端口映射(PAT)–&gt; 注意这里全程没有DIP的参与.</p><ul><li>LVS本身有两个IP, 对外是VIP, 对内是DIP(Director IP)</li><li>Client请求: {CIP, VIP}</li><li>LVS映射: 修改目标IP, VIP-&gt;RIP, 构建新的请求: {CIP, RIP}</li><li>Server处理: 完成后发送回包, {RIP, CIP}; 由于CIP与RIP不在同一个网段, 因此发送到网关(即LVS)</li><li>LVS映射: 修改源IP, RIP-&gt;VIP, 构建新的响应: {VIP, CIP}</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207052223099.png"></p><ul><li>缺点: <ul><li>需要RS与DS在同一个二层网络里, 且需要把DS&#x2F;DIP配置为RS的网关.</li></ul></li><li>优点: <ul><li>&#x2F;&#x2F; TODO:</li></ul></li></ul><h4 id="LVS-NAT-–-gt-FullNAT"><a href="#LVS-NAT-–-gt-FullNAT" class="headerlink" title="LVS-NAT –&gt; FullNAT"></a>LVS-NAT –&gt; FullNAT</h4><ul><li>LVS本身有两个IP, 对外是VIP, 对内是DIP(Director IP)</li><li>Client请求: {CIP, VIP}</li><li>LVS映射: 修改目标IP, VIP-&gt;RIP(RealServerIP); 修改源IP, CIP-&gt;DIP; 构建新的请求: {DIP, RIP}</li><li>RealServer处理: 完成后发送回包, {RIP, DIP} (FullNAT模式, 不需要LVS必须是网关, 只要三层IP可达即可)</li><li>LVS映射: 修改源IP, RIP-&gt;VIP; 通过conntrack查表, 修改目标IP, DIP-&gt;CIP; 构建新的响应: {VIP, CIP}</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207052218872.png"></p><ul><li><p>注意: LVS 本身不支持 FULLNAT 模式，需要额外对内核打补丁后才能使用。</p></li><li><p>缺点: </p><ul><li>不管是请求数据包还是响应数据包，都要经过负载均衡器。但是响应数据包一般要比请求数据包大很多，这可能会成为系统的瓶颈。</li></ul></li><li><p>优点:</p><ul><li>如上图, RealServer(DIP)不需要跟LVS在同一个网段, 只要IP包(三层路由)可达, 就能完成FullNAT</li></ul></li></ul><h4 id="LVS-DR"><a href="#LVS-DR" class="headerlink" title="LVS-DR"></a>LVS-DR</h4><h4 id="LVS-TUN"><a href="#LVS-TUN" class="headerlink" title="LVS-TUN"></a>LVS-TUN</h4><h4 id="实际"><a href="#实际" class="headerlink" title="实际"></a>实际</h4><ul><li><a href="https://help.aliyun.com/document_detail/27544.html">阿里云CLB</a>使用的是哪种模式? NAT?<ul><li>四层采用开源软件LVS（Linux Virtual Server）+ keepalived的方式实现负载均衡</li><li>LVS应该使用的是NAT模式. 但如果是NAT模式, 则必须把LVS作为ECS的网关. &#x2F;&#x2F;TODO: 待验证</li></ul></li></ul><h1 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h1><h1 id="什么是”冷土豆路由”与”热土豆路由”"><a href="#什么是”冷土豆路由”与”热土豆路由”" class="headerlink" title="什么是”冷土豆路由”与”热土豆路由”?"></a>什么是”冷土豆路由”与”热土豆路由”?</h1><ul><li>参见: <a href="https://docs.microsoft.com/zh-cn/azure/virtual-network/ip-services/routing-preference-overview">冷土豆路由&amp;热土豆路由</a></li><li>热土豆:<ul><li>入口流量: 如果来自新加坡的用户访问托管在芝加哥的 Azure 资源，则流量将通过公共 Internet 传输，并进入芝加哥的 Microsoft 全球网络。</li><li>出口流量: 出口流量遵循相同的原则。 流量会在托管服务的同一区域退出 Microsoft 网络。 例如，如果来自 Azure 芝加哥服务的流量最终传输给来自新加坡的用户，流量将离开芝加哥的 Microsoft 网络，并通过公共 Internet 传输给新加坡的用户。</li></ul></li><li>冷土豆:<ul><li>入口流量: 如果来自新加坡的用户访问托管在美国芝加哥的 Azure 资源，则流量将进入位于新加坡 Edge POP 的 Microsoft 全球网络，并通过 Microsoft 网络传输到托管在芝加哥的服务。</li><li>出口流量: 如果来自 Azure 芝加哥的流量最终传输给来自新加坡的用户，那么流量就会通过 Microsoft 网络从芝加哥传输到新加坡，并退出位于新加坡 Edge POP 的 Microsoft 网络。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;h1 id=&quot;FAQ&quot;&gt;&lt;a href=&quot;#FAQ&quot; class=&quot;headerlink&quot; title=&quot;FAQ&quot;&gt;&lt;/a&gt;FAQ&lt;/h1&gt;&lt;h2 id=&quot;网卡混杂模式&quot;&gt;&lt;a href=&quot;#网卡混杂模式&quot; class=&quot;headerlink&quot; title=&quot;网卡混杂模式&quot;&gt;&lt;/a&gt;网卡混杂模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;啥是网卡混杂模式？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正常情况下，在网卡收到二层帧之后，会查看TargetMac是否与自身的Mac地址相同，如果不同，则丢弃该帧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开启了混杂模式之后，即使MAC地址不匹配，也不会丢弃。还是会进入TCP&amp;#x2F;IP协议栈处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;啥时候需要开启？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;#x2F;&amp;#x2F; TODO:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何开启？&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;// 开启混杂模式
&lt;span class=&quot;token function&quot;&gt;ifconfig&lt;/span&gt; eth0 promisc
// 取消混杂模式
&lt;span class=&quot;token function&quot;&gt;ifconfig&lt;/span&gt; eth0 -promisc
// 内核判断网卡是否处于混杂模式是看如下标识，如果置位了0x100，则处于混杂模式
&lt;span class=&quot;token function&quot;&gt;cat&lt;/span&gt; /sys/class/net/eth0/flags&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;是否开启了混杂模式，就能嗅探局域网（二层网）内的所有数据包了？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不一定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;针对二层如果是集线器模式，可以嗅探到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但现在大部分二层都是交换机模式。即交换机会根据CAM表，往对应的端口转发，不会无脑地全部端口都转发，因此嗅探不到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开启混杂模式的例子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如下，docker0网桥就开启了混杂模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;#x2F;&amp;#x2F; TODO: 为啥docker0网桥开启混杂模式？具体怎么用的？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;davywalker@davywalker-ThinkPad-X1-Carbon-4th:~$ &lt;span class=&quot;token function&quot;&gt;cat&lt;/span&gt; /sys/class/net/docker0/flags 
0x1003&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;路由器与NAT设备的关联与区别&quot;&gt;&lt;a href=&quot;#路由器与NAT设备的关联与区别&quot; class=&quot;headerlink&quot; title=&quot;路由器与NAT设备的关联与区别&quot;&gt;&lt;/a&gt;路由器与NAT设备的关联与区别&lt;/h2&gt;&lt;h3 id=&quot;路由器工作原理：&quot;&gt;&lt;a href=&quot;#路由器工作原理：&quot; class=&quot;headerlink&quot; title=&quot;路由器工作原理：&quot;&gt;&lt;/a&gt;路由器工作原理：&lt;/h3&gt;&lt;p&gt;主要用来联通连个不同的网段，&lt;mark&gt;只修改sourceMac与targetMac，不修改sourceIp与targetIp&lt;/mark&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据传入包指定的targetIp（传入包的MAC地址是路由器当前网卡的MAC地址，IP地址是真正的IP地址）&lt;/li&gt;
&lt;li&gt;查询自身路由表，查找到最近的下一跳的IP地址。&lt;code&gt;route -n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;再根据下一跳的IP地址，查找到对应的MAC地址。arp缓存表&lt;/li&gt;
&lt;li&gt;修改数据包的targetMAC地址为下一跳的MAC地址，sourceMAC为当前网卡出口的mac地址&lt;/li&gt;
&lt;li&gt;将数据包从对应网卡送出去。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;路由器的核心是路由表的维护，能生成最短最优路径。&lt;br&gt;&lt;br&gt;从sourceIp到targetIp的路由路径，很可能与回包，即从targetIp返回到sourceIp的路由路径不一样。&lt;br&gt;取决于当时的路径中路由器的路由表情况。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://davyjones2010.github.io/tags/linux/"/>
    
    <category term="iaas" scheme="https://davyjones2010.github.io/tags/iaas/"/>
    
    <category term="network" scheme="https://davyjones2010.github.io/tags/network/"/>
    
    <category term="cloud-computing" scheme="https://davyjones2010.github.io/tags/cloud-computing/"/>
    
    <category term="nat" scheme="https://davyjones2010.github.io/tags/nat/"/>
    
    <category term="pat" scheme="https://davyjones2010.github.io/tags/pat/"/>
    
  </entry>
  
  <entry>
    <title>常用的Linux命令之网络相关命令</title>
    <link href="https://davyjones2010.github.io/2022-06-25-linux-network-scripts/"/>
    <id>https://davyjones2010.github.io/2022-06-25-linux-network-scripts/</id>
    <published>2022-06-25T16:00:00.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><h2 id="查看ARP缓存表"><a href="#查看ARP缓存表" class="headerlink" title="查看ARP缓存表"></a>查看ARP缓存表</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/PlayGround/nat$ arp -vAddress                  HWtype  HWaddress           Flags Mask            Iface_gateway                 ether   c0:b4:7d:69:d6:c3   C                     wlp4s0<span class="token number">172.17</span>.0.3               ether   02:42:ac:11:00:03   C                     docker0<span class="token number">192.168</span>.3.2              ether   00:11:32:b2:b7:04   C                     wlp4s0<span class="token number">172.17</span>.0.2               ether   02:42:ac:11:00:02   C                     docker0Entries: <span class="token number">4</span>Skipped: <span class="token number">0</span>Found: <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查看某个网卡的arp缓存"><a href="#查看某个网卡的arp缓存" class="headerlink" title="查看某个网卡的arp缓存"></a>查看某个网卡的arp缓存</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/PlayGround/nat$ arp -i wlp4s0Address                  HWtype  HWaddress           Flags Mask            Iface_gateway                 ether   c0:b4:7d:69:d6:c3   C                     wlp4s0<span class="token number">192.168</span>.3.2              ether   00:11:32:b2:b7:04   C                     wlp4s0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><ul><li>flags:<ul><li>C: complete, each complete entry in the ARP cache will be marked with the C flag.</li><li>M: 手动增加的，Permanent entries are marked  with  M</li><li>P: TODO: 不太明白具体啥意思，published entries have the P flag.</li></ul></li></ul><h1 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h1><h2 id="查看网桥"><a href="#查看网桥" class="headerlink" title="查看网桥"></a>查看网桥</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ brctl showbridge namebridge <span class="token function">id</span>STP enabledinterfacesdocker0<span class="token number">8000</span>.0242cee53dddnoveth9aec769            vethe466b6bvirbr0<span class="token number">8000</span>.525400245c90<span class="token function">yes</span>virbr0-nic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查看veth-pair"><a href="#查看veth-pair" class="headerlink" title="查看veth pair"></a>查看veth pair</h2><p>如上，发现<code>veth9aec769</code>与<code>vethe466b6b</code>都挂在<code>docker0</code>网桥下。<br>这两个veth设备都是在host上的，那么两个veth设备对应的pair（分别在2个docker容器中）分别是啥？</p><ol><li>查看host上veth设备对应的docker容器内veth设备的编号（如下分别是if23,if24）</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ <span class="token function">ip</span> a <span class="token operator">|</span> <span class="token function">fgrep</span> veth9aec769<span class="token number">24</span>: veth9aec769@if23: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue master docker0 state UP group default davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ <span class="token function">ip</span> a <span class="token operator">|</span> <span class="token function">fgrep</span> vethe466b6b<span class="token number">22</span>: vethe466b6b@if21: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue master docker0 state UP group default <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>登录docker容器中查看veth设备编号</li></ol><p>如下可知：</p><ul><li>d3f6cb3a496e 容器的veth编号是21，与host上if22，即vethe466b6b绑定</li><li>333a28ae8ea1 容器的veth编号是23，与host上if24，即veth9aec769绑定</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/PlayGround/docker$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it d3f6cb3a496e /bin/sh -c <span class="token string">"ip a"</span><span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN qlen <span class="token number">1000</span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo       valid_lft forever preferred_lft forever<span class="token number">21</span>: eth0@if22: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state UP     link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff    inet <span class="token number">172.17</span>.0.3/16 brd <span class="token number">172.17</span>.255.255 scope global eth0       valid_lft forever preferred_lft forever       davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/PlayGround/docker$ <span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it 333a28ae8ea1 /bin/sh -c <span class="token string">"ip a"</span><span class="token number">1</span>: lo: <span class="token operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="token operator">></span> mtu <span class="token number">65536</span> qdisc noqueue state UNKNOWN qlen <span class="token number">1000</span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet <span class="token number">127.0</span>.0.1/8 scope <span class="token function">host</span> lo       valid_lft forever preferred_lft forever<span class="token number">23</span>: eth0@if24: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN<span class="token operator">></span> mtu <span class="token number">1500</span> qdisc noqueue state UP     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff    inet <span class="token number">172.17</span>.0.2/16 brd <span class="token number">172.17</span>.255.255 scope global eth0       valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="CAM表（MAC-Learning-Table）"><a href="#CAM表（MAC-Learning-Table）" class="headerlink" title="CAM表（MAC Learning Table）"></a>CAM表（MAC Learning Table）</h1><p><a href="https://www.xmodulo.com/show-mac-learning-table-linux-bridge.html">How to show a MAC learning table of Linux bridge</a><br>如下，可以看到docker0网桥（虚拟交换机）的CAM表，即mac addr对应的port no</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ brctl showmacs docker0port nomac addris local?ageing timer  <span class="token number">1</span><span class="token number">22</span>:2f:64:b8:78:af<span class="token function">yes</span>   <span class="token number">0.00</span>  <span class="token number">1</span><span class="token number">22</span>:2f:64:b8:78:af<span class="token function">yes</span>   <span class="token number">0.00</span>  <span class="token number">2</span><span class="token number">46</span>:de:b9:ed:19:0f<span class="token function">yes</span>   <span class="token number">0.00</span>  <span class="token number">2</span><span class="token number">46</span>:de:b9:ed:19:0f<span class="token function">yes</span>   <span class="token number">0.00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/ $ routeKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Ifacedefault         <span class="token number">172.17</span>.0.1      <span class="token number">0.0</span>.0.0         UG    <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> eth0<span class="token number">172.17</span>.0.0      *               <span class="token number">255.255</span>.0.0     U     <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> eth0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这是docker容器内部的路由表：</li><li>第二条路由规则：从该主机，发往172.17.0.0&#x2F;16的IP包，都要通过eth0网卡发出（Iface&#x3D;eth0），不经过网关（Gateway&#x3D;*）,直接通过二层网络发送过去。</li><li>第一条路由规则：从该主机，发往其他地址的IP包，都要通过eth0网卡发出（Iface&#x3D;eth0），要先发给网关172.17.0.1（Gateway&#x3D;172.17.0.1）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface<span class="token number">0.0</span>.0.0         <span class="token number">192.168</span>.3.1     <span class="token number">0.0</span>.0.0         UG    <span class="token number">600</span>    <span class="token number">0</span>        <span class="token number">0</span> wlp4s0<span class="token number">172.17</span>.0.0      <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.0.0     U     <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> docker0<span class="token number">192.168</span>.3.0     <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.255.0   U     <span class="token number">600</span>    <span class="token number">0</span>        <span class="token number">0</span> wlp4s0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>这是Host的路由表：</li><li>第二条路由规则：从该主机，发往172.17.0.0&#x2F;16的IP包，都要从docker0网卡发出（Iface&#x3D;docker0），不经过网关（Gateway&#x3D;0.0.0.0），直接通过二层网络发送过去</li><li>第三条路由规则：从该主机，发往192.168.3.0&#x2F;24的IP包，都要从wlp4s0网卡发出（Iface&#x3D;wlp4s0），不经过网关（Gateway&#x3D;0.0.0.0），直接通过二层网络发送过去</li></ul><p>因此：</p><ul><li>从主机 <code>ping 172.17.0.2</code> 容器，实际是进入了docker0网桥，因此能ping通容器</li><li>从主机 <code>ping 192.168.3.2</code> 即该主机局域网内其他主机，实际是从wlp4s0网卡（物理网卡）出去。</li></ul><h1 id="NAT-x2F-iptables"><a href="#NAT-x2F-iptables" class="headerlink" title="NAT&#x2F;iptables"></a>NAT&#x2F;iptables</h1><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><h3 id="Linux上查看DNS缓存"><a href="#Linux上查看DNS缓存" class="headerlink" title="Linux上查看DNS缓存"></a>Linux上查看DNS缓存</h3><h4 id="2016年前"><a href="#2016年前" class="headerlink" title="2016年前"></a>2016年前</h4><p><a href="https://unix.stackexchange.com/questions/28553/how-to-read-the-local-dns-cache-contents">By 2016, Prior to systemd, there was almost no OS-level DNS caching</a><br>unless nscd or dnsmasq was installed and running.<br>Even then, the DNS caching feature of nscd is disabled by default at least in Debian because it’s broken.<br><a href="https://stackoverflow.com/questions/11020027/dns-caching-in-linux">The practical upshot is that your linux system very very probably does not do any OS-level DNS caching.</a></p><blockquote><p>If an end user using your software needs to have DNS caching </br><br>because the DNS query load is large enough to be a problem or the RTT to the external DNS server is long enough to be a problem, </br><br>they can install a caching DNS server such as Unbound on the same machine as your application,<br>configured to cache responses and forward misses to the regular DNS resolvers.</p></blockquote><h4 id="2016年后"><a href="#2016年后" class="headerlink" title="2016年后"></a>2016年后</h4><p><a href="https://www.freedesktop.org/software/systemd/man/systemd-resolved.service.html">After 2016, nowadays on systemd there’s a service to cache DNS, it could be enabled with systemctl enable systemd-resolved</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ <span class="token function">service</span> systemd-resolved statussystemd-resolved.service - Network Name Resolution     Loaded: loaded <span class="token punctuation">(</span>/lib/systemd/system/systemd-resolved.service<span class="token punctuation">;</span> enabled<span class="token punctuation">;</span> vendor preset: enabled<span class="token punctuation">)</span>     Active: active <span class="token punctuation">(</span>running<span class="token punctuation">)</span> since Sun <span class="token number">2022</span>-05-08 <span class="token number">16</span>:04:20 CST<span class="token punctuation">;</span> <span class="token number">1</span> months <span class="token number">18</span> days ago       Docs: man:systemd-resolved.service<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>             https://www.freedesktop.org/wiki/Software/systemd/resolved             https://www.freedesktop.org/wiki/Software/systemd/writing-network-configuration-managers             https://www.freedesktop.org/wiki/Software/systemd/writing-resolver-clients   Main PID: <span class="token number">603</span> <span class="token punctuation">(</span>systemd-resolve<span class="token punctuation">)</span>     Status: <span class="token string">"Processing requests..."</span>      Tasks: <span class="token number">1</span> <span class="token punctuation">(</span>limit: <span class="token number">9305</span><span class="token punctuation">)</span>     Memory: <span class="token number">2</span>.6M     CGroup: /system.slice/systemd-resolved.service             └─603 /lib/systemd/systemd-resolved<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ <span class="token function">cat</span> /etc/resolv.confnameserver <span class="token number">127.0</span>.0.53options edns0 trust-ad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ resolvectl statusLink <span class="token number">3</span> <span class="token punctuation">(</span>wlp4s0<span class="token punctuation">)</span>      Current Scopes: DNS        DefaultRoute setting: <span class="token function">yes</span>               LLMNR setting: <span class="token function">yes</span>        MulticastDNS setting: no           DNSOverTLS setting: no               DNSSEC setting: no             DNSSEC supported: no           Current DNS Server: <span class="token number">192.168</span>.3.1         DNS Servers: <span class="token number">192.168</span>.3.1          DNS Domain: ~.         Link <span class="token number">6</span> <span class="token punctuation">(</span>docker0<span class="token punctuation">)</span>      Current Scopes: noneDefaultRoute setting: no         LLMNR setting: <span class="token function">yes</span> MulticastDNS setting: no    DNSOverTLS setting: no        DNSSEC setting: no      DNSSEC supported: no  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Chrome上查看DNS缓存"><a href="#Chrome上查看DNS缓存" class="headerlink" title="Chrome上查看DNS缓存"></a>Chrome上查看DNS缓存</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chrome://net-internals/<span class="token comment">#dnschrome</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Firefox上查看DNS缓存"><a href="#Firefox上查看DNS缓存" class="headerlink" title="Firefox上查看DNS缓存"></a>Firefox上查看DNS缓存</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">about:networking<span class="token comment">#dns</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="DNS域名解析排查"><a href="#DNS域名解析排查" class="headerlink" title="DNS域名解析排查"></a>DNS域名解析排查</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:/etc/systemd$ <span class="token function">dig</span> baidu.comdavywalker@davywalker-ThinkPad-X1-Carbon-4th:/etc/systemd$ <span class="token function">dig</span> baidu.com +trace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="查看到某个IP的路由信息"><a href="#查看到某个IP的路由信息" class="headerlink" title="查看到某个IP的路由信息"></a>查看到某个IP的路由信息</h1><p>在Linux&amp;MacOS上，traceroute命令默认使用UDP，而Windows默认使用ICMP协议。但可以使用<code>traceroute -I</code>来强制使用ICMP协议。<br><a href="https://serverfault.com/questions/374620/does-traceroute-use-udp-or-icmp-or-both">By default Windows tracert uses ICMP and both Mac OS X and Linux traceroute use UDP.</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ <span class="token function">traceroute</span> <span class="token number">220.181</span>.38.148<span class="token function">traceroute</span> to <span class="token number">220.181</span>.38.148 <span class="token punctuation">(</span><span class="token number">220.181</span>.38.148<span class="token punctuation">)</span>, <span class="token number">30</span> hops max, <span class="token number">60</span> byte packets <span class="token number">1</span>  _gateway <span class="token punctuation">(</span><span class="token number">192.168</span>.3.1<span class="token punctuation">)</span>  <span class="token number">3.140</span> ms  <span class="token number">3.401</span> ms  <span class="token number">5.204</span> ms <span class="token number">2</span>  <span class="token number">122.233</span>.112.1 <span class="token punctuation">(</span><span class="token number">122.233</span>.112.1<span class="token punctuation">)</span>  <span class="token number">8.077</span> ms  <span class="token number">8.005</span> ms  <span class="token number">8.613</span> ms <span class="token number">3</span>  <span class="token number">61.164</span>.3.50 <span class="token punctuation">(</span><span class="token number">61.164</span>.3.50<span class="token punctuation">)</span>  <span class="token number">8.474</span> ms <span class="token number">61.164</span>.2.2 <span class="token punctuation">(</span><span class="token number">61.164</span>.2.2<span class="token punctuation">)</span>  <span class="token number">8.331</span> ms  <span class="token number">9.131</span> ms<span class="token number">30</span>  * * *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用ICMP协议进行traceroute</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ <span class="token function">traceroute</span> -I <span class="token number">220.181</span>.38.148<span class="token function">traceroute</span> to <span class="token number">220.181</span>.38.148 <span class="token punctuation">(</span><span class="token number">220.181</span>.38.148<span class="token punctuation">)</span>, <span class="token number">30</span> hops max, <span class="token number">60</span> byte packets <span class="token number">1</span>  _gateway <span class="token punctuation">(</span><span class="token number">192.168</span>.3.1<span class="token punctuation">)</span>  <span class="token number">3.348</span> ms  <span class="token number">3.300</span> ms  <span class="token number">3.604</span> ms <span class="token number">2</span>  <span class="token number">122.233</span>.112.1 <span class="token punctuation">(</span><span class="token number">122.233</span>.112.1<span class="token punctuation">)</span>  <span class="token number">46.031</span> ms  <span class="token number">46.236</span> ms  <span class="token number">46.274</span> ms <span class="token number">3</span>  <span class="token number">61.164</span>.3.50 <span class="token punctuation">(</span><span class="token number">61.164</span>.3.50<span class="token punctuation">)</span>  <span class="token number">8.196</span> ms  <span class="token number">9.610</span> ms  <span class="token number">9.522</span> ms <span class="token number">4</span>  * <span class="token number">115.233</span>.18.13 <span class="token punctuation">(</span><span class="token number">115.233</span>.18.13<span class="token punctuation">)</span>  <span class="token number">10.761</span> ms * <span class="token number">5</span>  <span class="token number">202.97</span>.102.201 <span class="token punctuation">(</span><span class="token number">202.97</span>.102.201<span class="token punctuation">)</span>  <span class="token number">40.430</span> ms  <span class="token number">40.413</span> ms  <span class="token number">40.431</span> ms <span class="token number">6</span>  <span class="token number">36.110</span>.245.66 <span class="token punctuation">(</span><span class="token number">36.110</span>.245.66<span class="token punctuation">)</span>  <span class="token number">35.611</span> ms *  <span class="token number">34.008</span> ms <span class="token number">7</span>  * * * <span class="token number">8</span>  <span class="token number">220.181</span>.182.30 <span class="token punctuation">(</span><span class="token number">220.181</span>.182.30<span class="token punctuation">)</span>  <span class="token number">41.642</span> ms  <span class="token number">41.785</span> ms  <span class="token number">37.416</span> ms <span class="token number">9</span>  * * *<span class="token number">10</span>  * * *<span class="token number">11</span>  * * *<span class="token number">12</span>  <span class="token number">220.181</span>.38.148 <span class="token punctuation">(</span><span class="token number">220.181</span>.38.148<span class="token punctuation">)</span>  <span class="token number">40.385</span> ms  <span class="token number">40.757</span> ms  <span class="token number">40.478</span> ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="路由器上，多个网卡，请求到某个网卡之后，是如何转发到其他网卡的？"><a href="#路由器上，多个网卡，请求到某个网卡之后，是如何转发到其他网卡的？" class="headerlink" title="路由器上，多个网卡，请求到某个网卡之后，是如何转发到其他网卡的？"></a>路由器上，多个网卡，请求到某个网卡之后，是如何转发到其他网卡的？</h2><p>例如：<br>docker容器内部 172.17.0.2，访问host的ip (192.168.3.80)</p><ol><li><p>docker容器内部有一条路由规则，非docker容器网段，都到docker0网桥上，docker0网桥IP 172.17.0.1</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Destination     Gateway         Genmask         Flags Metric Ref    Use Ifacedefault         <span class="token number">172.17</span>.0.1      <span class="token number">0.0</span>.0.0         UG    <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> eth0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>请求到docker0网桥 172.17.0.1 之后，（docker0网桥本身就在Host上），查看路由表，从 wlp4s0 网卡发出（这里具体怎么发出的？）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">davywalker@davywalker-ThinkPad-X1-Carbon-4th:/etc/systemd$ route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface<span class="token number">0.0</span>.0.0         <span class="token number">192.168</span>.3.1     <span class="token number">0.0</span>.0.0         UG    <span class="token number">600</span>    <span class="token number">0</span>        <span class="token number">0</span> wlp4s0<span class="token number">172.17</span>.0.0      <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.0.0     U     <span class="token number">0</span>      <span class="token number">0</span>        <span class="token number">0</span> docker0<span class="token number">192.168</span>.3.0     <span class="token number">0.0</span>.0.0         <span class="token number">255.255</span>.255.0   U     <span class="token number">600</span>    <span class="token number">0</span>        <span class="token number">0</span> wlp4s0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="centos如何查看网卡状态-并将某个网卡设置为默认启动"><a href="#centos如何查看网卡状态-并将某个网卡设置为默认启动" class="headerlink" title="centos如何查看网卡状态, 并将某个网卡设置为默认启动"></a>centos如何查看网卡状态, 并将某个网卡设置为默认启动</h2><p>使用<code>VMware Fusion</code>安装好了<code>CentOS 7</code>虚拟机之后, 发现网络怎么都不通.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ping</span> baidu.comping: baidu.com: Name or <span class="token function">service</span> not known$ <span class="token function">curl</span> baidu.comcurl: Could not resolve host: baidu.com<span class="token punctuation">;</span> Unknown error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用如下方式进行排查: </p><ol><li>查看网卡连接状态, 发现以太网卡<code>ens33</code>为未连接<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> nmcli dDEVICE  TYPE      STATE         CONNECTIONens33   ethernet  disconnected  --lo      lookback  unmanaged     --<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>修改网卡状态<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">vi</span> /etc/sysconfig/network-scripts/ifcfg-ens33-- <span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span>no<span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span>yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>重启网络服务<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> /etc/init.d/network restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>验证网卡状态<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sudo</span> nmcli dDEVICE  TYPE      STATE         CONNECTIONens33   ethernet  connected     ens33lo      lookback  unmanaged     --<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>验证网络状态: 成功<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ping</span> baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ARP协议&quot;&gt;&lt;a href=&quot;#ARP协议&quot; class=&quot;headerlink&quot; title=&quot;ARP协议&quot;&gt;&lt;/a&gt;ARP协议&lt;/h1&gt;&lt;h2 id=&quot;查看ARP缓存表&quot;&gt;&lt;a href=&quot;#查看ARP缓存表&quot; class=&quot;headerlink&quot; title=&quot;查看ARP缓存表&quot;&gt;&lt;/a&gt;查看ARP缓存表&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/PlayGround/nat$ arp -v
Address                  HWtype  HWaddress           Flags Mask            Iface
_gateway                 ether   c0:b4:7d:69:d6:c3   C                     wlp4s0
&lt;span class=&quot;token number&quot;&gt;172.17&lt;/span&gt;.0.3               ether   02:42:ac:11:00:03   C                     docker0
&lt;span class=&quot;token number&quot;&gt;192.168&lt;/span&gt;.3.2              ether   00:11:32:b2:b7:04   C                     wlp4s0
&lt;span class=&quot;token number&quot;&gt;172.17&lt;/span&gt;.0.2               ether   02:42:ac:11:00:02   C                     docker0
Entries: &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;	Skipped: &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;	Found: &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;查看某个网卡的arp缓存&quot;&gt;&lt;a href=&quot;#查看某个网卡的arp缓存&quot; class=&quot;headerlink&quot; title=&quot;查看某个网卡的arp缓存&quot;&gt;&lt;/a&gt;查看某个网卡的arp缓存&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/PlayGround/nat$ arp -i wlp4s0
Address                  HWtype  HWaddress           Flags Mask            Iface
_gateway                 ether   c0:b4:7d:69:d6:c3   C                     wlp4s0
&lt;span class=&quot;token number&quot;&gt;192.168&lt;/span&gt;.3.2              ether   00:11:32:b2:b7:04   C                     wlp4s0&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;参数详解&quot;&gt;&lt;a href=&quot;#参数详解&quot; class=&quot;headerlink&quot; title=&quot;参数详解&quot;&gt;&lt;/a&gt;参数详解&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;flags:&lt;ul&gt;
&lt;li&gt;C: complete, each complete entry in the ARP cache will be marked with the C flag.&lt;/li&gt;
&lt;li&gt;M: 手动增加的，Permanent entries are marked  with  M&lt;/li&gt;
&lt;li&gt;P: TODO: 不太明白具体啥意思，published entries have the P flag.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;网桥&quot;&gt;&lt;a href=&quot;#网桥&quot; class=&quot;headerlink&quot; title=&quot;网桥&quot;&gt;&lt;/a&gt;网桥&lt;/h1&gt;&lt;h2 id=&quot;查看网桥&quot;&gt;&lt;a href=&quot;#查看网桥&quot; class=&quot;headerlink&quot; title=&quot;查看网桥&quot;&gt;&lt;/a&gt;查看网桥&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;davywalker@davywalker-ThinkPad-X1-Carbon-4th:~/Downloads$ brctl show
bridge name	bridge &lt;span class=&quot;token function&quot;&gt;id&lt;/span&gt;		STP enabled	interfaces
docker0		&lt;span class=&quot;token number&quot;&gt;8000&lt;/span&gt;.0242cee53ddd	no		veth9aec769
							            vethe466b6b
virbr0		&lt;span class=&quot;token number&quot;&gt;8000&lt;/span&gt;.525400245c90	&lt;span class=&quot;token function&quot;&gt;yes&lt;/span&gt;		virbr0-nic&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="code-snippets" scheme="https://davyjones2010.github.io/tags/code-snippets/"/>
    
    <category term="linux" scheme="https://davyjones2010.github.io/tags/linux/"/>
    
    <category term="network" scheme="https://davyjones2010.github.io/tags/network/"/>
    
    <category term="nat" scheme="https://davyjones2010.github.io/tags/nat/"/>
    
    <category term="arp" scheme="https://davyjones2010.github.io/tags/arp/"/>
    
  </entry>
  
  <entry>
    <title>记一次Dubbo服务调用异常排查</title>
    <link href="https://davyjones2010.github.io/2022-06-24-dubbo-invoke-error/"/>
    <id>https://davyjones2010.github.io/2022-06-24-dubbo-invoke-error/</id>
    <published>2022-06-24T16:00:00.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ul><li>应用拓扑: systemA —- dubbo 调用 —-&gt; systemB</li><li>systemB应用在已有的dubbo接口类里, 新增加了一个方法methodA.</li><li>systemA在调用该methodA时, 抛错. 错误信息如下:</li></ul><h1 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h1><h2 id="0x00-排查provider侧"><a href="#0x00-排查provider侧" class="headerlink" title="0x00 排查provider侧"></a>0x00 排查provider侧</h2><p>确认provider侧:</p><ol><li>服务是否正常可以执行? &gt; 通过telnet localhost, 手动invoke确定是OK的.</li><li>接口类&amp;接口方法是否正常注册在registry上? &gt; 通过查看dubbo registry, 发现接口类与接口方法是正常注册的.</li></ol><h2 id="0x01-排查consumer侧"><a href="#0x01-排查consumer侧" class="headerlink" title="0x01 排查consumer侧"></a>0x01 排查consumer侧</h2><p>确认consumer侧:</p><ol><li>是否正确依赖到了provider?<ol><li>通过查看 tcp ESTABLISHED 连接确定长连接已经建立.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122201347.png"></li><li>or 查看registry下发的 dubbo config 文件?  –&gt; TODO: 暂时没找到, 待分析.</li></ol></li><li>请求是否正确路由到了provider的host?  &#x2F;&#x2F; 由于systemB有多套环境, 怀疑是请求路由到了非目标环境.<ol><li>动态分析: 查看 dubbo 请求日志 –&gt; 没找到, 待进一步查看.</li><li>静态分析: 查看 diamond 配置 + 相关代码, 是不是路由代码有误?</li></ol></li></ol><h2 id="0x02-真实错误原因"><a href="#0x02-真实错误原因" class="headerlink" title="0x02 真实错误原因"></a>0x02 真实错误原因</h2><ul><li>provider侧与consumer侧都没有问题, 路由也没有问题, 但为啥会报错?</li><li>最终在某位同学的提醒下, 查看了consumer侧的error日志, 发现了详细的错误堆栈信息如下(原来是序列化失败):</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122201975.png"></p><h2 id="0x03-原因探讨"><a href="#0x03-原因探讨" class="headerlink" title="0x03 原因探讨"></a>0x03 原因探讨</h2><h3 id="为啥dubbo调用参数必须要是Serializable的"><a href="#为啥dubbo调用参数必须要是Serializable的" class="headerlink" title="为啥dubbo调用参数必须要是Serializable的?"></a>为啥dubbo调用参数必须要是Serializable的?</h3><p>因为dubbo rpc, 默认使用hessian2序列化方式.<br><a href="https://blog.csdn.net/liyong1028826685/article/details/117308356">而hessian2针对java Object类型参数, 使用的是默认的Java序列化方式</a>.<br>而Java序列化则要求Object必须<code>implements Serializable</code>接口.</p><h3 id="为啥在本地telnet-invoke的时候没有序列化失败错误"><a href="#为啥在本地telnet-invoke的时候没有序列化失败错误" class="headerlink" title="为啥在本地telnet invoke的时候没有序列化失败错误?"></a>为啥在本地telnet invoke的时候没有序列化失败错误?</h3><p>因为在本地telnet invoke的时候, 默认使用的是JSON序列化方式!</p><h3 id="如何查看当前接口使用的序列化方式"><a href="#如何查看当前接口使用的序列化方式" class="headerlink" title="如何查看当前接口使用的序列化方式?"></a>如何查看当前接口使用的序列化方式?</h3><ol><li>查看registry, 如果没有指定, 则是默认的hessian2:</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122202268.png"></p><h3 id="如何指定序列化方式"><a href="#如何指定序列化方式" class="headerlink" title="如何指定序列化方式?"></a>如何指定序列化方式?</h3><p><a href="https://dubbo.apache.org/zh/docs/references/xml/dubbo-protocol/">https://dubbo.apache.org/zh/docs/references/xml/dubbo-protocol/</a><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122202940.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&lt;</span>dubbo:protocol <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">"dubbo-m"</span> <span class="token assign-left variable">threadpool</span><span class="token operator">=</span><span class="token string">"dubboThreadPool"</span> <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">"dubbo"</span>  <span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$&#123;pbs.dubbo.protocol.default.port&#125;</span>"</span>  <span class="token assign-left variable">threads</span><span class="token operator">=</span><span class="token string">"150"</span> <span class="token assign-left variable">serialization</span><span class="token operator">=</span><span class="token string">"json"</span> /<span class="token operator">></span><span class="token operator">&lt;</span>dubbo:protocol <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">"dubbo-h"</span> <span class="token assign-left variable">threadpool</span><span class="token operator">=</span><span class="token string">"dubboThreadPool"</span> <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">"dubbo"</span>  <span class="token assign-left variable">port</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$&#123;pbs.dubbo.protocol.high.port&#125;</span>"</span>  <span class="token assign-left variable">threads</span><span class="token operator">=</span><span class="token string">"150"</span> <span class="token assign-left variable">serialization</span><span class="token operator">=</span><span class="token string">"fastjson"</span> /<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><h2 id="正确的问题排查步骤"><a href="#正确的问题排查步骤" class="headerlink" title="正确的问题排查步骤"></a>正确的问题排查步骤</h2><ol><li>排查问题时, 优先在报错的host(不用管是consumer&#x2F;provider)上, 查看error等更详细的堆栈日志.</li></ol><h2 id="走的一些弯路"><a href="#走的一些弯路" class="headerlink" title="走的一些弯路"></a>走的一些弯路</h2><ol><li>provider侧排查时, invoke 方法名称写错, 导致误以为是provider没有把新的接口方法暴露出去. 误导了排查方向. 如下:</li></ol><p>正确的: <code>invoke com.xxx.xxx.XXXQueryService.queryHistory(&quot;&quot;)</code><br>错误的: <code>invoke com.xxx.xxx.XXXQueryService.describeHistory(&quot;&quot;)</code><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122202508.png"><br><a href="#dubbo%E5%A6%82%E4%BD%95%E6%9F%A5%E5%88%B0%E6%9F%90%E5%8F%B0host%E4%B8%AD%E6%9F%90%E4%B8%AA%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BE%9B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%B9%E6%B3%95">如何快速查看某个host的某个interface有没有把某个method暴露出去</a></p><ol start="2"><li>consumer侧排查时, 由于systemA的dubbo console的端口与systemB的dubbo console 端口不一致, 也查了半天.<br><a href="#dubbo%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bconsole%E7%9A%84%E7%AB%AF%E5%8F%A3">如何快速查到dubbo console端口号?</a></li></ol><h2 id="Dubbo最佳实践"><a href="#Dubbo最佳实践" class="headerlink" title="Dubbo最佳实践"></a>Dubbo最佳实践</h2><h3 id="dubbo按照端口进行线程池隔离"><a href="#dubbo按照端口进行线程池隔离" class="headerlink" title="dubbo按照端口进行线程池隔离"></a>dubbo按照端口进行线程池隔离</h3><h4 id="隔离原理"><a href="#隔离原理" class="headerlink" title="隔离原理"></a>隔离原理</h4><p>单个host可以开启多个dubbo端口, 每个端口由独立的线程池处理, 把svc按照端口进行分组.<br>可以防止低优先级接口占用线程导致dubbo线程池满, 从而影响高优先级接口.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122202434.png"></p><h4 id="隔离配置样例"><a href="#隔离配置样例" class="headerlink" title="隔离配置样例"></a>隔离配置样例</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>registry</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>coreRegistry<span class="token punctuation">"</span></span> <span class="token attr-name">address</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;pbs.dubbo.registry.address&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment">&lt;!-- 核心接口 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>protocol</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo-core<span class="token punctuation">"</span></span> <span class="token attr-name">threadpool</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubboThreadPool<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo<span class="token punctuation">"</span></span>  <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;pbs.dubbo.protocol.core.port&#125;<span class="token punctuation">"</span></span>  <span class="token attr-name">threads</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment">&lt;!-- 中优先级接口线程池(默认，为了最大保持兼容) --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>protocol</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo-m<span class="token punctuation">"</span></span> <span class="token attr-name">threadpool</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubboThreadPool<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo<span class="token punctuation">"</span></span>  <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;pbs.dubbo.protocol.default.port&#125;<span class="token punctuation">"</span></span>  <span class="token attr-name">threads</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>150<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment">&lt;!-- 默认provider使用dubbo-m,http-dubbo协议 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>provider</span> <span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo-m<span class="token punctuation">"</span></span> <span class="token attr-name">filter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>-sentinel.dubbo.provider.filter<span class="token punctuation">"</span></span> <span class="token attr-name">delay</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>-1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment">&lt;!-- 使用dubbo-core --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.TestService<span class="token punctuation">"</span></span><span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo-core<span class="token punctuation">"</span></span> <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;pbs.service.version&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>testService<span class="token punctuation">"</span></span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">timeout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>30000<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment">&lt;!-- 使用dubbo-core --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.xxx.SampleService<span class="token punctuation">"</span></span><span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dubbo-core<span class="token punctuation">"</span></span> <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$&#123;pbs.service.version&#125;<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sampleService<span class="token punctuation">"</span></span> <span class="token attr-name">retries</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">timeout</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>30000<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dubbo默认端口号配置原则"><a href="#dubbo默认端口号配置原则" class="headerlink" title="dubbo默认端口号配置原则"></a>dubbo默认端口号配置原则</h3><p>如上, <code>pbs.dubbo.protocol.default.port=-1</code>配置项, 按照dubbo文档说明, 应该是随机分配一个端口. 但发现systemB实际启动后, 却开启了 20880 端口. 这是为啥?</p><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p>根据 <a href="https://dubbo.apache.org/zh/docs/references/xml/dubbo-protocol/">https://dubbo.apache.org/zh/docs/references/xml/dubbo-protocol/</a>  文档说明,  <code>分配的端口在协议缺省端口的基础上增长</code><br>但实际语焉不详, dubbo协议默认端口是20880,  那么如果配置 <code>port=-1</code>, 则端口是 <code>20880</code> or <code>20881</code>??</p><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122203219.png"></p><h4 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h4><p>核心代码: <code>com.alibaba.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol</code>, 可以得知是从 20880 开始(包括20880).<br>这也就解释了, 为啥 <code>pbs.dubbo.protocol.default.port=-1</code>配置项, 实际对应的开启端口号是 20880 啦.<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122203404.png"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122203097.png"></p><h3 id="dubbo多端口telnet原则"><a href="#dubbo多端口telnet原则" class="headerlink" title="dubbo多端口telnet原则"></a>dubbo多端口telnet原则</h3><p>如上, 暴露了 20880~20884 5个端口, 用于线程池隔离.<br>实际:</p><ol><li>每个端口, 都是启动了一个NettyServer<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122203903.png"></li><li>因此每个端口, 都可以telnet上去.</li><li>telnet每个端口执行 ls 列举出来本机暴露的dubbo服务都是一样的(会把所有其他端口暴露的服务也都枚举出来). 不会因为telnet 20880, 就只列举出暴露在20880端口的服务. 参见: <code>com.alibaba.dubbo.rpc.protocol.dubbo.telnet.ListTelnetHandler</code><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122204305.png"></li></ol><h3 id="dubbo版本号隔离"><a href="#dubbo版本号隔离" class="headerlink" title="dubbo版本号隔离"></a>dubbo版本号隔离</h3><p>用来区分多套预发环境.<br>但实际看了下, 多套预发环境provider的版本号都是1.0.0, 而不是通过版本号来进行隔离的. 那么consumer实际怎么做的路由?<br>&#x2F;&#x2F; TODO:  核心代码附录<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122204657.png"></p><h3 id="dubbo序列化"><a href="#dubbo序列化" class="headerlink" title="dubbo序列化"></a>dubbo序列化</h3><ul><li>使用console手动invoke, 用的是json序列化.</li><li>而consumer真正调用时用的是hessian2序列化, 因此针对这种序列化差异导致的错误问题, 是无法验证到的. 需要编码测试的时候注意.</li></ul><h3 id="dubbo-ls-x2F-invoke"><a href="#dubbo-ls-x2F-invoke" class="headerlink" title="dubbo ls&#x2F;invoke"></a>dubbo ls&#x2F;invoke</h3><p>如何查看当前host下依赖的所有dubbo服务?</p><ol><li>通过telnet localhost xxxx 进入dubbo管控页面, 执行 <code>ls</code>命令, 只能列出自身作为provider对外暴露的所有服务.</li><li>而无法列出自身host作为consumer依赖到的所有服务.  &#x2F;&#x2F; 查看了dubbo文档, 目前没有办法通过telnet查看到.</li></ol><h3 id="dubbo如何查到某台host中某个接口提供的所有方法"><a href="#dubbo如何查到某台host中某个接口提供的所有方法" class="headerlink" title="dubbo如何查到某台host中某个接口提供的所有方法"></a>dubbo如何查到某台host中某个接口提供的所有方法</h3><h4 id="方案1-telnet查看"><a href="#方案1-telnet查看" class="headerlink" title="方案1 telnet查看"></a>方案1 telnet查看</h4><p><code>ls -l com.xxx.SampleService</code><br>telnet localhost  20880  telnet localhost  20881 telnet localhost  20882 都能登上去, 实际方法列表也相同.  参见: <a href="#th8th">dubbo多端口telnet原则</a></p><h4 id="方案2-registry查看"><a href="#方案2-registry查看" class="headerlink" title="方案2 registry查看"></a>方案2 registry查看</h4><p>在registry中查询接口, 选定host查看:<br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122206622.png"></p><h3 id="dubbo如何查看console的端口"><a href="#dubbo如何查看console的端口" class="headerlink" title="dubbo如何查看console的端口"></a>dubbo如何查看console的端口</h3><h4 id="方案1-通过查看应用配置文件"><a href="#方案1-通过查看应用配置文件" class="headerlink" title="方案1: 通过查看应用配置文件"></a>方案1: 通过查看应用配置文件</h4><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122207808.png"></p><blockquote><p>这种方式最直接, 也最有效. 缺点是紧急排查问题时, 如果配置项经过了一层有一层的自动替换, 不一定能很快找出实际配置值是啥.</p></blockquote><h4 id="方案2-通过查看TCP连接"><a href="#方案2-通过查看TCP连接" class="headerlink" title="方案2: 通过查看TCP连接"></a>方案2: 通过查看TCP连接</h4><ol><li><p>查看进程号PID(注意看清楚进程的USER是不是当前用户)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">fgrep</span> <span class="token variable">$&#123;appName&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看进程占用的TCP在Listen状态的端口(如果上一步获取到的PID不是当前用户的, 则需要su到PID对应的用户, 或者如下用sudo)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">lsof</span> -i -P<span class="token operator">|</span> <span class="token function">fgrep</span> <span class="token variable">$&#123;PID&#125;</span> <span class="token operator">|</span> <span class="token function">fgrep</span> LISTEN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>看到如下, 一般dubbo端口号是从20880开始的(包括20880)</p></li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122207567.png"></p><p>但如果应用配置的dubbo端口很奇怪, 不符合惯例, 那这里就只能一个一个端口来telnet试试了.</p><blockquote><p>这种方式不算非常直接, 但优点是可以不用去翻找代码, 翻找配置项. 在端口数很少的情况下, 简单有效.</p></blockquote><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Dubbo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%AE%9E%E6%88%98-%E5%AE%8C/16%20%20Dubbo%20Serialize%20%E5%B1%82%EF%BC%9A%E5%A4%9A%E7%A7%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%97%E6%B3%95%EF%BC%8C%E6%80%BB%E6%9C%89%E4%B8%80%E6%AC%BE%E9%80%82%E5%90%88%E4%BD%A0.md">Dubbo Serialize 层：多种序列化算法，总有一款适合你</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;应用拓扑: systemA —- dubbo 调用 —-&amp;gt; systemB&lt;/li&gt;
&lt;li&gt;systemB应用在已有的dubbo接口类里, 新增加了一个方法methodA.&lt;/li&gt;
&lt;li&gt;systemA在调用该methodA时, 抛错. 错误信息如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;排查步骤&quot;&gt;&lt;a href=&quot;#排查步骤&quot; class=&quot;headerlink&quot; title=&quot;排查步骤&quot;&gt;&lt;/a&gt;排查步骤&lt;/h1&gt;&lt;h2 id=&quot;0x00-排查provider侧&quot;&gt;&lt;a href=&quot;#0x00-排查provider侧&quot; class=&quot;headerlink&quot; title=&quot;0x00 排查provider侧&quot;&gt;&lt;/a&gt;0x00 排查provider侧&lt;/h2&gt;&lt;p&gt;确认provider侧:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务是否正常可以执行? &amp;gt; 通过telnet localhost, 手动invoke确定是OK的.&lt;/li&gt;
&lt;li&gt;接口类&amp;amp;接口方法是否正常注册在registry上? &amp;gt; 通过查看dubbo registry, 发现接口类与接口方法是正常注册的.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;0x01-排查consumer侧&quot;&gt;&lt;a href=&quot;#0x01-排查consumer侧&quot; class=&quot;headerlink&quot; title=&quot;0x01 排查consumer侧&quot;&gt;&lt;/a&gt;0x01 排查consumer侧&lt;/h2&gt;&lt;p&gt;确认consumer侧:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是否正确依赖到了provider?&lt;ol&gt;
&lt;li&gt;通过查看 tcp ESTABLISHED 连接确定长连接已经建立.&lt;br&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202207122201347.png&quot;&gt;&lt;/li&gt;
&lt;li&gt;or 查看registry下发的 dubbo config 文件?  –&amp;gt; TODO: 暂时没找到, 待分析.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;请求是否正确路由到了provider的host?  &amp;#x2F;&amp;#x2F; 由于systemB有多套环境, 怀疑是请求路由到了非目标环境.&lt;ol&gt;
&lt;li&gt;动态分析: 查看 dubbo 请求日志 –&amp;gt; 没找到, 待进一步查看.&lt;/li&gt;
&lt;li&gt;静态分析: 查看 diamond 配置 + 相关代码, 是不是路由代码有误?&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;0x02-真实错误原因&quot;&gt;&lt;a href=&quot;#0x02-真实错误原因&quot; class=&quot;headerlink&quot; title=&quot;0x02 真实错误原因&quot;&gt;&lt;/a&gt;0x02 真实错误原因&lt;/h2&gt;</summary>
    
    
    
    
    <category term="java" scheme="https://davyjones2010.github.io/tags/java/"/>
    
    <category term="dubbo" scheme="https://davyjones2010.github.io/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>NAT之端口映射(PAT)原理总结&amp;实践</title>
    <link href="https://davyjones2010.github.io/2022-06-22-linux-network-nat/"/>
    <id>https://davyjones2010.github.io/2022-06-22-linux-network-nat/</id>
    <published>2022-06-22T16:00:00.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>经常在家用路由器中, 看到有端口映射(PAT)选项, 但不明所以.<br>最近刚好在研究NAT, 知道了<mark>PAT本质是NAT的一种实现方式, 更确切地说是DNAT的一种实现方式</mark>.<br>因此借此机会好好研究下.</p><h1 id="DNAT总结"><a href="#DNAT总结" class="headerlink" title="DNAT总结"></a>DNAT总结</h1><h2 id="PAT作用概述"><a href="#PAT作用概述" class="headerlink" title="PAT作用概述"></a>PAT作用概述</h2><p>家用路由器中配置PAT, 本质上还是一种<code>内网穿透</code>的实现方式，或者DNAT的一种方式。<br>即需要把家里内网某台主机的某个服务, 暴露到公网上, 以便能在公网环境下访问该服务.<br>例如</p><ul><li>家庭内网网段是<code>192.168.3.0/24</code></li><li>家用路由器, 电信运营商分配的对外公网IP是<code>115.192.71.187</code></li><li>某台主机IP是<code>192.168.3.213</code>: <ul><li>暴露了8080的某个tomcat服务, 想要把这个服务暴露在公网上, 以便其他人能够访问.</li><li>暴露了远程桌面RDP端口服务, 以便在公司或者咖啡厅, 能访问到该远程桌面.</li><li>等等</li></ul></li><li>此时可以在路由器上开启端口映射(PAT), 将路由器上某个端口(如8888)与内网主机的端口(如8080)如进行映射, 所有访问{路由器IP, 8888端口}的请求, 就会被自动路由到{内网IP, 8080端口}上:</li></ul><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206232339615.png"></p><p>&#x2F;&#x2F; TODO: 这里挖个坑, 内网穿透除了PAT外, 还有其他方案, 例如 <code>花生壳</code>, 后边新开篇章讲下原理.</p><h2 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h2><p>本质上是家用路由器保存了这么一张NAT表:<br><code>&#123;publicIp, publicPort&#125;</code> —映射到—&gt; <code>&#123;localIp, localPort&#125;</code></p><h2 id="PAT路由流程"><a href="#PAT路由流程" class="headerlink" title="PAT路由流程"></a>PAT路由流程</h2><h3 id="0X00-外部用户-–-gt-路由器"><a href="#0X00-外部用户-–-gt-路由器" class="headerlink" title="0X00: 外部用户 –&gt; 路由器"></a>0X00: 外部用户 –&gt; 路由器</h3><ol><li>二层帧: <code>&#123;remoteMac, remoteIp, remotePort&#125;, &#123;publicMac, publicIp, publicPort&#125;</code></li></ol><h3 id="0X01-路由器-–-gt-内网Server"><a href="#0X01-路由器-–-gt-内网Server" class="headerlink" title="0X01: 路由器 –&gt; 内网Server:"></a>0X01: 路由器 –&gt; 内网Server:</h3><ol><li>目标 publicMac &#x3D;&#x3D; router’s publicMac，网卡接收，解析三层IP包</li><li>进入prerouting阶段：(DNAT作用在preroute阶段)<ol><li>查NAT表（DNAT条目）: <code>&#123;publicIp, publicPort&#125;</code> –&gt; <code>&#123;localIp, localPort&#125;</code></li><li>修改三层IP包 <code>&#123;remoteIp, remotePort&#125;</code> –&gt; <code>&#123;localIp, localPort&#125;</code></li></ol></li><li>由于此时targetIp是 localIp, !&#x3D; publicIp，因此不会走入INPUT流程，因此也就不会把数据包交给上层应用。</li><li>进入FORWARD&#x2F;ROUTE阶段：<ol><li>如果没有开启ip_forwarding，则流程到此结束。直接把IP包丢弃掉。</li><li>查看路由表，<code>route -n</code>，找到往localIp网段发送数据包，应该使用的网卡与网卡对应的Mac地址（例如 gatewayMac）</li></ol></li><li>封装二层帧<ol><li>发ARP广播: what’s localIp’s mac addr, tell publicMac</li><li>获取ARP缓存表项: {localIp} –&gt; {localMac}</li><li>修改帧内容为: <code>&#123;gatewayMac, remoteIp, remotePort&#125;, &#123;localMac, localIp, localPort&#125;</code></li></ol></li><li>通过对应的网卡发出二层帧。</li></ol><p><img data-src="https://p.k8s.li/iptables.png"></p><h3 id="0X02-Server端处理"><a href="#0X02-Server端处理" class="headerlink" title="0X02: Server端处理:"></a>0X02: Server端处理:</h3><ol><li>接收如下IP帧<br><code>&#123;gatewayMac, remoteIp, remotePort&#125;, &#123;localMac, localIp, localPort&#125;</code></li><li>目标 localMac &#x3D;&#x3D; Server localMac, 网卡接收(无需开启混杂模式), 否则丢弃</li><li>目标 localIp &#x3D;&#x3D; Server localIp, TCP&#x2F;IP协议栈接收. <ol><li>是否有可能IP不匹配? 如何处理? –&gt; 是否开启了ip_forwarding？ 具体参见</li></ol></li><li>server端将TCP数据包转给对应应用层程序处理</li></ol><h3 id="0X03-Server-–回包–-gt-路由器"><a href="#0X03-Server-–回包–-gt-路由器" class="headerlink" title="0X03: Server –回包–&gt; 路由器:"></a>0X03: Server –回包–&gt; 路由器:</h3><ol><li>Server处理完毕, 生成回包, 由于remoteIp不在网段:<br><code>&#123;localIp, localPort&#125;, &#123;remoteIp, remotePort&#125;</code></li><li>Server发送ARP广播, 查找默认网关(server端事先配置好了网关的IP)的MAC地址 {gatewayIp} –&gt; {gatewayMac}</li><li>Server封装二层帧, 发送给路由器:<br><code>&#123;localMac, localIp, localPort&#125;, &#123;gatewayMac, remoteIp, remotePort&#125;</code></li></ol><h3 id="0X04-路由器PAT处理回包"><a href="#0X04-路由器PAT处理回包" class="headerlink" title="0X04: 路由器PAT处理回包"></a>0X04: 路由器PAT处理回包</h3><p>后经查证，<mark> 针对回包，不会再过iptables</mark>，进行如下NAT反向查表了。<br>实际看了下，确实没有同时创建出如下反向的iptables规则。<br>而是<mark>由kernel模块conntrack进行维护完成{mac, ip, port}的替换。<mark></p><ol><li><del>收到二层帧:<br><code>&#123;localMac, localIp, localPort&#125;, &#123;gatewayMac, remoteIp, remotePort&#125;</code></del></li><li><del>反向查找NAT表:<br><code>&#123;localIp, localPort&#125; --&gt; &#123;publicIp, publicPort&#125;</code></del></li><li><del>修改三层包(替换掉localIp, localPort):<br><code>&#123;publicIp, publicPort&#125;, &#123;remoteIp, remotePort&#125;</code></del></li><li><del>二层帧修改(修改掉localMac, gatewayMac):<br><code>&#123;publicMac, publicIp, publicPort&#125;, &#123;remoteMac, remoteIp, remotePort&#125;</code></del></li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>路由器本身是有多个网卡的, 内网中是 {gatewayMac, gatewayIp}, 对应的公网是 {publicMac, publicIp}</p><h1 id="SNAT总结"><a href="#SNAT总结" class="headerlink" title="SNAT总结"></a>SNAT总结</h1><p>&#x2F;&#x2F; TODO: 如何作用在postrouting阶段？</p><h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><p>核心是路由器怎么创建NAT表? 使用iptables么? 怎么操作iptables能实现相同功能? </p><h1 id="实践-amp-验证"><a href="#实践-amp-验证" class="headerlink" title="实践&amp;验证"></a>实践&amp;验证</h1><p>&#x2F;&#x2F; TODO: </p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul><li><a href="https://blog.k8s.li/linux-net-and-iptables.html#%E5%85%B3%E7%B3%BB">Linux 网络和 iptables 运行原理</a></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>最近研究关于网络, 有一堆的概念, 一堆的坑要填, 这里先列出来: </p><ul><li>几张表, 作用是啥? 分别如何查看表项? <ul><li>cam表</li><li>arp缓存表</li><li>nat表</li><li>dns缓存表</li></ul></li><li>几种设备: <ul><li>三层交换机与二层交换机区别?</li><li>Linux网桥与交换机有啥区别?</li></ul></li><li>几个技术细节<ul><li>网卡混杂模式? 啥时候下开启? 应用场景是啥?</li><li>会不会收到MAC地址匹配, 但IP地址不匹配的IP包? 具体咋处理? 直接丢弃? 还是可以使用? </li><li>ip forwarding 是啥? 为啥NAT模式下需要开启? 为啥不默认开启? </li><li>ip隧道的原理是啥? </li><li>lvs的几种工作原理再研究, 再实践验证</li><li>组播的应用场景是啥? 很重要么?</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;经常在家用路由器中, 看到有端口映射(PAT)选项, 但不明所以.&lt;br&gt;最近刚好在研究NAT, 知道了&lt;mark&gt;PAT本质是NAT的一种实现方式, 更确切地说是DNAT的一种实现方式&lt;/mark&gt;.&lt;br&gt;因此借此机会好好研究下.&lt;/p&gt;
&lt;h1 id=&quot;DNAT总结&quot;&gt;&lt;a href=&quot;#DNAT总结&quot; class=&quot;headerlink&quot; title=&quot;DNAT总结&quot;&gt;&lt;/a&gt;DNAT总结&lt;/h1&gt;&lt;h2 id=&quot;PAT作用概述&quot;&gt;&lt;a href=&quot;#PAT作用概述&quot; class=&quot;headerlink&quot; title=&quot;PAT作用概述&quot;&gt;&lt;/a&gt;PAT作用概述&lt;/h2&gt;&lt;p&gt;家用路由器中配置PAT, 本质上还是一种&lt;code&gt;内网穿透&lt;/code&gt;的实现方式，或者DNAT的一种方式。&lt;br&gt;即需要把家里内网某台主机的某个服务, 暴露到公网上, 以便能在公网环境下访问该服务.&lt;br&gt;例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;家庭内网网段是&lt;code&gt;192.168.3.0/24&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;家用路由器, 电信运营商分配的对外公网IP是&lt;code&gt;115.192.71.187&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;某台主机IP是&lt;code&gt;192.168.3.213&lt;/code&gt;: &lt;ul&gt;
&lt;li&gt;暴露了8080的某个tomcat服务, 想要把这个服务暴露在公网上, 以便其他人能够访问.&lt;/li&gt;
&lt;li&gt;暴露了远程桌面RDP端口服务, 以便在公司或者咖啡厅, 能访问到该远程桌面.&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此时可以在路由器上开启端口映射(PAT), 将路由器上某个端口(如8888)与内网主机的端口(如8080)如进行映射, 所有访问{路由器IP, 8888端口}的请求, 就会被自动路由到{内网IP, 8080端口}上:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206232339615.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&amp;#x2F;&amp;#x2F; TODO: 这里挖个坑, 内网穿透除了PAT外, 还有其他方案, 例如 &lt;code&gt;花生壳&lt;/code&gt;, 后边新开篇章讲下原理.&lt;/p&gt;
&lt;h2 id=&quot;原理概述&quot;&gt;&lt;a href=&quot;#原理概述&quot; class=&quot;headerlink&quot; title=&quot;原理概述&quot;&gt;&lt;/a&gt;原理概述&lt;/h2&gt;&lt;p&gt;本质上是家用路由器保存了这么一张NAT表:&lt;br&gt;&lt;code&gt;&amp;#123;publicIp, publicPort&amp;#125;&lt;/code&gt; —映射到—&amp;gt; &lt;code&gt;&amp;#123;localIp, localPort&amp;#125;&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://davyjones2010.github.io/tags/linux/"/>
    
    <category term="iaas" scheme="https://davyjones2010.github.io/tags/iaas/"/>
    
    <category term="network" scheme="https://davyjones2010.github.io/tags/network/"/>
    
    <category term="cloud-computing" scheme="https://davyjones2010.github.io/tags/cloud-computing/"/>
    
    <category term="nat" scheme="https://davyjones2010.github.io/tags/nat/"/>
    
    <category term="pat" scheme="https://davyjones2010.github.io/tags/pat/"/>
    
  </entry>
  
  <entry>
    <title>Linux虚拟网络与网络设备</title>
    <link href="https://davyjones2010.github.io/2022-06-19-linux-virtual-network/"/>
    <id>https://davyjones2010.github.io/2022-06-19-linux-virtual-network/</id>
    <published>2022-06-19T16:00:00.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>使用VMWare或者KVM设置VM网络时, 通常会有几种网络模式: </p><ul><li>网桥模式(Bridge模式)</li><li>NAT模式</li></ul><p>之前一直比较迷惑, 不是特别清楚区别, 最近研究终于搞懂了, 总结如下: </p><h1 id="网桥模式"><a href="#网桥模式" class="headerlink" title="网桥模式"></a>网桥模式</h1><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><ol><li>本质上把Linux网桥看做一个二层的交换机.</li><li>VM连接到该网桥, 获取访问外网能力.</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202216042.png" alt="linux-bridge"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>因此</p><ol><li>VM的IP与Host的IP是在同一个网段上的</li><li>VM在网络中的位置与Host是并列的</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202214199.png" alt="VM"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202215507.png" alt="Host"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202216645.png" alt="VM Route Table"></p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><p>网桥操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brctl show<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>安装工具</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> net-tools -yyum <span class="token function">install</span> bridge-utils -y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>配置</p></li></ul><h1 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h1><h2 id="本质-1"><a href="#本质-1" class="headerlink" title="本质"></a>本质</h2><ol><li>本质上是Host看做一个NAT设备</li><li>VM连接到该NAT设备上, 获取访问外网能力.</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202212554.png"></p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>因此</p><ol><li>VM的IP与Host的IP不在同一个网段</li><li>VM在网络中的位置是从属于Host</li></ol><p><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202159960.png" alt="VM在192.168.230.0/24网段"><br><img data-src="https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202200319.png" alt="Host在192.168.3.0/24网段"></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>&#x2F;&#x2F; TODO:</p><h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><p>这里 VM的网桥模式 与 docker的网桥&#x2F;Bridge模式 是有很大区别的。</p><ul><li>VM 网桥&#x2F;桥接模式: VM与HOST在同一个网段。</li><li>Docker Bridge模式： Docker容器与HOST不在同一个网段。<blockquote><p>Bridge 是 docker 默认的网络模式。<br>原理跟 vmware 的 NAT 模式相同。<br>安装 docker 时，会给宿主机创建一个 docker0 网卡，该网卡会与一个虚拟交换机相连，<br>当容器以 Bridge 模式创建启动时，会给容器创建一个虚拟网卡，该网卡分配的 IP 与宿主机的 docker0 所在同一个局域网内 (一般是 172.16.0.0)。<br>然后过程就和 vmware 的 NAT 模式完全相同。</p></blockquote></li></ul><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul><li><a href="https://learnku.com/docs/go-micro-build/1.0/explain-the-network-mode-of-vmware-and-docker/8879"> Vmware和Docker的网络模式讲解</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;使用VMWare或者KVM设置VM网络时, 通常会有几种网络模式: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网桥模式(Bridge模式)&lt;/li&gt;
&lt;li&gt;NAT模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前一直比较迷惑, 不是特别清楚区别, 最近研究终于搞懂了, 总结如下: &lt;/p&gt;
&lt;h1 id=&quot;网桥模式&quot;&gt;&lt;a href=&quot;#网桥模式&quot; class=&quot;headerlink&quot; title=&quot;网桥模式&quot;&gt;&lt;/a&gt;网桥模式&lt;/h1&gt;&lt;h2 id=&quot;本质&quot;&gt;&lt;a href=&quot;#本质&quot; class=&quot;headerlink&quot; title=&quot;本质&quot;&gt;&lt;/a&gt;本质&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;本质上把Linux网桥看做一个二层的交换机.&lt;/li&gt;
&lt;li&gt;VM连接到该网桥, 获取访问外网能力.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&quot;https://davywalker-bucket.oss-cn-shanghai.aliyuncs.com/img/202206202216042.png&quot; alt=&quot;linux-bridge&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h2&gt;&lt;p&gt;因此&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://davyjones2010.github.io/tags/linux/"/>
    
    <category term="iaas" scheme="https://davyjones2010.github.io/tags/iaas/"/>
    
    <category term="network" scheme="https://davyjones2010.github.io/tags/network/"/>
    
    <category term="cloud-computing" scheme="https://davyjones2010.github.io/tags/cloud-computing/"/>
    
    <category term="nat" scheme="https://davyjones2010.github.io/tags/nat/"/>
    
    <category term="pat" scheme="https://davyjones2010.github.io/tags/pat/"/>
    
  </entry>
  
  <entry>
    <title>大学对我的影响</title>
    <link href="https://davyjones2010.github.io/2022-06-17-university-summary/"/>
    <id>https://davyjones2010.github.io/2022-06-17-university-summary/</id>
    <published>2022-06-17T16:00:00.000Z</published>
    <updated>2022-11-02T14:44:57.609Z</updated>
    
    <content type="html"><![CDATA[<p>一年一度如火如荼的高考季结束. 蓦然回首, 自己已然高中毕业13年, 大学也毕业9年了.<br>9年时间, 改变了很多, 足以把一个鲜衣怒马, 意气风发, 唇红齿白的少年, 变成而今房贷和车贷缠身, 视力与体力俱下, 惶惶不可终日的油腻中年.</p><p>但最近也一直在酝酿与反思, 这短短四年的大学生活, 究竟带给了我什么?<br>当我在收到外卖, 外卖员说都怪自己没上大学, 才落得今天下苦力.<br>当我在坐网约车, 司机说要不是自己没上大学, 也不至于现在每天被公司压榨.</p><p>四年的生活, 有什么样的魔力, 真的足以把人群完成阶级划分么?<br>现在把杂乱的思绪总结成文, 聊以慰藉.</p><h1 id="一-让我看到了一个更大的世界"><a href="#一-让我看到了一个更大的世界" class="headerlink" title="一: 让我看到了一个更大的世界"></a>一: 让我看到了一个更大的世界</h1><hr><p>这个话说得可能有点儿大, 有点儿虚, 但确实上大学, 让我这个小镇青年, 有机会第一次离开了那个只有60万人口的小城市,<br>进入到一个二三线城市, 看到了一个更大的世界.</p><h2 id="地理上的冲击"><a href="#地理上的冲击" class="headerlink" title="地理上的冲击"></a>地理上的冲击</h2><p>家乡处于豫西北一个不起眼的角落, 三面环山的盆地, 剩余一面被黄河阻隔.<br>伟大的太行山与王屋山交汇于此. <br>而我从小生活在太行山脚下, 听着愚公移山的故事长大. <br>18岁前从来没有离开过那片大山. <br>年少的我一直很好奇山的后边是什么? 会不会是一片蔚蓝色的大海呢? 会不会是一个喧嚣繁华, 高楼林立, 霓虹闪烁的都市呢?<br>曾经跟随奶奶上坟, 翻越了眼前那座大山, 发现在山的后边, 仍然是山, 是无穷无尽绵延不绝的山, 是目之所及毫无颓势的山脉.<br>沮丧至极.  </p><blockquote><p>没有人知道为什么<br>太阳总下到山的那一边<br>没有人能够告诉我<br>山里面有没有住着神仙<br>多少的日子里总是<br>一个人面对着天空发呆<br>就这么好奇就这么幻想<br>这么孤单的童年</p></blockquote><p>而上大学给了我一次机会,<br>能光明正大理直气壮地彻底逃离这片群山,<br>毅然决然地选择离家2000公里外的厦门.</p><p>我来自大山, <br>我要奔赴向大海. </p><p>第一次到海边, 第一次吃到芒果荔枝肯德基麦当劳, </p><blockquote><p>父母在, 不远游.<br>游必有方.</p></blockquote><h2 id="文化上的冲击"><a href="#文化上的冲击" class="headerlink" title="文化上的冲击"></a>文化上的冲击</h2><p>同学都来自五湖四海, </p><h2 id="思想上的冲击"><a href="#思想上的冲击" class="headerlink" title="思想上的冲击"></a>思想上的冲击</h2><p>很快就体会到了贫富差距与阶级差异.<br>当我还在省吃俭用只为买个100多元的<code>蓝魔MP3</code>, 甚至兴奋地睡不着时, 隔壁宿舍的同学就已经开始用<code>iPod touch</code>通过陀螺仪玩赛车游戏了.<br>当我还在用<code>小灵通</code>的时候, 室友就已经开始用<code>iPhone 3Gs</code>了. 当第一次试用, 彻底颠覆了我的想象, 才知道原来手机可以是这样的. </p><blockquote><p>每次室友手机解锁时, 经典的”咔哒”声音, 令我羡慕, 至今仍在我耳边回响, 是我永远逾越不了的鸿沟.</p></blockquote><p>当我为了省钱, 选择花费120元, 硬座坐43小时火车跨越四千里回家, 腰酸背痛, 双腿浮肿时; 室友与爸妈选择坐飞机, 去香港购物度假.<br>当我知道室友原来竟然没有参加高考, 直接通过竞赛保送到大学; 而我却几乎拼出了半条命, 才得以在当年100万考生中杀出了一条血路.<br>当看到室友的班级通讯录里, 前四五十都是清一色的清北浙交; 我们河南的同伴</p><p>很庆幸自己没有因为这些差异导致走向消极与虚无, 走向愤怒与反抗, 而是接受这些冲击, 这就是生活.<br>然后一点一点地再努力一些, </p><p>当然, 外卖员, 网约车司机可能也是一样, 借由来城市打工.</p><h1 id="二-让我拥有了独立思考与探索知识的能力"><a href="#二-让我拥有了独立思考与探索知识的能力" class="headerlink" title="二: 让我拥有了独立思考与探索知识的能力"></a>二: 让我拥有了独立思考与探索知识的能力</h1><hr><p>第一次在同学宿舍, 看到了墙外的世界.<br>批判型思维.<br>成长型思维.</p><h1 id="三-让我拥有了破除任何神话人物的信心与勇气"><a href="#三-让我拥有了破除任何神话人物的信心与勇气" class="headerlink" title="三: 让我拥有了破除任何神话人物的信心与勇气"></a>三: 让我拥有了破除任何神话人物的信心与勇气</h1><hr><p>正是因为接受了思想上的冲击, 所以至今我心底里从不会崇拜或者神话任何一个人.<br>相信自己</p><h1 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h1><hr><p>最近也在看&lt;规模&gt;这本书, 城市, 真的会让生活更美好么? </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一年一度如火如荼的高考季结束. 蓦然回首, 自己已然高中毕业13年, 大学也毕业9年了.&lt;br&gt;9年时间, 改变了很多, 足以把一个鲜衣怒马, 意气风发, 唇红齿白的少年, 变成而今房贷和车贷缠身, 视力与体力俱下, 惶惶不可终日的油腻中年.&lt;/p&gt;
&lt;p&gt;但最近也一直在酝酿与反思, 这短短四年的大学生活, 究竟带给了我什么?&lt;br&gt;当我在收到外卖, 外卖员说都怪自己没上大学, 才落得今天下苦力.&lt;br&gt;当我在坐网约车, 司机说要不是自己没上大学, 也不至于现在每天被公司压榨.&lt;/p&gt;
&lt;p&gt;四年的生活, 有什么样的魔力, 真的足以把人群完成阶级划分么?&lt;br&gt;现在把杂乱的思绪总结成文, 聊以慰藉.&lt;/p&gt;
&lt;h1 id=&quot;一-让我看到了一个更大的世界&quot;&gt;&lt;a href=&quot;#一-让我看到了一个更大的世界&quot; class=&quot;headerlink&quot; title=&quot;一: 让我看到了一个更大的世界&quot;&gt;&lt;/a&gt;一: 让我看到了一个更大的世界&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;这个话说得可能有点儿大, 有点儿虚, 但确实上大学, 让我这个小镇青年, 有机会第一次离开了那个只有60万人口的小城市,&lt;br&gt;进入到一个二三线城市, 看到了一个更大的世界.&lt;/p&gt;
&lt;h2 id=&quot;地理上的冲击&quot;&gt;&lt;a href=&quot;#地理上的冲击&quot; class=&quot;headerlink&quot; title=&quot;地理上的冲击&quot;&gt;&lt;/a&gt;地理上的冲击&lt;/h2&gt;&lt;p&gt;家乡处于豫西北一个不起眼的角落, 三面环山的盆地, 剩余一面被黄河阻隔.&lt;br&gt;伟大的太行山与王屋山交汇于此. &lt;br&gt;而我从小生活在太行山脚下, 听着愚公移山的故事长大. &lt;br&gt;18岁前从来没有离开过那片大山. &lt;br&gt;年少的我一直很好奇山的后边是什么? 会不会是一片蔚蓝色的大海呢? 会不会是一个喧嚣繁华, 高楼林立, 霓虹闪烁的都市呢?&lt;br&gt;曾经跟随奶奶上坟, 翻越了眼前那座大山, 发现在山的后边, 仍然是山, 是无穷无尽绵延不绝的山, 是目之所及毫无颓势的山脉.&lt;br&gt;沮丧至极.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;没有人知道为什么&lt;br&gt;太阳总下到山的那一边&lt;br&gt;没有人能够告诉我&lt;br&gt;山里面有没有住着神仙&lt;br&gt;多少的日子里总是&lt;br&gt;一个人面对着天空发呆&lt;br&gt;就这么好奇就这么幻想&lt;br&gt;这么孤单的童年&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而上大学给了我一次机会,&lt;br&gt;能光明正大理直气壮地彻底逃离这片群山,&lt;br&gt;毅然决然地选择离家2000公里外的厦门.&lt;/p&gt;</summary>
    
    
    
    
    <category term="weekend" scheme="https://davyjones2010.github.io/tags/weekend/"/>
    
    <category term="diary" scheme="https://davyjones2010.github.io/tags/diary/"/>
    
    <category term="books" scheme="https://davyjones2010.github.io/tags/books/"/>
    
  </entry>
  
</feed>
